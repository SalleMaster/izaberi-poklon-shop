
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model PackageOption
 * 
 */
export type PackageOption = $Result.DefaultSelection<Prisma.$PackageOptionPayload>
/**
 * Model DeliveryService
 * 
 */
export type DeliveryService = $Result.DefaultSelection<Prisma.$DeliveryServicePayload>
/**
 * Model Banner
 * 
 */
export type Banner = $Result.DefaultSelection<Prisma.$BannerPayload>
/**
 * Model Coupon
 * 
 */
export type Coupon = $Result.DefaultSelection<Prisma.$CouponPayload>
/**
 * Model DeliveryFee
 * 
 */
export type DeliveryFee = $Result.DefaultSelection<Prisma.$DeliveryFeePayload>
/**
 * Model PriceRange
 * 
 */
export type PriceRange = $Result.DefaultSelection<Prisma.$PriceRangePayload>
/**
 * Model Discount
 * 
 */
export type Discount = $Result.DefaultSelection<Prisma.$DiscountPayload>
/**
 * Model TextPersonalizationField
 * 
 */
export type TextPersonalizationField = $Result.DefaultSelection<Prisma.$TextPersonalizationFieldPayload>
/**
 * Model ImagePersonalizationField
 * 
 */
export type ImagePersonalizationField = $Result.DefaultSelection<Prisma.$ImagePersonalizationFieldPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Rating
 * 
 */
export type Rating = $Result.DefaultSelection<Prisma.$RatingPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model Cart
 * 
 */
export type Cart = $Result.DefaultSelection<Prisma.$CartPayload>
/**
 * Model CartItem
 * 
 */
export type CartItem = $Result.DefaultSelection<Prisma.$CartItemPayload>
/**
 * Model TextPersonalization
 * 
 */
export type TextPersonalization = $Result.DefaultSelection<Prisma.$TextPersonalizationPayload>
/**
 * Model ImagePersonalization
 * 
 */
export type ImagePersonalization = $Result.DefaultSelection<Prisma.$ImagePersonalizationPayload>
/**
 * Model DeliveryAddress
 * 
 */
export type DeliveryAddress = $Result.DefaultSelection<Prisma.$DeliveryAddressPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRoleType: {
  admin: 'admin',
  user: 'user'
};

export type UserRoleType = (typeof UserRoleType)[keyof typeof UserRoleType]


export const DiscountType: {
  percentage: 'percentage',
  fixed: 'fixed'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]


export const DeliveryType: {
  fast: 'fast',
  slow: 'slow'
};

export type DeliveryType = (typeof DeliveryType)[keyof typeof DeliveryType]


export const FontType: {
  latin: 'latin',
  cyrillic: 'cyrillic'
};

export type FontType = (typeof FontType)[keyof typeof FontType]


export const OrderDeliveryType: {
  delivery: 'delivery',
  pickup: 'pickup'
};

export type OrderDeliveryType = (typeof OrderDeliveryType)[keyof typeof OrderDeliveryType]


export const OrderPaymentType: {
  onDelivery: 'onDelivery',
  card: 'card',
  ips: 'ips',
  bankTransfer: 'bankTransfer'
};

export type OrderPaymentType = (typeof OrderPaymentType)[keyof typeof OrderPaymentType]


export const OrderStatusType: {
  draft: 'draft',
  pending: 'pending',
  processing: 'processing',
  shipped: 'shipped',
  delivered: 'delivered',
  canceled: 'canceled'
};

export type OrderStatusType = (typeof OrderStatusType)[keyof typeof OrderStatusType]


export const OrderPaymentStatusType: {
  pending: 'pending',
  success: 'success',
  failed: 'failed'
};

export type OrderPaymentStatusType = (typeof OrderPaymentStatusType)[keyof typeof OrderPaymentStatusType]


export const DeliveryAddressType: {
  delivery: 'delivery',
  billing: 'billing'
};

export type DeliveryAddressType = (typeof DeliveryAddressType)[keyof typeof DeliveryAddressType]


export const RatingStatusType: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected'
};

export type RatingStatusType = (typeof RatingStatusType)[keyof typeof RatingStatusType]

}

export type UserRoleType = $Enums.UserRoleType

export const UserRoleType: typeof $Enums.UserRoleType

export type DiscountType = $Enums.DiscountType

export const DiscountType: typeof $Enums.DiscountType

export type DeliveryType = $Enums.DeliveryType

export const DeliveryType: typeof $Enums.DeliveryType

export type FontType = $Enums.FontType

export const FontType: typeof $Enums.FontType

export type OrderDeliveryType = $Enums.OrderDeliveryType

export const OrderDeliveryType: typeof $Enums.OrderDeliveryType

export type OrderPaymentType = $Enums.OrderPaymentType

export const OrderPaymentType: typeof $Enums.OrderPaymentType

export type OrderStatusType = $Enums.OrderStatusType

export const OrderStatusType: typeof $Enums.OrderStatusType

export type OrderPaymentStatusType = $Enums.OrderPaymentStatusType

export const OrderPaymentStatusType: typeof $Enums.OrderPaymentStatusType

export type DeliveryAddressType = $Enums.DeliveryAddressType

export const DeliveryAddressType: typeof $Enums.DeliveryAddressType

export type RatingStatusType = $Enums.RatingStatusType

export const RatingStatusType: typeof $Enums.RatingStatusType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Categories
 * const categories = await prisma.category.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Categories
   * const categories = await prisma.category.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.packageOption`: Exposes CRUD operations for the **PackageOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PackageOptions
    * const packageOptions = await prisma.packageOption.findMany()
    * ```
    */
  get packageOption(): Prisma.PackageOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryService`: Exposes CRUD operations for the **DeliveryService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryServices
    * const deliveryServices = await prisma.deliveryService.findMany()
    * ```
    */
  get deliveryService(): Prisma.DeliveryServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.banner`: Exposes CRUD operations for the **Banner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banners
    * const banners = await prisma.banner.findMany()
    * ```
    */
  get banner(): Prisma.BannerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **Coupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupon.findMany()
    * ```
    */
  get coupon(): Prisma.CouponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryFee`: Exposes CRUD operations for the **DeliveryFee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryFees
    * const deliveryFees = await prisma.deliveryFee.findMany()
    * ```
    */
  get deliveryFee(): Prisma.DeliveryFeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.priceRange`: Exposes CRUD operations for the **PriceRange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceRanges
    * const priceRanges = await prisma.priceRange.findMany()
    * ```
    */
  get priceRange(): Prisma.PriceRangeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discount`: Exposes CRUD operations for the **Discount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Discounts
    * const discounts = await prisma.discount.findMany()
    * ```
    */
  get discount(): Prisma.DiscountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.textPersonalizationField`: Exposes CRUD operations for the **TextPersonalizationField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TextPersonalizationFields
    * const textPersonalizationFields = await prisma.textPersonalizationField.findMany()
    * ```
    */
  get textPersonalizationField(): Prisma.TextPersonalizationFieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.imagePersonalizationField`: Exposes CRUD operations for the **ImagePersonalizationField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImagePersonalizationFields
    * const imagePersonalizationFields = await prisma.imagePersonalizationField.findMany()
    * ```
    */
  get imagePersonalizationField(): Prisma.ImagePersonalizationFieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rating`: Exposes CRUD operations for the **Rating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ratings
    * const ratings = await prisma.rating.findMany()
    * ```
    */
  get rating(): Prisma.RatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): Prisma.CartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cartItem`: Exposes CRUD operations for the **CartItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartItems
    * const cartItems = await prisma.cartItem.findMany()
    * ```
    */
  get cartItem(): Prisma.CartItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.textPersonalization`: Exposes CRUD operations for the **TextPersonalization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TextPersonalizations
    * const textPersonalizations = await prisma.textPersonalization.findMany()
    * ```
    */
  get textPersonalization(): Prisma.TextPersonalizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.imagePersonalization`: Exposes CRUD operations for the **ImagePersonalization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImagePersonalizations
    * const imagePersonalizations = await prisma.imagePersonalization.findMany()
    * ```
    */
  get imagePersonalization(): Prisma.ImagePersonalizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryAddress`: Exposes CRUD operations for the **DeliveryAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryAddresses
    * const deliveryAddresses = await prisma.deliveryAddress.findMany()
    * ```
    */
  get deliveryAddress(): Prisma.DeliveryAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.1
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Category: 'Category',
    PackageOption: 'PackageOption',
    DeliveryService: 'DeliveryService',
    Banner: 'Banner',
    Coupon: 'Coupon',
    DeliveryFee: 'DeliveryFee',
    PriceRange: 'PriceRange',
    Discount: 'Discount',
    TextPersonalizationField: 'TextPersonalizationField',
    ImagePersonalizationField: 'ImagePersonalizationField',
    Product: 'Product',
    Rating: 'Rating',
    Media: 'Media',
    Cart: 'Cart',
    CartItem: 'CartItem',
    TextPersonalization: 'TextPersonalization',
    ImagePersonalization: 'ImagePersonalization',
    DeliveryAddress: 'DeliveryAddress',
    Order: 'Order',
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Verification: 'Verification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "category" | "packageOption" | "deliveryService" | "banner" | "coupon" | "deliveryFee" | "priceRange" | "discount" | "textPersonalizationField" | "imagePersonalizationField" | "product" | "rating" | "media" | "cart" | "cartItem" | "textPersonalization" | "imagePersonalization" | "deliveryAddress" | "order" | "user" | "account" | "session" | "verificationToken" | "verification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      PackageOption: {
        payload: Prisma.$PackageOptionPayload<ExtArgs>
        fields: Prisma.PackageOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackageOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackageOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>
          }
          findFirst: {
            args: Prisma.PackageOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackageOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>
          }
          findMany: {
            args: Prisma.PackageOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>[]
          }
          create: {
            args: Prisma.PackageOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>
          }
          createMany: {
            args: Prisma.PackageOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PackageOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>[]
          }
          delete: {
            args: Prisma.PackageOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>
          }
          update: {
            args: Prisma.PackageOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>
          }
          deleteMany: {
            args: Prisma.PackageOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackageOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PackageOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>[]
          }
          upsert: {
            args: Prisma.PackageOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>
          }
          aggregate: {
            args: Prisma.PackageOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackageOption>
          }
          groupBy: {
            args: Prisma.PackageOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackageOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackageOptionCountArgs<ExtArgs>
            result: $Utils.Optional<PackageOptionCountAggregateOutputType> | number
          }
        }
      }
      DeliveryService: {
        payload: Prisma.$DeliveryServicePayload<ExtArgs>
        fields: Prisma.DeliveryServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryServicePayload>
          }
          findFirst: {
            args: Prisma.DeliveryServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryServicePayload>
          }
          findMany: {
            args: Prisma.DeliveryServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryServicePayload>[]
          }
          create: {
            args: Prisma.DeliveryServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryServicePayload>
          }
          createMany: {
            args: Prisma.DeliveryServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryServicePayload>[]
          }
          delete: {
            args: Prisma.DeliveryServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryServicePayload>
          }
          update: {
            args: Prisma.DeliveryServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryServicePayload>
          }
          deleteMany: {
            args: Prisma.DeliveryServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryServicePayload>[]
          }
          upsert: {
            args: Prisma.DeliveryServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryServicePayload>
          }
          aggregate: {
            args: Prisma.DeliveryServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryService>
          }
          groupBy: {
            args: Prisma.DeliveryServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryServiceCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryServiceCountAggregateOutputType> | number
          }
        }
      }
      Banner: {
        payload: Prisma.$BannerPayload<ExtArgs>
        fields: Prisma.BannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findFirst: {
            args: Prisma.BannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findMany: {
            args: Prisma.BannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          create: {
            args: Prisma.BannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          createMany: {
            args: Prisma.BannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BannerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          delete: {
            args: Prisma.BannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          update: {
            args: Prisma.BannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          deleteMany: {
            args: Prisma.BannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BannerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          upsert: {
            args: Prisma.BannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          aggregate: {
            args: Prisma.BannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBanner>
          }
          groupBy: {
            args: Prisma.BannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerCountArgs<ExtArgs>
            result: $Utils.Optional<BannerCountAggregateOutputType> | number
          }
        }
      }
      Coupon: {
        payload: Prisma.$CouponPayload<ExtArgs>
        fields: Prisma.CouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findFirst: {
            args: Prisma.CouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findMany: {
            args: Prisma.CouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          create: {
            args: Prisma.CouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          createMany: {
            args: Prisma.CouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CouponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          delete: {
            args: Prisma.CouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          update: {
            args: Prisma.CouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          deleteMany: {
            args: Prisma.CouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CouponUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          upsert: {
            args: Prisma.CouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          aggregate: {
            args: Prisma.CouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupon>
          }
          groupBy: {
            args: Prisma.CouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouponCountArgs<ExtArgs>
            result: $Utils.Optional<CouponCountAggregateOutputType> | number
          }
        }
      }
      DeliveryFee: {
        payload: Prisma.$DeliveryFeePayload<ExtArgs>
        fields: Prisma.DeliveryFeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryFeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryFeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryFeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryFeePayload>
          }
          findFirst: {
            args: Prisma.DeliveryFeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryFeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryFeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryFeePayload>
          }
          findMany: {
            args: Prisma.DeliveryFeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryFeePayload>[]
          }
          create: {
            args: Prisma.DeliveryFeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryFeePayload>
          }
          createMany: {
            args: Prisma.DeliveryFeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryFeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryFeePayload>[]
          }
          delete: {
            args: Prisma.DeliveryFeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryFeePayload>
          }
          update: {
            args: Prisma.DeliveryFeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryFeePayload>
          }
          deleteMany: {
            args: Prisma.DeliveryFeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryFeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryFeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryFeePayload>[]
          }
          upsert: {
            args: Prisma.DeliveryFeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryFeePayload>
          }
          aggregate: {
            args: Prisma.DeliveryFeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryFee>
          }
          groupBy: {
            args: Prisma.DeliveryFeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryFeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryFeeCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryFeeCountAggregateOutputType> | number
          }
        }
      }
      PriceRange: {
        payload: Prisma.$PriceRangePayload<ExtArgs>
        fields: Prisma.PriceRangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceRangeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceRangeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRangePayload>
          }
          findFirst: {
            args: Prisma.PriceRangeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceRangeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRangePayload>
          }
          findMany: {
            args: Prisma.PriceRangeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRangePayload>[]
          }
          create: {
            args: Prisma.PriceRangeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRangePayload>
          }
          createMany: {
            args: Prisma.PriceRangeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceRangeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRangePayload>[]
          }
          delete: {
            args: Prisma.PriceRangeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRangePayload>
          }
          update: {
            args: Prisma.PriceRangeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRangePayload>
          }
          deleteMany: {
            args: Prisma.PriceRangeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceRangeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PriceRangeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRangePayload>[]
          }
          upsert: {
            args: Prisma.PriceRangeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRangePayload>
          }
          aggregate: {
            args: Prisma.PriceRangeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceRange>
          }
          groupBy: {
            args: Prisma.PriceRangeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceRangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceRangeCountArgs<ExtArgs>
            result: $Utils.Optional<PriceRangeCountAggregateOutputType> | number
          }
        }
      }
      Discount: {
        payload: Prisma.$DiscountPayload<ExtArgs>
        fields: Prisma.DiscountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          findFirst: {
            args: Prisma.DiscountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          findMany: {
            args: Prisma.DiscountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          create: {
            args: Prisma.DiscountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          createMany: {
            args: Prisma.DiscountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiscountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          delete: {
            args: Prisma.DiscountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          update: {
            args: Prisma.DiscountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          deleteMany: {
            args: Prisma.DiscountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiscountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          upsert: {
            args: Prisma.DiscountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          aggregate: {
            args: Prisma.DiscountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscount>
          }
          groupBy: {
            args: Prisma.DiscountGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscountGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscountCountArgs<ExtArgs>
            result: $Utils.Optional<DiscountCountAggregateOutputType> | number
          }
        }
      }
      TextPersonalizationField: {
        payload: Prisma.$TextPersonalizationFieldPayload<ExtArgs>
        fields: Prisma.TextPersonalizationFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TextPersonalizationFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TextPersonalizationFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationFieldPayload>
          }
          findFirst: {
            args: Prisma.TextPersonalizationFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TextPersonalizationFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationFieldPayload>
          }
          findMany: {
            args: Prisma.TextPersonalizationFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationFieldPayload>[]
          }
          create: {
            args: Prisma.TextPersonalizationFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationFieldPayload>
          }
          createMany: {
            args: Prisma.TextPersonalizationFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TextPersonalizationFieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationFieldPayload>[]
          }
          delete: {
            args: Prisma.TextPersonalizationFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationFieldPayload>
          }
          update: {
            args: Prisma.TextPersonalizationFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationFieldPayload>
          }
          deleteMany: {
            args: Prisma.TextPersonalizationFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TextPersonalizationFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TextPersonalizationFieldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationFieldPayload>[]
          }
          upsert: {
            args: Prisma.TextPersonalizationFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationFieldPayload>
          }
          aggregate: {
            args: Prisma.TextPersonalizationFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTextPersonalizationField>
          }
          groupBy: {
            args: Prisma.TextPersonalizationFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<TextPersonalizationFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.TextPersonalizationFieldCountArgs<ExtArgs>
            result: $Utils.Optional<TextPersonalizationFieldCountAggregateOutputType> | number
          }
        }
      }
      ImagePersonalizationField: {
        payload: Prisma.$ImagePersonalizationFieldPayload<ExtArgs>
        fields: Prisma.ImagePersonalizationFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImagePersonalizationFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImagePersonalizationFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationFieldPayload>
          }
          findFirst: {
            args: Prisma.ImagePersonalizationFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImagePersonalizationFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationFieldPayload>
          }
          findMany: {
            args: Prisma.ImagePersonalizationFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationFieldPayload>[]
          }
          create: {
            args: Prisma.ImagePersonalizationFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationFieldPayload>
          }
          createMany: {
            args: Prisma.ImagePersonalizationFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImagePersonalizationFieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationFieldPayload>[]
          }
          delete: {
            args: Prisma.ImagePersonalizationFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationFieldPayload>
          }
          update: {
            args: Prisma.ImagePersonalizationFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationFieldPayload>
          }
          deleteMany: {
            args: Prisma.ImagePersonalizationFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImagePersonalizationFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImagePersonalizationFieldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationFieldPayload>[]
          }
          upsert: {
            args: Prisma.ImagePersonalizationFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationFieldPayload>
          }
          aggregate: {
            args: Prisma.ImagePersonalizationFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImagePersonalizationField>
          }
          groupBy: {
            args: Prisma.ImagePersonalizationFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImagePersonalizationFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImagePersonalizationFieldCountArgs<ExtArgs>
            result: $Utils.Optional<ImagePersonalizationFieldCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Rating: {
        payload: Prisma.$RatingPayload<ExtArgs>
        fields: Prisma.RatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findFirst: {
            args: Prisma.RatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findMany: {
            args: Prisma.RatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          create: {
            args: Prisma.RatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          createMany: {
            args: Prisma.RatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          delete: {
            args: Prisma.RatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          update: {
            args: Prisma.RatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          deleteMany: {
            args: Prisma.RatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          upsert: {
            args: Prisma.RatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          aggregate: {
            args: Prisma.RatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRating>
          }
          groupBy: {
            args: Prisma.RatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.RatingCountArgs<ExtArgs>
            result: $Utils.Optional<RatingCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      Cart: {
        payload: Prisma.$CartPayload<ExtArgs>
        fields: Prisma.CartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findFirst: {
            args: Prisma.CartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findMany: {
            args: Prisma.CartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          create: {
            args: Prisma.CartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          createMany: {
            args: Prisma.CartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          delete: {
            args: Prisma.CartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          update: {
            args: Prisma.CartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          deleteMany: {
            args: Prisma.CartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          upsert: {
            args: Prisma.CartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCart>
          }
          groupBy: {
            args: Prisma.CartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartCountArgs<ExtArgs>
            result: $Utils.Optional<CartCountAggregateOutputType> | number
          }
        }
      }
      CartItem: {
        payload: Prisma.$CartItemPayload<ExtArgs>
        fields: Prisma.CartItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findFirst: {
            args: Prisma.CartItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findMany: {
            args: Prisma.CartItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          create: {
            args: Prisma.CartItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          createMany: {
            args: Prisma.CartItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          delete: {
            args: Prisma.CartItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          update: {
            args: Prisma.CartItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          deleteMany: {
            args: Prisma.CartItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          upsert: {
            args: Prisma.CartItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          aggregate: {
            args: Prisma.CartItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCartItem>
          }
          groupBy: {
            args: Prisma.CartItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartItemCountArgs<ExtArgs>
            result: $Utils.Optional<CartItemCountAggregateOutputType> | number
          }
        }
      }
      TextPersonalization: {
        payload: Prisma.$TextPersonalizationPayload<ExtArgs>
        fields: Prisma.TextPersonalizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TextPersonalizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TextPersonalizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationPayload>
          }
          findFirst: {
            args: Prisma.TextPersonalizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TextPersonalizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationPayload>
          }
          findMany: {
            args: Prisma.TextPersonalizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationPayload>[]
          }
          create: {
            args: Prisma.TextPersonalizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationPayload>
          }
          createMany: {
            args: Prisma.TextPersonalizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TextPersonalizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationPayload>[]
          }
          delete: {
            args: Prisma.TextPersonalizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationPayload>
          }
          update: {
            args: Prisma.TextPersonalizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationPayload>
          }
          deleteMany: {
            args: Prisma.TextPersonalizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TextPersonalizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TextPersonalizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationPayload>[]
          }
          upsert: {
            args: Prisma.TextPersonalizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextPersonalizationPayload>
          }
          aggregate: {
            args: Prisma.TextPersonalizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTextPersonalization>
          }
          groupBy: {
            args: Prisma.TextPersonalizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TextPersonalizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TextPersonalizationCountArgs<ExtArgs>
            result: $Utils.Optional<TextPersonalizationCountAggregateOutputType> | number
          }
        }
      }
      ImagePersonalization: {
        payload: Prisma.$ImagePersonalizationPayload<ExtArgs>
        fields: Prisma.ImagePersonalizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImagePersonalizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImagePersonalizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationPayload>
          }
          findFirst: {
            args: Prisma.ImagePersonalizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImagePersonalizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationPayload>
          }
          findMany: {
            args: Prisma.ImagePersonalizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationPayload>[]
          }
          create: {
            args: Prisma.ImagePersonalizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationPayload>
          }
          createMany: {
            args: Prisma.ImagePersonalizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImagePersonalizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationPayload>[]
          }
          delete: {
            args: Prisma.ImagePersonalizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationPayload>
          }
          update: {
            args: Prisma.ImagePersonalizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationPayload>
          }
          deleteMany: {
            args: Prisma.ImagePersonalizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImagePersonalizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImagePersonalizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationPayload>[]
          }
          upsert: {
            args: Prisma.ImagePersonalizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePersonalizationPayload>
          }
          aggregate: {
            args: Prisma.ImagePersonalizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImagePersonalization>
          }
          groupBy: {
            args: Prisma.ImagePersonalizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImagePersonalizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImagePersonalizationCountArgs<ExtArgs>
            result: $Utils.Optional<ImagePersonalizationCountAggregateOutputType> | number
          }
        }
      }
      DeliveryAddress: {
        payload: Prisma.$DeliveryAddressPayload<ExtArgs>
        fields: Prisma.DeliveryAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>
          }
          findFirst: {
            args: Prisma.DeliveryAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>
          }
          findMany: {
            args: Prisma.DeliveryAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>[]
          }
          create: {
            args: Prisma.DeliveryAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>
          }
          createMany: {
            args: Prisma.DeliveryAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>[]
          }
          delete: {
            args: Prisma.DeliveryAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>
          }
          update: {
            args: Prisma.DeliveryAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryAddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAddressPayload>
          }
          aggregate: {
            args: Prisma.DeliveryAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryAddress>
          }
          groupBy: {
            args: Prisma.DeliveryAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryAddressCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryAddressCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    category?: CategoryOmit
    packageOption?: PackageOptionOmit
    deliveryService?: DeliveryServiceOmit
    banner?: BannerOmit
    coupon?: CouponOmit
    deliveryFee?: DeliveryFeeOmit
    priceRange?: PriceRangeOmit
    discount?: DiscountOmit
    textPersonalizationField?: TextPersonalizationFieldOmit
    imagePersonalizationField?: ImagePersonalizationFieldOmit
    product?: ProductOmit
    rating?: RatingOmit
    media?: MediaOmit
    cart?: CartOmit
    cartItem?: CartItemOmit
    textPersonalization?: TextPersonalizationOmit
    imagePersonalization?: ImagePersonalizationOmit
    deliveryAddress?: DeliveryAddressOmit
    order?: OrderOmit
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    verification?: VerificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type PackageOptionCountOutputType
   */

  export type PackageOptionCountOutputType = {
    products: number
  }

  export type PackageOptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | PackageOptionCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * PackageOptionCountOutputType without action
   */
  export type PackageOptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOptionCountOutputType
     */
    select?: PackageOptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PackageOptionCountOutputType without action
   */
  export type PackageOptionCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type CouponCountOutputType
   */

  export type CouponCountOutputType = {
    carts: number
  }

  export type CouponCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carts?: boolean | CouponCountOutputTypeCountCartsArgs
  }

  // Custom InputTypes
  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponCountOutputType
     */
    select?: CouponCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountCartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
  }


  /**
   * Count Type DeliveryFeeCountOutputType
   */

  export type DeliveryFeeCountOutputType = {
    priceRange: number
  }

  export type DeliveryFeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceRange?: boolean | DeliveryFeeCountOutputTypeCountPriceRangeArgs
  }

  // Custom InputTypes
  /**
   * DeliveryFeeCountOutputType without action
   */
  export type DeliveryFeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryFeeCountOutputType
     */
    select?: DeliveryFeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeliveryFeeCountOutputType without action
   */
  export type DeliveryFeeCountOutputTypeCountPriceRangeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceRangeWhereInput
  }


  /**
   * Count Type DiscountCountOutputType
   */

  export type DiscountCountOutputType = {
    products: number
  }

  export type DiscountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | DiscountCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * DiscountCountOutputType without action
   */
  export type DiscountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountCountOutputType
     */
    select?: DiscountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DiscountCountOutputType without action
   */
  export type DiscountCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    categories: number
    priceTable: number
    images: number
    imagePersonalizationFields: number
    textPersonalizationFields: number
    cartItems: number
    ratings: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | ProductCountOutputTypeCountCategoriesArgs
    priceTable?: boolean | ProductCountOutputTypeCountPriceTableArgs
    images?: boolean | ProductCountOutputTypeCountImagesArgs
    imagePersonalizationFields?: boolean | ProductCountOutputTypeCountImagePersonalizationFieldsArgs
    textPersonalizationFields?: boolean | ProductCountOutputTypeCountTextPersonalizationFieldsArgs
    cartItems?: boolean | ProductCountOutputTypeCountCartItemsArgs
    ratings?: boolean | ProductCountOutputTypeCountRatingsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPriceTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceRangeWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountImagePersonalizationFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImagePersonalizationFieldWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTextPersonalizationFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextPersonalizationFieldWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }


  /**
   * Count Type CartCountOutputType
   */

  export type CartCountOutputType = {
    items: number
  }

  export type CartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CartCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartCountOutputType
     */
    select?: CartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }


  /**
   * Count Type CartItemCountOutputType
   */

  export type CartItemCountOutputType = {
    textPersonalizations: number
    imagePersonalizations: number
  }

  export type CartItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    textPersonalizations?: boolean | CartItemCountOutputTypeCountTextPersonalizationsArgs
    imagePersonalizations?: boolean | CartItemCountOutputTypeCountImagePersonalizationsArgs
  }

  // Custom InputTypes
  /**
   * CartItemCountOutputType without action
   */
  export type CartItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemCountOutputType
     */
    select?: CartItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CartItemCountOutputType without action
   */
  export type CartItemCountOutputTypeCountTextPersonalizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextPersonalizationWhereInput
  }

  /**
   * CartItemCountOutputType without action
   */
  export type CartItemCountOutputTypeCountImagePersonalizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImagePersonalizationWhereInput
  }


  /**
   * Count Type ImagePersonalizationCountOutputType
   */

  export type ImagePersonalizationCountOutputType = {
    images: number
  }

  export type ImagePersonalizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | ImagePersonalizationCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * ImagePersonalizationCountOutputType without action
   */
  export type ImagePersonalizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalizationCountOutputType
     */
    select?: ImagePersonalizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImagePersonalizationCountOutputType without action
   */
  export type ImagePersonalizationCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    media: number
    deliveryAddresses: number
    orders: number
    ratings: number
    accounts: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | UserCountOutputTypeCountMediaArgs
    deliveryAddresses?: boolean | UserCountOutputTypeCountDeliveryAddressesArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    ratings?: boolean | UserCountOutputTypeCountRatingsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeliveryAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryAddressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    position: number | null
  }

  export type CategorySumAggregateOutputType = {
    position: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    active: boolean | null
    special: boolean | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    active: boolean | null
    special: boolean | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    active: number
    special: number
    position: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    position?: true
  }

  export type CategorySumAggregateInputType = {
    position?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    active?: true
    special?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    active?: true
    special?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    active?: true
    special?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    active: boolean
    special: boolean
    position: number
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    active?: boolean
    special?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    image?: boolean | Category$imageArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    active?: boolean
    special?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    active?: boolean
    special?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    active?: boolean
    special?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "active" | "special" | "position" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    image?: boolean | Category$imageArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      image: Prisma.$MediaPayload<ExtArgs> | null
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      active: boolean
      special: boolean
      position: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    image<T extends Category$imageArgs<ExtArgs> = {}>(args?: Subset<T, Category$imageArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly active: FieldRef<"Category", 'Boolean'>
    readonly special: FieldRef<"Category", 'Boolean'>
    readonly position: FieldRef<"Category", 'Int'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.image
   */
  export type Category$imageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model PackageOption
   */

  export type AggregatePackageOption = {
    _count: PackageOptionCountAggregateOutputType | null
    _avg: PackageOptionAvgAggregateOutputType | null
    _sum: PackageOptionSumAggregateOutputType | null
    _min: PackageOptionMinAggregateOutputType | null
    _max: PackageOptionMaxAggregateOutputType | null
  }

  export type PackageOptionAvgAggregateOutputType = {
    price: number | null
  }

  export type PackageOptionSumAggregateOutputType = {
    price: number | null
  }

  export type PackageOptionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackageOptionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackageOptionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PackageOptionAvgAggregateInputType = {
    price?: true
  }

  export type PackageOptionSumAggregateInputType = {
    price?: true
  }

  export type PackageOptionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackageOptionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackageOptionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PackageOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageOption to aggregate.
     */
    where?: PackageOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageOptions to fetch.
     */
    orderBy?: PackageOptionOrderByWithRelationInput | PackageOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackageOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PackageOptions
    **/
    _count?: true | PackageOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackageOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackageOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackageOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackageOptionMaxAggregateInputType
  }

  export type GetPackageOptionAggregateType<T extends PackageOptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePackageOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackageOption[P]>
      : GetScalarType<T[P], AggregatePackageOption[P]>
  }




  export type PackageOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageOptionWhereInput
    orderBy?: PackageOptionOrderByWithAggregationInput | PackageOptionOrderByWithAggregationInput[]
    by: PackageOptionScalarFieldEnum[] | PackageOptionScalarFieldEnum
    having?: PackageOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackageOptionCountAggregateInputType | true
    _avg?: PackageOptionAvgAggregateInputType
    _sum?: PackageOptionSumAggregateInputType
    _min?: PackageOptionMinAggregateInputType
    _max?: PackageOptionMaxAggregateInputType
  }

  export type PackageOptionGroupByOutputType = {
    id: string
    name: string
    description: string
    price: number
    createdAt: Date
    updatedAt: Date
    _count: PackageOptionCountAggregateOutputType | null
    _avg: PackageOptionAvgAggregateOutputType | null
    _sum: PackageOptionSumAggregateOutputType | null
    _min: PackageOptionMinAggregateOutputType | null
    _max: PackageOptionMaxAggregateOutputType | null
  }

  type GetPackageOptionGroupByPayload<T extends PackageOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackageOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackageOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackageOptionGroupByOutputType[P]>
            : GetScalarType<T[P], PackageOptionGroupByOutputType[P]>
        }
      >
    >


  export type PackageOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | PackageOption$productsArgs<ExtArgs>
    _count?: boolean | PackageOptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packageOption"]>

  export type PackageOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["packageOption"]>

  export type PackageOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["packageOption"]>

  export type PackageOptionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PackageOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "createdAt" | "updatedAt", ExtArgs["result"]["packageOption"]>
  export type PackageOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | PackageOption$productsArgs<ExtArgs>
    _count?: boolean | PackageOptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PackageOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PackageOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PackageOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PackageOption"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      price: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["packageOption"]>
    composites: {}
  }

  type PackageOptionGetPayload<S extends boolean | null | undefined | PackageOptionDefaultArgs> = $Result.GetResult<Prisma.$PackageOptionPayload, S>

  type PackageOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PackageOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PackageOptionCountAggregateInputType | true
    }

  export interface PackageOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PackageOption'], meta: { name: 'PackageOption' } }
    /**
     * Find zero or one PackageOption that matches the filter.
     * @param {PackageOptionFindUniqueArgs} args - Arguments to find a PackageOption
     * @example
     * // Get one PackageOption
     * const packageOption = await prisma.packageOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackageOptionFindUniqueArgs>(args: SelectSubset<T, PackageOptionFindUniqueArgs<ExtArgs>>): Prisma__PackageOptionClient<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PackageOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PackageOptionFindUniqueOrThrowArgs} args - Arguments to find a PackageOption
     * @example
     * // Get one PackageOption
     * const packageOption = await prisma.packageOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackageOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PackageOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackageOptionClient<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PackageOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageOptionFindFirstArgs} args - Arguments to find a PackageOption
     * @example
     * // Get one PackageOption
     * const packageOption = await prisma.packageOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackageOptionFindFirstArgs>(args?: SelectSubset<T, PackageOptionFindFirstArgs<ExtArgs>>): Prisma__PackageOptionClient<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PackageOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageOptionFindFirstOrThrowArgs} args - Arguments to find a PackageOption
     * @example
     * // Get one PackageOption
     * const packageOption = await prisma.packageOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackageOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PackageOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackageOptionClient<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PackageOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PackageOptions
     * const packageOptions = await prisma.packageOption.findMany()
     * 
     * // Get first 10 PackageOptions
     * const packageOptions = await prisma.packageOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packageOptionWithIdOnly = await prisma.packageOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackageOptionFindManyArgs>(args?: SelectSubset<T, PackageOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PackageOption.
     * @param {PackageOptionCreateArgs} args - Arguments to create a PackageOption.
     * @example
     * // Create one PackageOption
     * const PackageOption = await prisma.packageOption.create({
     *   data: {
     *     // ... data to create a PackageOption
     *   }
     * })
     * 
     */
    create<T extends PackageOptionCreateArgs>(args: SelectSubset<T, PackageOptionCreateArgs<ExtArgs>>): Prisma__PackageOptionClient<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PackageOptions.
     * @param {PackageOptionCreateManyArgs} args - Arguments to create many PackageOptions.
     * @example
     * // Create many PackageOptions
     * const packageOption = await prisma.packageOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackageOptionCreateManyArgs>(args?: SelectSubset<T, PackageOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PackageOptions and returns the data saved in the database.
     * @param {PackageOptionCreateManyAndReturnArgs} args - Arguments to create many PackageOptions.
     * @example
     * // Create many PackageOptions
     * const packageOption = await prisma.packageOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PackageOptions and only return the `id`
     * const packageOptionWithIdOnly = await prisma.packageOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PackageOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PackageOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PackageOption.
     * @param {PackageOptionDeleteArgs} args - Arguments to delete one PackageOption.
     * @example
     * // Delete one PackageOption
     * const PackageOption = await prisma.packageOption.delete({
     *   where: {
     *     // ... filter to delete one PackageOption
     *   }
     * })
     * 
     */
    delete<T extends PackageOptionDeleteArgs>(args: SelectSubset<T, PackageOptionDeleteArgs<ExtArgs>>): Prisma__PackageOptionClient<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PackageOption.
     * @param {PackageOptionUpdateArgs} args - Arguments to update one PackageOption.
     * @example
     * // Update one PackageOption
     * const packageOption = await prisma.packageOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackageOptionUpdateArgs>(args: SelectSubset<T, PackageOptionUpdateArgs<ExtArgs>>): Prisma__PackageOptionClient<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PackageOptions.
     * @param {PackageOptionDeleteManyArgs} args - Arguments to filter PackageOptions to delete.
     * @example
     * // Delete a few PackageOptions
     * const { count } = await prisma.packageOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackageOptionDeleteManyArgs>(args?: SelectSubset<T, PackageOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackageOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PackageOptions
     * const packageOption = await prisma.packageOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackageOptionUpdateManyArgs>(args: SelectSubset<T, PackageOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackageOptions and returns the data updated in the database.
     * @param {PackageOptionUpdateManyAndReturnArgs} args - Arguments to update many PackageOptions.
     * @example
     * // Update many PackageOptions
     * const packageOption = await prisma.packageOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PackageOptions and only return the `id`
     * const packageOptionWithIdOnly = await prisma.packageOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PackageOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PackageOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PackageOption.
     * @param {PackageOptionUpsertArgs} args - Arguments to update or create a PackageOption.
     * @example
     * // Update or create a PackageOption
     * const packageOption = await prisma.packageOption.upsert({
     *   create: {
     *     // ... data to create a PackageOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PackageOption we want to update
     *   }
     * })
     */
    upsert<T extends PackageOptionUpsertArgs>(args: SelectSubset<T, PackageOptionUpsertArgs<ExtArgs>>): Prisma__PackageOptionClient<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PackageOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageOptionCountArgs} args - Arguments to filter PackageOptions to count.
     * @example
     * // Count the number of PackageOptions
     * const count = await prisma.packageOption.count({
     *   where: {
     *     // ... the filter for the PackageOptions we want to count
     *   }
     * })
    **/
    count<T extends PackageOptionCountArgs>(
      args?: Subset<T, PackageOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackageOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PackageOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackageOptionAggregateArgs>(args: Subset<T, PackageOptionAggregateArgs>): Prisma.PrismaPromise<GetPackageOptionAggregateType<T>>

    /**
     * Group by PackageOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackageOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackageOptionGroupByArgs['orderBy'] }
        : { orderBy?: PackageOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackageOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackageOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PackageOption model
   */
  readonly fields: PackageOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PackageOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackageOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends PackageOption$productsArgs<ExtArgs> = {}>(args?: Subset<T, PackageOption$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PackageOption model
   */
  interface PackageOptionFieldRefs {
    readonly id: FieldRef<"PackageOption", 'String'>
    readonly name: FieldRef<"PackageOption", 'String'>
    readonly description: FieldRef<"PackageOption", 'String'>
    readonly price: FieldRef<"PackageOption", 'Int'>
    readonly createdAt: FieldRef<"PackageOption", 'DateTime'>
    readonly updatedAt: FieldRef<"PackageOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PackageOption findUnique
   */
  export type PackageOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageOptionInclude<ExtArgs> | null
    /**
     * Filter, which PackageOption to fetch.
     */
    where: PackageOptionWhereUniqueInput
  }

  /**
   * PackageOption findUniqueOrThrow
   */
  export type PackageOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageOptionInclude<ExtArgs> | null
    /**
     * Filter, which PackageOption to fetch.
     */
    where: PackageOptionWhereUniqueInput
  }

  /**
   * PackageOption findFirst
   */
  export type PackageOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageOptionInclude<ExtArgs> | null
    /**
     * Filter, which PackageOption to fetch.
     */
    where?: PackageOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageOptions to fetch.
     */
    orderBy?: PackageOptionOrderByWithRelationInput | PackageOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageOptions.
     */
    cursor?: PackageOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageOptions.
     */
    distinct?: PackageOptionScalarFieldEnum | PackageOptionScalarFieldEnum[]
  }

  /**
   * PackageOption findFirstOrThrow
   */
  export type PackageOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageOptionInclude<ExtArgs> | null
    /**
     * Filter, which PackageOption to fetch.
     */
    where?: PackageOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageOptions to fetch.
     */
    orderBy?: PackageOptionOrderByWithRelationInput | PackageOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageOptions.
     */
    cursor?: PackageOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageOptions.
     */
    distinct?: PackageOptionScalarFieldEnum | PackageOptionScalarFieldEnum[]
  }

  /**
   * PackageOption findMany
   */
  export type PackageOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageOptionInclude<ExtArgs> | null
    /**
     * Filter, which PackageOptions to fetch.
     */
    where?: PackageOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageOptions to fetch.
     */
    orderBy?: PackageOptionOrderByWithRelationInput | PackageOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PackageOptions.
     */
    cursor?: PackageOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageOptions.
     */
    skip?: number
    distinct?: PackageOptionScalarFieldEnum | PackageOptionScalarFieldEnum[]
  }

  /**
   * PackageOption create
   */
  export type PackageOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PackageOption.
     */
    data: XOR<PackageOptionCreateInput, PackageOptionUncheckedCreateInput>
  }

  /**
   * PackageOption createMany
   */
  export type PackageOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PackageOptions.
     */
    data: PackageOptionCreateManyInput | PackageOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackageOption createManyAndReturn
   */
  export type PackageOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * The data used to create many PackageOptions.
     */
    data: PackageOptionCreateManyInput | PackageOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackageOption update
   */
  export type PackageOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PackageOption.
     */
    data: XOR<PackageOptionUpdateInput, PackageOptionUncheckedUpdateInput>
    /**
     * Choose, which PackageOption to update.
     */
    where: PackageOptionWhereUniqueInput
  }

  /**
   * PackageOption updateMany
   */
  export type PackageOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PackageOptions.
     */
    data: XOR<PackageOptionUpdateManyMutationInput, PackageOptionUncheckedUpdateManyInput>
    /**
     * Filter which PackageOptions to update
     */
    where?: PackageOptionWhereInput
    /**
     * Limit how many PackageOptions to update.
     */
    limit?: number
  }

  /**
   * PackageOption updateManyAndReturn
   */
  export type PackageOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * The data used to update PackageOptions.
     */
    data: XOR<PackageOptionUpdateManyMutationInput, PackageOptionUncheckedUpdateManyInput>
    /**
     * Filter which PackageOptions to update
     */
    where?: PackageOptionWhereInput
    /**
     * Limit how many PackageOptions to update.
     */
    limit?: number
  }

  /**
   * PackageOption upsert
   */
  export type PackageOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PackageOption to update in case it exists.
     */
    where: PackageOptionWhereUniqueInput
    /**
     * In case the PackageOption found by the `where` argument doesn't exist, create a new PackageOption with this data.
     */
    create: XOR<PackageOptionCreateInput, PackageOptionUncheckedCreateInput>
    /**
     * In case the PackageOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackageOptionUpdateInput, PackageOptionUncheckedUpdateInput>
  }

  /**
   * PackageOption delete
   */
  export type PackageOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageOptionInclude<ExtArgs> | null
    /**
     * Filter which PackageOption to delete.
     */
    where: PackageOptionWhereUniqueInput
  }

  /**
   * PackageOption deleteMany
   */
  export type PackageOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageOptions to delete
     */
    where?: PackageOptionWhereInput
    /**
     * Limit how many PackageOptions to delete.
     */
    limit?: number
  }

  /**
   * PackageOption.products
   */
  export type PackageOption$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * PackageOption without action
   */
  export type PackageOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageOptionInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryService
   */

  export type AggregateDeliveryService = {
    _count: DeliveryServiceCountAggregateOutputType | null
    _min: DeliveryServiceMinAggregateOutputType | null
    _max: DeliveryServiceMaxAggregateOutputType | null
  }

  export type DeliveryServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    link: string | null
    active: boolean | null
    predefinedPrices: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    link: string | null
    active: boolean | null
    predefinedPrices: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryServiceCountAggregateOutputType = {
    id: number
    name: number
    link: number
    active: number
    predefinedPrices: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeliveryServiceMinAggregateInputType = {
    id?: true
    name?: true
    link?: true
    active?: true
    predefinedPrices?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryServiceMaxAggregateInputType = {
    id?: true
    name?: true
    link?: true
    active?: true
    predefinedPrices?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryServiceCountAggregateInputType = {
    id?: true
    name?: true
    link?: true
    active?: true
    predefinedPrices?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeliveryServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryService to aggregate.
     */
    where?: DeliveryServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryServices to fetch.
     */
    orderBy?: DeliveryServiceOrderByWithRelationInput | DeliveryServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryServices
    **/
    _count?: true | DeliveryServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryServiceMaxAggregateInputType
  }

  export type GetDeliveryServiceAggregateType<T extends DeliveryServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryService[P]>
      : GetScalarType<T[P], AggregateDeliveryService[P]>
  }




  export type DeliveryServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryServiceWhereInput
    orderBy?: DeliveryServiceOrderByWithAggregationInput | DeliveryServiceOrderByWithAggregationInput[]
    by: DeliveryServiceScalarFieldEnum[] | DeliveryServiceScalarFieldEnum
    having?: DeliveryServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryServiceCountAggregateInputType | true
    _min?: DeliveryServiceMinAggregateInputType
    _max?: DeliveryServiceMaxAggregateInputType
  }

  export type DeliveryServiceGroupByOutputType = {
    id: string
    name: string
    link: string
    active: boolean
    predefinedPrices: boolean
    createdAt: Date
    updatedAt: Date
    _count: DeliveryServiceCountAggregateOutputType | null
    _min: DeliveryServiceMinAggregateOutputType | null
    _max: DeliveryServiceMaxAggregateOutputType | null
  }

  type GetDeliveryServiceGroupByPayload<T extends DeliveryServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryServiceGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryServiceGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
    active?: boolean
    predefinedPrices?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pdf?: boolean | DeliveryService$pdfArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryService"]>

  export type DeliveryServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
    active?: boolean
    predefinedPrices?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["deliveryService"]>

  export type DeliveryServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
    active?: boolean
    predefinedPrices?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["deliveryService"]>

  export type DeliveryServiceSelectScalar = {
    id?: boolean
    name?: boolean
    link?: boolean
    active?: boolean
    predefinedPrices?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeliveryServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "link" | "active" | "predefinedPrices" | "createdAt" | "updatedAt", ExtArgs["result"]["deliveryService"]>
  export type DeliveryServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pdf?: boolean | DeliveryService$pdfArgs<ExtArgs>
  }
  export type DeliveryServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DeliveryServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DeliveryServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryService"
    objects: {
      pdf: Prisma.$MediaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      link: string
      active: boolean
      predefinedPrices: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deliveryService"]>
    composites: {}
  }

  type DeliveryServiceGetPayload<S extends boolean | null | undefined | DeliveryServiceDefaultArgs> = $Result.GetResult<Prisma.$DeliveryServicePayload, S>

  type DeliveryServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryServiceCountAggregateInputType | true
    }

  export interface DeliveryServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryService'], meta: { name: 'DeliveryService' } }
    /**
     * Find zero or one DeliveryService that matches the filter.
     * @param {DeliveryServiceFindUniqueArgs} args - Arguments to find a DeliveryService
     * @example
     * // Get one DeliveryService
     * const deliveryService = await prisma.deliveryService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryServiceFindUniqueArgs>(args: SelectSubset<T, DeliveryServiceFindUniqueArgs<ExtArgs>>): Prisma__DeliveryServiceClient<$Result.GetResult<Prisma.$DeliveryServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryServiceFindUniqueOrThrowArgs} args - Arguments to find a DeliveryService
     * @example
     * // Get one DeliveryService
     * const deliveryService = await prisma.deliveryService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryServiceClient<$Result.GetResult<Prisma.$DeliveryServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryServiceFindFirstArgs} args - Arguments to find a DeliveryService
     * @example
     * // Get one DeliveryService
     * const deliveryService = await prisma.deliveryService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryServiceFindFirstArgs>(args?: SelectSubset<T, DeliveryServiceFindFirstArgs<ExtArgs>>): Prisma__DeliveryServiceClient<$Result.GetResult<Prisma.$DeliveryServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryServiceFindFirstOrThrowArgs} args - Arguments to find a DeliveryService
     * @example
     * // Get one DeliveryService
     * const deliveryService = await prisma.deliveryService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryServiceClient<$Result.GetResult<Prisma.$DeliveryServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryServices
     * const deliveryServices = await prisma.deliveryService.findMany()
     * 
     * // Get first 10 DeliveryServices
     * const deliveryServices = await prisma.deliveryService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryServiceWithIdOnly = await prisma.deliveryService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryServiceFindManyArgs>(args?: SelectSubset<T, DeliveryServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryService.
     * @param {DeliveryServiceCreateArgs} args - Arguments to create a DeliveryService.
     * @example
     * // Create one DeliveryService
     * const DeliveryService = await prisma.deliveryService.create({
     *   data: {
     *     // ... data to create a DeliveryService
     *   }
     * })
     * 
     */
    create<T extends DeliveryServiceCreateArgs>(args: SelectSubset<T, DeliveryServiceCreateArgs<ExtArgs>>): Prisma__DeliveryServiceClient<$Result.GetResult<Prisma.$DeliveryServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryServices.
     * @param {DeliveryServiceCreateManyArgs} args - Arguments to create many DeliveryServices.
     * @example
     * // Create many DeliveryServices
     * const deliveryService = await prisma.deliveryService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryServiceCreateManyArgs>(args?: SelectSubset<T, DeliveryServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryServices and returns the data saved in the database.
     * @param {DeliveryServiceCreateManyAndReturnArgs} args - Arguments to create many DeliveryServices.
     * @example
     * // Create many DeliveryServices
     * const deliveryService = await prisma.deliveryService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryServices and only return the `id`
     * const deliveryServiceWithIdOnly = await prisma.deliveryService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryService.
     * @param {DeliveryServiceDeleteArgs} args - Arguments to delete one DeliveryService.
     * @example
     * // Delete one DeliveryService
     * const DeliveryService = await prisma.deliveryService.delete({
     *   where: {
     *     // ... filter to delete one DeliveryService
     *   }
     * })
     * 
     */
    delete<T extends DeliveryServiceDeleteArgs>(args: SelectSubset<T, DeliveryServiceDeleteArgs<ExtArgs>>): Prisma__DeliveryServiceClient<$Result.GetResult<Prisma.$DeliveryServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryService.
     * @param {DeliveryServiceUpdateArgs} args - Arguments to update one DeliveryService.
     * @example
     * // Update one DeliveryService
     * const deliveryService = await prisma.deliveryService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryServiceUpdateArgs>(args: SelectSubset<T, DeliveryServiceUpdateArgs<ExtArgs>>): Prisma__DeliveryServiceClient<$Result.GetResult<Prisma.$DeliveryServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryServices.
     * @param {DeliveryServiceDeleteManyArgs} args - Arguments to filter DeliveryServices to delete.
     * @example
     * // Delete a few DeliveryServices
     * const { count } = await prisma.deliveryService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryServiceDeleteManyArgs>(args?: SelectSubset<T, DeliveryServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryServices
     * const deliveryService = await prisma.deliveryService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryServiceUpdateManyArgs>(args: SelectSubset<T, DeliveryServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryServices and returns the data updated in the database.
     * @param {DeliveryServiceUpdateManyAndReturnArgs} args - Arguments to update many DeliveryServices.
     * @example
     * // Update many DeliveryServices
     * const deliveryService = await prisma.deliveryService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryServices and only return the `id`
     * const deliveryServiceWithIdOnly = await prisma.deliveryService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryService.
     * @param {DeliveryServiceUpsertArgs} args - Arguments to update or create a DeliveryService.
     * @example
     * // Update or create a DeliveryService
     * const deliveryService = await prisma.deliveryService.upsert({
     *   create: {
     *     // ... data to create a DeliveryService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryService we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryServiceUpsertArgs>(args: SelectSubset<T, DeliveryServiceUpsertArgs<ExtArgs>>): Prisma__DeliveryServiceClient<$Result.GetResult<Prisma.$DeliveryServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryServiceCountArgs} args - Arguments to filter DeliveryServices to count.
     * @example
     * // Count the number of DeliveryServices
     * const count = await prisma.deliveryService.count({
     *   where: {
     *     // ... the filter for the DeliveryServices we want to count
     *   }
     * })
    **/
    count<T extends DeliveryServiceCountArgs>(
      args?: Subset<T, DeliveryServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryServiceAggregateArgs>(args: Subset<T, DeliveryServiceAggregateArgs>): Prisma.PrismaPromise<GetDeliveryServiceAggregateType<T>>

    /**
     * Group by DeliveryService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryServiceGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryService model
   */
  readonly fields: DeliveryServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pdf<T extends DeliveryService$pdfArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryService$pdfArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryService model
   */
  interface DeliveryServiceFieldRefs {
    readonly id: FieldRef<"DeliveryService", 'String'>
    readonly name: FieldRef<"DeliveryService", 'String'>
    readonly link: FieldRef<"DeliveryService", 'String'>
    readonly active: FieldRef<"DeliveryService", 'Boolean'>
    readonly predefinedPrices: FieldRef<"DeliveryService", 'Boolean'>
    readonly createdAt: FieldRef<"DeliveryService", 'DateTime'>
    readonly updatedAt: FieldRef<"DeliveryService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryService findUnique
   */
  export type DeliveryServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryService
     */
    select?: DeliveryServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryService
     */
    omit?: DeliveryServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryServiceInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryService to fetch.
     */
    where: DeliveryServiceWhereUniqueInput
  }

  /**
   * DeliveryService findUniqueOrThrow
   */
  export type DeliveryServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryService
     */
    select?: DeliveryServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryService
     */
    omit?: DeliveryServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryServiceInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryService to fetch.
     */
    where: DeliveryServiceWhereUniqueInput
  }

  /**
   * DeliveryService findFirst
   */
  export type DeliveryServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryService
     */
    select?: DeliveryServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryService
     */
    omit?: DeliveryServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryServiceInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryService to fetch.
     */
    where?: DeliveryServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryServices to fetch.
     */
    orderBy?: DeliveryServiceOrderByWithRelationInput | DeliveryServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryServices.
     */
    cursor?: DeliveryServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryServices.
     */
    distinct?: DeliveryServiceScalarFieldEnum | DeliveryServiceScalarFieldEnum[]
  }

  /**
   * DeliveryService findFirstOrThrow
   */
  export type DeliveryServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryService
     */
    select?: DeliveryServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryService
     */
    omit?: DeliveryServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryServiceInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryService to fetch.
     */
    where?: DeliveryServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryServices to fetch.
     */
    orderBy?: DeliveryServiceOrderByWithRelationInput | DeliveryServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryServices.
     */
    cursor?: DeliveryServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryServices.
     */
    distinct?: DeliveryServiceScalarFieldEnum | DeliveryServiceScalarFieldEnum[]
  }

  /**
   * DeliveryService findMany
   */
  export type DeliveryServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryService
     */
    select?: DeliveryServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryService
     */
    omit?: DeliveryServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryServiceInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryServices to fetch.
     */
    where?: DeliveryServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryServices to fetch.
     */
    orderBy?: DeliveryServiceOrderByWithRelationInput | DeliveryServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryServices.
     */
    cursor?: DeliveryServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryServices.
     */
    skip?: number
    distinct?: DeliveryServiceScalarFieldEnum | DeliveryServiceScalarFieldEnum[]
  }

  /**
   * DeliveryService create
   */
  export type DeliveryServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryService
     */
    select?: DeliveryServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryService
     */
    omit?: DeliveryServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryService.
     */
    data: XOR<DeliveryServiceCreateInput, DeliveryServiceUncheckedCreateInput>
  }

  /**
   * DeliveryService createMany
   */
  export type DeliveryServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryServices.
     */
    data: DeliveryServiceCreateManyInput | DeliveryServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryService createManyAndReturn
   */
  export type DeliveryServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryService
     */
    select?: DeliveryServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryService
     */
    omit?: DeliveryServiceOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryServices.
     */
    data: DeliveryServiceCreateManyInput | DeliveryServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryService update
   */
  export type DeliveryServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryService
     */
    select?: DeliveryServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryService
     */
    omit?: DeliveryServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryService.
     */
    data: XOR<DeliveryServiceUpdateInput, DeliveryServiceUncheckedUpdateInput>
    /**
     * Choose, which DeliveryService to update.
     */
    where: DeliveryServiceWhereUniqueInput
  }

  /**
   * DeliveryService updateMany
   */
  export type DeliveryServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryServices.
     */
    data: XOR<DeliveryServiceUpdateManyMutationInput, DeliveryServiceUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryServices to update
     */
    where?: DeliveryServiceWhereInput
    /**
     * Limit how many DeliveryServices to update.
     */
    limit?: number
  }

  /**
   * DeliveryService updateManyAndReturn
   */
  export type DeliveryServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryService
     */
    select?: DeliveryServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryService
     */
    omit?: DeliveryServiceOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryServices.
     */
    data: XOR<DeliveryServiceUpdateManyMutationInput, DeliveryServiceUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryServices to update
     */
    where?: DeliveryServiceWhereInput
    /**
     * Limit how many DeliveryServices to update.
     */
    limit?: number
  }

  /**
   * DeliveryService upsert
   */
  export type DeliveryServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryService
     */
    select?: DeliveryServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryService
     */
    omit?: DeliveryServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryService to update in case it exists.
     */
    where: DeliveryServiceWhereUniqueInput
    /**
     * In case the DeliveryService found by the `where` argument doesn't exist, create a new DeliveryService with this data.
     */
    create: XOR<DeliveryServiceCreateInput, DeliveryServiceUncheckedCreateInput>
    /**
     * In case the DeliveryService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryServiceUpdateInput, DeliveryServiceUncheckedUpdateInput>
  }

  /**
   * DeliveryService delete
   */
  export type DeliveryServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryService
     */
    select?: DeliveryServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryService
     */
    omit?: DeliveryServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryServiceInclude<ExtArgs> | null
    /**
     * Filter which DeliveryService to delete.
     */
    where: DeliveryServiceWhereUniqueInput
  }

  /**
   * DeliveryService deleteMany
   */
  export type DeliveryServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryServices to delete
     */
    where?: DeliveryServiceWhereInput
    /**
     * Limit how many DeliveryServices to delete.
     */
    limit?: number
  }

  /**
   * DeliveryService.pdf
   */
  export type DeliveryService$pdfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * DeliveryService without action
   */
  export type DeliveryServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryService
     */
    select?: DeliveryServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryService
     */
    omit?: DeliveryServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryServiceInclude<ExtArgs> | null
  }


  /**
   * Model Banner
   */

  export type AggregateBanner = {
    _count: BannerCountAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  export type BannerMinAggregateOutputType = {
    id: string | null
    name: string | null
    link: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    link: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerCountAggregateOutputType = {
    id: number
    name: number
    link: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BannerMinAggregateInputType = {
    id?: true
    name?: true
    link?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerMaxAggregateInputType = {
    id?: true
    name?: true
    link?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerCountAggregateInputType = {
    id?: true
    name?: true
    link?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banner to aggregate.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banners
    **/
    _count?: true | BannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerMaxAggregateInputType
  }

  export type GetBannerAggregateType<T extends BannerAggregateArgs> = {
        [P in keyof T & keyof AggregateBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner[P]>
      : GetScalarType<T[P], AggregateBanner[P]>
  }




  export type BannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithAggregationInput | BannerOrderByWithAggregationInput[]
    by: BannerScalarFieldEnum[] | BannerScalarFieldEnum
    having?: BannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerCountAggregateInputType | true
    _min?: BannerMinAggregateInputType
    _max?: BannerMaxAggregateInputType
  }

  export type BannerGroupByOutputType = {
    id: string
    name: string
    link: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: BannerCountAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  type GetBannerGroupByPayload<T extends BannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerGroupByOutputType[P]>
            : GetScalarType<T[P], BannerGroupByOutputType[P]>
        }
      >
    >


  export type BannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    desktopImage?: boolean | Banner$desktopImageArgs<ExtArgs>
    mobileImage?: boolean | Banner$mobileImageArgs<ExtArgs>
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectScalar = {
    id?: boolean
    name?: boolean
    link?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BannerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "link" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["banner"]>
  export type BannerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    desktopImage?: boolean | Banner$desktopImageArgs<ExtArgs>
    mobileImage?: boolean | Banner$mobileImageArgs<ExtArgs>
  }
  export type BannerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BannerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Banner"
    objects: {
      desktopImage: Prisma.$MediaPayload<ExtArgs> | null
      mobileImage: Prisma.$MediaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      link: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["banner"]>
    composites: {}
  }

  type BannerGetPayload<S extends boolean | null | undefined | BannerDefaultArgs> = $Result.GetResult<Prisma.$BannerPayload, S>

  type BannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BannerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannerCountAggregateInputType | true
    }

  export interface BannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Banner'], meta: { name: 'Banner' } }
    /**
     * Find zero or one Banner that matches the filter.
     * @param {BannerFindUniqueArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerFindUniqueArgs>(args: SelectSubset<T, BannerFindUniqueArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Banner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BannerFindUniqueOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerFindFirstArgs>(args?: SelectSubset<T, BannerFindFirstArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banner.findMany()
     * 
     * // Get first 10 Banners
     * const banners = await prisma.banner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerWithIdOnly = await prisma.banner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerFindManyArgs>(args?: SelectSubset<T, BannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Banner.
     * @param {BannerCreateArgs} args - Arguments to create a Banner.
     * @example
     * // Create one Banner
     * const Banner = await prisma.banner.create({
     *   data: {
     *     // ... data to create a Banner
     *   }
     * })
     * 
     */
    create<T extends BannerCreateArgs>(args: SelectSubset<T, BannerCreateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Banners.
     * @param {BannerCreateManyArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerCreateManyArgs>(args?: SelectSubset<T, BannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Banners and returns the data saved in the database.
     * @param {BannerCreateManyAndReturnArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Banners and only return the `id`
     * const bannerWithIdOnly = await prisma.banner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BannerCreateManyAndReturnArgs>(args?: SelectSubset<T, BannerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Banner.
     * @param {BannerDeleteArgs} args - Arguments to delete one Banner.
     * @example
     * // Delete one Banner
     * const Banner = await prisma.banner.delete({
     *   where: {
     *     // ... filter to delete one Banner
     *   }
     * })
     * 
     */
    delete<T extends BannerDeleteArgs>(args: SelectSubset<T, BannerDeleteArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Banner.
     * @param {BannerUpdateArgs} args - Arguments to update one Banner.
     * @example
     * // Update one Banner
     * const banner = await prisma.banner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerUpdateArgs>(args: SelectSubset<T, BannerUpdateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Banners.
     * @param {BannerDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerDeleteManyArgs>(args?: SelectSubset<T, BannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerUpdateManyArgs>(args: SelectSubset<T, BannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners and returns the data updated in the database.
     * @param {BannerUpdateManyAndReturnArgs} args - Arguments to update many Banners.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Banners and only return the `id`
     * const bannerWithIdOnly = await prisma.banner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BannerUpdateManyAndReturnArgs>(args: SelectSubset<T, BannerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Banner.
     * @param {BannerUpsertArgs} args - Arguments to update or create a Banner.
     * @example
     * // Update or create a Banner
     * const banner = await prisma.banner.upsert({
     *   create: {
     *     // ... data to create a Banner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner we want to update
     *   }
     * })
     */
    upsert<T extends BannerUpsertArgs>(args: SelectSubset<T, BannerUpsertArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banner.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
    **/
    count<T extends BannerCountArgs>(
      args?: Subset<T, BannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerAggregateArgs>(args: Subset<T, BannerAggregateArgs>): Prisma.PrismaPromise<GetBannerAggregateType<T>>

    /**
     * Group by Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerGroupByArgs['orderBy'] }
        : { orderBy?: BannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Banner model
   */
  readonly fields: BannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Banner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    desktopImage<T extends Banner$desktopImageArgs<ExtArgs> = {}>(args?: Subset<T, Banner$desktopImageArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mobileImage<T extends Banner$mobileImageArgs<ExtArgs> = {}>(args?: Subset<T, Banner$mobileImageArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Banner model
   */
  interface BannerFieldRefs {
    readonly id: FieldRef<"Banner", 'String'>
    readonly name: FieldRef<"Banner", 'String'>
    readonly link: FieldRef<"Banner", 'String'>
    readonly active: FieldRef<"Banner", 'Boolean'>
    readonly createdAt: FieldRef<"Banner", 'DateTime'>
    readonly updatedAt: FieldRef<"Banner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Banner findUnique
   */
  export type BannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findUniqueOrThrow
   */
  export type BannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findFirst
   */
  export type BannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findFirstOrThrow
   */
  export type BannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findMany
   */
  export type BannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banners to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner create
   */
  export type BannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * The data needed to create a Banner.
     */
    data: XOR<BannerCreateInput, BannerUncheckedCreateInput>
  }

  /**
   * Banner createMany
   */
  export type BannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Banner createManyAndReturn
   */
  export type BannerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Banner update
   */
  export type BannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * The data needed to update a Banner.
     */
    data: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
    /**
     * Choose, which Banner to update.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner updateMany
   */
  export type BannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to update.
     */
    limit?: number
  }

  /**
   * Banner updateManyAndReturn
   */
  export type BannerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to update.
     */
    limit?: number
  }

  /**
   * Banner upsert
   */
  export type BannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * The filter to search for the Banner to update in case it exists.
     */
    where: BannerWhereUniqueInput
    /**
     * In case the Banner found by the `where` argument doesn't exist, create a new Banner with this data.
     */
    create: XOR<BannerCreateInput, BannerUncheckedCreateInput>
    /**
     * In case the Banner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
  }

  /**
   * Banner delete
   */
  export type BannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter which Banner to delete.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner deleteMany
   */
  export type BannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banners to delete
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to delete.
     */
    limit?: number
  }

  /**
   * Banner.desktopImage
   */
  export type Banner$desktopImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Banner.mobileImage
   */
  export type Banner$mobileImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Banner without action
   */
  export type BannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
  }


  /**
   * Model Coupon
   */

  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  export type CouponAvgAggregateOutputType = {
    discount: number | null
    cartValue: number | null
    available: number | null
    used: number | null
  }

  export type CouponSumAggregateOutputType = {
    discount: number | null
    cartValue: number | null
    available: number | null
    used: number | null
  }

  export type CouponMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    discountType: $Enums.DiscountType | null
    discount: number | null
    cartValue: number | null
    available: number | null
    used: number | null
    active: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    discountType: $Enums.DiscountType | null
    discount: number | null
    cartValue: number | null
    available: number | null
    used: number | null
    active: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponCountAggregateOutputType = {
    id: number
    name: number
    code: number
    discountType: number
    discount: number
    cartValue: number
    available: number
    used: number
    active: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CouponAvgAggregateInputType = {
    discount?: true
    cartValue?: true
    available?: true
    used?: true
  }

  export type CouponSumAggregateInputType = {
    discount?: true
    cartValue?: true
    available?: true
    used?: true
  }

  export type CouponMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    discountType?: true
    discount?: true
    cartValue?: true
    available?: true
    used?: true
    active?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    discountType?: true
    discount?: true
    cartValue?: true
    available?: true
    used?: true
    active?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    discountType?: true
    discount?: true
    cartValue?: true
    available?: true
    used?: true
    active?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupon to aggregate.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coupons
    **/
    _count?: true | CouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponMaxAggregateInputType
  }

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>
  }




  export type CouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithAggregationInput | CouponOrderByWithAggregationInput[]
    by: CouponScalarFieldEnum[] | CouponScalarFieldEnum
    having?: CouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponCountAggregateInputType | true
    _avg?: CouponAvgAggregateInputType
    _sum?: CouponSumAggregateInputType
    _min?: CouponMinAggregateInputType
    _max?: CouponMaxAggregateInputType
  }

  export type CouponGroupByOutputType = {
    id: string
    name: string
    code: string
    discountType: $Enums.DiscountType
    discount: number
    cartValue: number
    available: number
    used: number
    active: boolean
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  type GetCouponGroupByPayload<T extends CouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
        }
      >
    >


  export type CouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    discountType?: boolean
    discount?: boolean
    cartValue?: boolean
    available?: boolean
    used?: boolean
    active?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    carts?: boolean | Coupon$cartsArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    discountType?: boolean
    discount?: boolean
    cartValue?: boolean
    available?: boolean
    used?: boolean
    active?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    discountType?: boolean
    discount?: boolean
    cartValue?: boolean
    available?: boolean
    used?: boolean
    active?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    discountType?: boolean
    discount?: boolean
    cartValue?: boolean
    available?: boolean
    used?: boolean
    active?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CouponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "discountType" | "discount" | "cartValue" | "available" | "used" | "active" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["coupon"]>
  export type CouponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carts?: boolean | Coupon$cartsArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CouponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CouponIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coupon"
    objects: {
      carts: Prisma.$CartPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      discountType: $Enums.DiscountType
      discount: number
      cartValue: number
      available: number
      used: number
      active: boolean
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coupon"]>
    composites: {}
  }

  type CouponGetPayload<S extends boolean | null | undefined | CouponDefaultArgs> = $Result.GetResult<Prisma.$CouponPayload, S>

  type CouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CouponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CouponCountAggregateInputType | true
    }

  export interface CouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coupon'], meta: { name: 'Coupon' } }
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {CouponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponFindUniqueArgs>(args: SelectSubset<T, CouponFindUniqueArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CouponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponFindUniqueOrThrowArgs>(args: SelectSubset<T, CouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponFindFirstArgs>(args?: SelectSubset<T, CouponFindFirstArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponFindFirstOrThrowArgs>(args?: SelectSubset<T, CouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouponFindManyArgs>(args?: SelectSubset<T, CouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coupon.
     * @param {CouponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     * 
     */
    create<T extends CouponCreateArgs>(args: SelectSubset<T, CouponCreateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coupons.
     * @param {CouponCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouponCreateManyArgs>(args?: SelectSubset<T, CouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coupons and returns the data saved in the database.
     * @param {CouponCreateManyAndReturnArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CouponCreateManyAndReturnArgs>(args?: SelectSubset<T, CouponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Coupon.
     * @param {CouponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     * 
     */
    delete<T extends CouponDeleteArgs>(args: SelectSubset<T, CouponDeleteArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coupon.
     * @param {CouponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouponUpdateArgs>(args: SelectSubset<T, CouponUpdateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coupons.
     * @param {CouponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouponDeleteManyArgs>(args?: SelectSubset<T, CouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouponUpdateManyArgs>(args: SelectSubset<T, CouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons and returns the data updated in the database.
     * @param {CouponUpdateManyAndReturnArgs} args - Arguments to update many Coupons.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CouponUpdateManyAndReturnArgs>(args: SelectSubset<T, CouponUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Coupon.
     * @param {CouponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
     */
    upsert<T extends CouponUpsertArgs>(args: SelectSubset<T, CouponUpsertArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends CouponCountArgs>(
      args?: Subset<T, CouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponAggregateArgs>(args: Subset<T, CouponAggregateArgs>): Prisma.PrismaPromise<GetCouponAggregateType<T>>

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponGroupByArgs['orderBy'] }
        : { orderBy?: CouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coupon model
   */
  readonly fields: CouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    carts<T extends Coupon$cartsArgs<ExtArgs> = {}>(args?: Subset<T, Coupon$cartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coupon model
   */
  interface CouponFieldRefs {
    readonly id: FieldRef<"Coupon", 'String'>
    readonly name: FieldRef<"Coupon", 'String'>
    readonly code: FieldRef<"Coupon", 'String'>
    readonly discountType: FieldRef<"Coupon", 'DiscountType'>
    readonly discount: FieldRef<"Coupon", 'Int'>
    readonly cartValue: FieldRef<"Coupon", 'Int'>
    readonly available: FieldRef<"Coupon", 'Int'>
    readonly used: FieldRef<"Coupon", 'Int'>
    readonly active: FieldRef<"Coupon", 'Boolean'>
    readonly expiresAt: FieldRef<"Coupon", 'DateTime'>
    readonly createdAt: FieldRef<"Coupon", 'DateTime'>
    readonly updatedAt: FieldRef<"Coupon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Coupon findUnique
   */
  export type CouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findUniqueOrThrow
   */
  export type CouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findFirst
   */
  export type CouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findFirstOrThrow
   */
  export type CouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findMany
   */
  export type CouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon create
   */
  export type CouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to create a Coupon.
     */
    data: XOR<CouponCreateInput, CouponUncheckedCreateInput>
  }

  /**
   * Coupon createMany
   */
  export type CouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupon createManyAndReturn
   */
  export type CouponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupon update
   */
  export type CouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to update a Coupon.
     */
    data: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
    /**
     * Choose, which Coupon to update.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon updateMany
   */
  export type CouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to update.
     */
    limit?: number
  }

  /**
   * Coupon updateManyAndReturn
   */
  export type CouponUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to update.
     */
    limit?: number
  }

  /**
   * Coupon upsert
   */
  export type CouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The filter to search for the Coupon to update in case it exists.
     */
    where: CouponWhereUniqueInput
    /**
     * In case the Coupon found by the `where` argument doesn't exist, create a new Coupon with this data.
     */
    create: XOR<CouponCreateInput, CouponUncheckedCreateInput>
    /**
     * In case the Coupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
  }

  /**
   * Coupon delete
   */
  export type CouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter which Coupon to delete.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon deleteMany
   */
  export type CouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupons to delete
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to delete.
     */
    limit?: number
  }

  /**
   * Coupon.carts
   */
  export type Coupon$cartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    where?: CartWhereInput
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    cursor?: CartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Coupon without action
   */
  export type CouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryFee
   */

  export type AggregateDeliveryFee = {
    _count: DeliveryFeeCountAggregateOutputType | null
    _avg: DeliveryFeeAvgAggregateOutputType | null
    _sum: DeliveryFeeSumAggregateOutputType | null
    _min: DeliveryFeeMinAggregateOutputType | null
    _max: DeliveryFeeMaxAggregateOutputType | null
  }

  export type DeliveryFeeAvgAggregateOutputType = {
    fee: number | null
  }

  export type DeliveryFeeSumAggregateOutputType = {
    fee: number | null
  }

  export type DeliveryFeeMinAggregateOutputType = {
    id: string | null
    name: string | null
    fee: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryFeeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    fee: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryFeeCountAggregateOutputType = {
    id: number
    name: number
    fee: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeliveryFeeAvgAggregateInputType = {
    fee?: true
  }

  export type DeliveryFeeSumAggregateInputType = {
    fee?: true
  }

  export type DeliveryFeeMinAggregateInputType = {
    id?: true
    name?: true
    fee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryFeeMaxAggregateInputType = {
    id?: true
    name?: true
    fee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryFeeCountAggregateInputType = {
    id?: true
    name?: true
    fee?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeliveryFeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryFee to aggregate.
     */
    where?: DeliveryFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryFees to fetch.
     */
    orderBy?: DeliveryFeeOrderByWithRelationInput | DeliveryFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryFees
    **/
    _count?: true | DeliveryFeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryFeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryFeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryFeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryFeeMaxAggregateInputType
  }

  export type GetDeliveryFeeAggregateType<T extends DeliveryFeeAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryFee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryFee[P]>
      : GetScalarType<T[P], AggregateDeliveryFee[P]>
  }




  export type DeliveryFeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryFeeWhereInput
    orderBy?: DeliveryFeeOrderByWithAggregationInput | DeliveryFeeOrderByWithAggregationInput[]
    by: DeliveryFeeScalarFieldEnum[] | DeliveryFeeScalarFieldEnum
    having?: DeliveryFeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryFeeCountAggregateInputType | true
    _avg?: DeliveryFeeAvgAggregateInputType
    _sum?: DeliveryFeeSumAggregateInputType
    _min?: DeliveryFeeMinAggregateInputType
    _max?: DeliveryFeeMaxAggregateInputType
  }

  export type DeliveryFeeGroupByOutputType = {
    id: string
    name: string
    fee: number
    createdAt: Date
    updatedAt: Date
    _count: DeliveryFeeCountAggregateOutputType | null
    _avg: DeliveryFeeAvgAggregateOutputType | null
    _sum: DeliveryFeeSumAggregateOutputType | null
    _min: DeliveryFeeMinAggregateOutputType | null
    _max: DeliveryFeeMaxAggregateOutputType | null
  }

  type GetDeliveryFeeGroupByPayload<T extends DeliveryFeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryFeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryFeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryFeeGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryFeeGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryFeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    priceRange?: boolean | DeliveryFee$priceRangeArgs<ExtArgs>
    _count?: boolean | DeliveryFeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryFee"]>

  export type DeliveryFeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["deliveryFee"]>

  export type DeliveryFeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["deliveryFee"]>

  export type DeliveryFeeSelectScalar = {
    id?: boolean
    name?: boolean
    fee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeliveryFeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "fee" | "createdAt" | "updatedAt", ExtArgs["result"]["deliveryFee"]>
  export type DeliveryFeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceRange?: boolean | DeliveryFee$priceRangeArgs<ExtArgs>
    _count?: boolean | DeliveryFeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeliveryFeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DeliveryFeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DeliveryFeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryFee"
    objects: {
      priceRange: Prisma.$PriceRangePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      fee: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deliveryFee"]>
    composites: {}
  }

  type DeliveryFeeGetPayload<S extends boolean | null | undefined | DeliveryFeeDefaultArgs> = $Result.GetResult<Prisma.$DeliveryFeePayload, S>

  type DeliveryFeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryFeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryFeeCountAggregateInputType | true
    }

  export interface DeliveryFeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryFee'], meta: { name: 'DeliveryFee' } }
    /**
     * Find zero or one DeliveryFee that matches the filter.
     * @param {DeliveryFeeFindUniqueArgs} args - Arguments to find a DeliveryFee
     * @example
     * // Get one DeliveryFee
     * const deliveryFee = await prisma.deliveryFee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryFeeFindUniqueArgs>(args: SelectSubset<T, DeliveryFeeFindUniqueArgs<ExtArgs>>): Prisma__DeliveryFeeClient<$Result.GetResult<Prisma.$DeliveryFeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryFee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryFeeFindUniqueOrThrowArgs} args - Arguments to find a DeliveryFee
     * @example
     * // Get one DeliveryFee
     * const deliveryFee = await prisma.deliveryFee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryFeeFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryFeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryFeeClient<$Result.GetResult<Prisma.$DeliveryFeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryFee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFeeFindFirstArgs} args - Arguments to find a DeliveryFee
     * @example
     * // Get one DeliveryFee
     * const deliveryFee = await prisma.deliveryFee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryFeeFindFirstArgs>(args?: SelectSubset<T, DeliveryFeeFindFirstArgs<ExtArgs>>): Prisma__DeliveryFeeClient<$Result.GetResult<Prisma.$DeliveryFeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryFee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFeeFindFirstOrThrowArgs} args - Arguments to find a DeliveryFee
     * @example
     * // Get one DeliveryFee
     * const deliveryFee = await prisma.deliveryFee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryFeeFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryFeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryFeeClient<$Result.GetResult<Prisma.$DeliveryFeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryFees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryFees
     * const deliveryFees = await prisma.deliveryFee.findMany()
     * 
     * // Get first 10 DeliveryFees
     * const deliveryFees = await prisma.deliveryFee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryFeeWithIdOnly = await prisma.deliveryFee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryFeeFindManyArgs>(args?: SelectSubset<T, DeliveryFeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryFeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryFee.
     * @param {DeliveryFeeCreateArgs} args - Arguments to create a DeliveryFee.
     * @example
     * // Create one DeliveryFee
     * const DeliveryFee = await prisma.deliveryFee.create({
     *   data: {
     *     // ... data to create a DeliveryFee
     *   }
     * })
     * 
     */
    create<T extends DeliveryFeeCreateArgs>(args: SelectSubset<T, DeliveryFeeCreateArgs<ExtArgs>>): Prisma__DeliveryFeeClient<$Result.GetResult<Prisma.$DeliveryFeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryFees.
     * @param {DeliveryFeeCreateManyArgs} args - Arguments to create many DeliveryFees.
     * @example
     * // Create many DeliveryFees
     * const deliveryFee = await prisma.deliveryFee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryFeeCreateManyArgs>(args?: SelectSubset<T, DeliveryFeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryFees and returns the data saved in the database.
     * @param {DeliveryFeeCreateManyAndReturnArgs} args - Arguments to create many DeliveryFees.
     * @example
     * // Create many DeliveryFees
     * const deliveryFee = await prisma.deliveryFee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryFees and only return the `id`
     * const deliveryFeeWithIdOnly = await prisma.deliveryFee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryFeeCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryFeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryFeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryFee.
     * @param {DeliveryFeeDeleteArgs} args - Arguments to delete one DeliveryFee.
     * @example
     * // Delete one DeliveryFee
     * const DeliveryFee = await prisma.deliveryFee.delete({
     *   where: {
     *     // ... filter to delete one DeliveryFee
     *   }
     * })
     * 
     */
    delete<T extends DeliveryFeeDeleteArgs>(args: SelectSubset<T, DeliveryFeeDeleteArgs<ExtArgs>>): Prisma__DeliveryFeeClient<$Result.GetResult<Prisma.$DeliveryFeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryFee.
     * @param {DeliveryFeeUpdateArgs} args - Arguments to update one DeliveryFee.
     * @example
     * // Update one DeliveryFee
     * const deliveryFee = await prisma.deliveryFee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryFeeUpdateArgs>(args: SelectSubset<T, DeliveryFeeUpdateArgs<ExtArgs>>): Prisma__DeliveryFeeClient<$Result.GetResult<Prisma.$DeliveryFeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryFees.
     * @param {DeliveryFeeDeleteManyArgs} args - Arguments to filter DeliveryFees to delete.
     * @example
     * // Delete a few DeliveryFees
     * const { count } = await prisma.deliveryFee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryFeeDeleteManyArgs>(args?: SelectSubset<T, DeliveryFeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryFees
     * const deliveryFee = await prisma.deliveryFee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryFeeUpdateManyArgs>(args: SelectSubset<T, DeliveryFeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryFees and returns the data updated in the database.
     * @param {DeliveryFeeUpdateManyAndReturnArgs} args - Arguments to update many DeliveryFees.
     * @example
     * // Update many DeliveryFees
     * const deliveryFee = await prisma.deliveryFee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryFees and only return the `id`
     * const deliveryFeeWithIdOnly = await prisma.deliveryFee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryFeeUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryFeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryFeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryFee.
     * @param {DeliveryFeeUpsertArgs} args - Arguments to update or create a DeliveryFee.
     * @example
     * // Update or create a DeliveryFee
     * const deliveryFee = await prisma.deliveryFee.upsert({
     *   create: {
     *     // ... data to create a DeliveryFee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryFee we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryFeeUpsertArgs>(args: SelectSubset<T, DeliveryFeeUpsertArgs<ExtArgs>>): Prisma__DeliveryFeeClient<$Result.GetResult<Prisma.$DeliveryFeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFeeCountArgs} args - Arguments to filter DeliveryFees to count.
     * @example
     * // Count the number of DeliveryFees
     * const count = await prisma.deliveryFee.count({
     *   where: {
     *     // ... the filter for the DeliveryFees we want to count
     *   }
     * })
    **/
    count<T extends DeliveryFeeCountArgs>(
      args?: Subset<T, DeliveryFeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryFeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryFeeAggregateArgs>(args: Subset<T, DeliveryFeeAggregateArgs>): Prisma.PrismaPromise<GetDeliveryFeeAggregateType<T>>

    /**
     * Group by DeliveryFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryFeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryFeeGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryFeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryFeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryFeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryFee model
   */
  readonly fields: DeliveryFeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryFee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryFeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    priceRange<T extends DeliveryFee$priceRangeArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryFee$priceRangeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceRangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryFee model
   */
  interface DeliveryFeeFieldRefs {
    readonly id: FieldRef<"DeliveryFee", 'String'>
    readonly name: FieldRef<"DeliveryFee", 'String'>
    readonly fee: FieldRef<"DeliveryFee", 'Int'>
    readonly createdAt: FieldRef<"DeliveryFee", 'DateTime'>
    readonly updatedAt: FieldRef<"DeliveryFee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryFee findUnique
   */
  export type DeliveryFeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryFee
     */
    select?: DeliveryFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryFee
     */
    omit?: DeliveryFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryFeeInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryFee to fetch.
     */
    where: DeliveryFeeWhereUniqueInput
  }

  /**
   * DeliveryFee findUniqueOrThrow
   */
  export type DeliveryFeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryFee
     */
    select?: DeliveryFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryFee
     */
    omit?: DeliveryFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryFeeInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryFee to fetch.
     */
    where: DeliveryFeeWhereUniqueInput
  }

  /**
   * DeliveryFee findFirst
   */
  export type DeliveryFeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryFee
     */
    select?: DeliveryFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryFee
     */
    omit?: DeliveryFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryFeeInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryFee to fetch.
     */
    where?: DeliveryFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryFees to fetch.
     */
    orderBy?: DeliveryFeeOrderByWithRelationInput | DeliveryFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryFees.
     */
    cursor?: DeliveryFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryFees.
     */
    distinct?: DeliveryFeeScalarFieldEnum | DeliveryFeeScalarFieldEnum[]
  }

  /**
   * DeliveryFee findFirstOrThrow
   */
  export type DeliveryFeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryFee
     */
    select?: DeliveryFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryFee
     */
    omit?: DeliveryFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryFeeInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryFee to fetch.
     */
    where?: DeliveryFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryFees to fetch.
     */
    orderBy?: DeliveryFeeOrderByWithRelationInput | DeliveryFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryFees.
     */
    cursor?: DeliveryFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryFees.
     */
    distinct?: DeliveryFeeScalarFieldEnum | DeliveryFeeScalarFieldEnum[]
  }

  /**
   * DeliveryFee findMany
   */
  export type DeliveryFeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryFee
     */
    select?: DeliveryFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryFee
     */
    omit?: DeliveryFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryFeeInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryFees to fetch.
     */
    where?: DeliveryFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryFees to fetch.
     */
    orderBy?: DeliveryFeeOrderByWithRelationInput | DeliveryFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryFees.
     */
    cursor?: DeliveryFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryFees.
     */
    skip?: number
    distinct?: DeliveryFeeScalarFieldEnum | DeliveryFeeScalarFieldEnum[]
  }

  /**
   * DeliveryFee create
   */
  export type DeliveryFeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryFee
     */
    select?: DeliveryFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryFee
     */
    omit?: DeliveryFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryFeeInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryFee.
     */
    data: XOR<DeliveryFeeCreateInput, DeliveryFeeUncheckedCreateInput>
  }

  /**
   * DeliveryFee createMany
   */
  export type DeliveryFeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryFees.
     */
    data: DeliveryFeeCreateManyInput | DeliveryFeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryFee createManyAndReturn
   */
  export type DeliveryFeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryFee
     */
    select?: DeliveryFeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryFee
     */
    omit?: DeliveryFeeOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryFees.
     */
    data: DeliveryFeeCreateManyInput | DeliveryFeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryFee update
   */
  export type DeliveryFeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryFee
     */
    select?: DeliveryFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryFee
     */
    omit?: DeliveryFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryFeeInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryFee.
     */
    data: XOR<DeliveryFeeUpdateInput, DeliveryFeeUncheckedUpdateInput>
    /**
     * Choose, which DeliveryFee to update.
     */
    where: DeliveryFeeWhereUniqueInput
  }

  /**
   * DeliveryFee updateMany
   */
  export type DeliveryFeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryFees.
     */
    data: XOR<DeliveryFeeUpdateManyMutationInput, DeliveryFeeUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryFees to update
     */
    where?: DeliveryFeeWhereInput
    /**
     * Limit how many DeliveryFees to update.
     */
    limit?: number
  }

  /**
   * DeliveryFee updateManyAndReturn
   */
  export type DeliveryFeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryFee
     */
    select?: DeliveryFeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryFee
     */
    omit?: DeliveryFeeOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryFees.
     */
    data: XOR<DeliveryFeeUpdateManyMutationInput, DeliveryFeeUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryFees to update
     */
    where?: DeliveryFeeWhereInput
    /**
     * Limit how many DeliveryFees to update.
     */
    limit?: number
  }

  /**
   * DeliveryFee upsert
   */
  export type DeliveryFeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryFee
     */
    select?: DeliveryFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryFee
     */
    omit?: DeliveryFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryFeeInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryFee to update in case it exists.
     */
    where: DeliveryFeeWhereUniqueInput
    /**
     * In case the DeliveryFee found by the `where` argument doesn't exist, create a new DeliveryFee with this data.
     */
    create: XOR<DeliveryFeeCreateInput, DeliveryFeeUncheckedCreateInput>
    /**
     * In case the DeliveryFee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryFeeUpdateInput, DeliveryFeeUncheckedUpdateInput>
  }

  /**
   * DeliveryFee delete
   */
  export type DeliveryFeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryFee
     */
    select?: DeliveryFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryFee
     */
    omit?: DeliveryFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryFeeInclude<ExtArgs> | null
    /**
     * Filter which DeliveryFee to delete.
     */
    where: DeliveryFeeWhereUniqueInput
  }

  /**
   * DeliveryFee deleteMany
   */
  export type DeliveryFeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryFees to delete
     */
    where?: DeliveryFeeWhereInput
    /**
     * Limit how many DeliveryFees to delete.
     */
    limit?: number
  }

  /**
   * DeliveryFee.priceRange
   */
  export type DeliveryFee$priceRangeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRange
     */
    select?: PriceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRange
     */
    omit?: PriceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceRangeInclude<ExtArgs> | null
    where?: PriceRangeWhereInput
    orderBy?: PriceRangeOrderByWithRelationInput | PriceRangeOrderByWithRelationInput[]
    cursor?: PriceRangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceRangeScalarFieldEnum | PriceRangeScalarFieldEnum[]
  }

  /**
   * DeliveryFee without action
   */
  export type DeliveryFeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryFee
     */
    select?: DeliveryFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryFee
     */
    omit?: DeliveryFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryFeeInclude<ExtArgs> | null
  }


  /**
   * Model PriceRange
   */

  export type AggregatePriceRange = {
    _count: PriceRangeCountAggregateOutputType | null
    _avg: PriceRangeAvgAggregateOutputType | null
    _sum: PriceRangeSumAggregateOutputType | null
    _min: PriceRangeMinAggregateOutputType | null
    _max: PriceRangeMaxAggregateOutputType | null
  }

  export type PriceRangeAvgAggregateOutputType = {
    from: number | null
    to: number | null
    price: number | null
  }

  export type PriceRangeSumAggregateOutputType = {
    from: number | null
    to: number | null
    price: number | null
  }

  export type PriceRangeMinAggregateOutputType = {
    id: string | null
    from: number | null
    to: number | null
    price: number | null
    deliveryFeeId: string | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PriceRangeMaxAggregateOutputType = {
    id: string | null
    from: number | null
    to: number | null
    price: number | null
    deliveryFeeId: string | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PriceRangeCountAggregateOutputType = {
    id: number
    from: number
    to: number
    price: number
    deliveryFeeId: number
    productId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PriceRangeAvgAggregateInputType = {
    from?: true
    to?: true
    price?: true
  }

  export type PriceRangeSumAggregateInputType = {
    from?: true
    to?: true
    price?: true
  }

  export type PriceRangeMinAggregateInputType = {
    id?: true
    from?: true
    to?: true
    price?: true
    deliveryFeeId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PriceRangeMaxAggregateInputType = {
    id?: true
    from?: true
    to?: true
    price?: true
    deliveryFeeId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PriceRangeCountAggregateInputType = {
    id?: true
    from?: true
    to?: true
    price?: true
    deliveryFeeId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PriceRangeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceRange to aggregate.
     */
    where?: PriceRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceRanges to fetch.
     */
    orderBy?: PriceRangeOrderByWithRelationInput | PriceRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceRanges
    **/
    _count?: true | PriceRangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceRangeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceRangeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceRangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceRangeMaxAggregateInputType
  }

  export type GetPriceRangeAggregateType<T extends PriceRangeAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceRange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceRange[P]>
      : GetScalarType<T[P], AggregatePriceRange[P]>
  }




  export type PriceRangeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceRangeWhereInput
    orderBy?: PriceRangeOrderByWithAggregationInput | PriceRangeOrderByWithAggregationInput[]
    by: PriceRangeScalarFieldEnum[] | PriceRangeScalarFieldEnum
    having?: PriceRangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceRangeCountAggregateInputType | true
    _avg?: PriceRangeAvgAggregateInputType
    _sum?: PriceRangeSumAggregateInputType
    _min?: PriceRangeMinAggregateInputType
    _max?: PriceRangeMaxAggregateInputType
  }

  export type PriceRangeGroupByOutputType = {
    id: string
    from: number
    to: number
    price: number
    deliveryFeeId: string
    productId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PriceRangeCountAggregateOutputType | null
    _avg: PriceRangeAvgAggregateOutputType | null
    _sum: PriceRangeSumAggregateOutputType | null
    _min: PriceRangeMinAggregateOutputType | null
    _max: PriceRangeMaxAggregateOutputType | null
  }

  type GetPriceRangeGroupByPayload<T extends PriceRangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceRangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceRangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceRangeGroupByOutputType[P]>
            : GetScalarType<T[P], PriceRangeGroupByOutputType[P]>
        }
      >
    >


  export type PriceRangeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from?: boolean
    to?: boolean
    price?: boolean
    deliveryFeeId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deliveryFee?: boolean | DeliveryFeeDefaultArgs<ExtArgs>
    product?: boolean | PriceRange$productArgs<ExtArgs>
  }, ExtArgs["result"]["priceRange"]>

  export type PriceRangeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from?: boolean
    to?: boolean
    price?: boolean
    deliveryFeeId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deliveryFee?: boolean | DeliveryFeeDefaultArgs<ExtArgs>
    product?: boolean | PriceRange$productArgs<ExtArgs>
  }, ExtArgs["result"]["priceRange"]>

  export type PriceRangeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from?: boolean
    to?: boolean
    price?: boolean
    deliveryFeeId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deliveryFee?: boolean | DeliveryFeeDefaultArgs<ExtArgs>
    product?: boolean | PriceRange$productArgs<ExtArgs>
  }, ExtArgs["result"]["priceRange"]>

  export type PriceRangeSelectScalar = {
    id?: boolean
    from?: boolean
    to?: boolean
    price?: boolean
    deliveryFeeId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PriceRangeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "from" | "to" | "price" | "deliveryFeeId" | "productId" | "createdAt" | "updatedAt", ExtArgs["result"]["priceRange"]>
  export type PriceRangeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveryFee?: boolean | DeliveryFeeDefaultArgs<ExtArgs>
    product?: boolean | PriceRange$productArgs<ExtArgs>
  }
  export type PriceRangeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveryFee?: boolean | DeliveryFeeDefaultArgs<ExtArgs>
    product?: boolean | PriceRange$productArgs<ExtArgs>
  }
  export type PriceRangeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveryFee?: boolean | DeliveryFeeDefaultArgs<ExtArgs>
    product?: boolean | PriceRange$productArgs<ExtArgs>
  }

  export type $PriceRangePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceRange"
    objects: {
      deliveryFee: Prisma.$DeliveryFeePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      from: number
      to: number
      price: number
      deliveryFeeId: string
      productId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["priceRange"]>
    composites: {}
  }

  type PriceRangeGetPayload<S extends boolean | null | undefined | PriceRangeDefaultArgs> = $Result.GetResult<Prisma.$PriceRangePayload, S>

  type PriceRangeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PriceRangeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PriceRangeCountAggregateInputType | true
    }

  export interface PriceRangeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceRange'], meta: { name: 'PriceRange' } }
    /**
     * Find zero or one PriceRange that matches the filter.
     * @param {PriceRangeFindUniqueArgs} args - Arguments to find a PriceRange
     * @example
     * // Get one PriceRange
     * const priceRange = await prisma.priceRange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceRangeFindUniqueArgs>(args: SelectSubset<T, PriceRangeFindUniqueArgs<ExtArgs>>): Prisma__PriceRangeClient<$Result.GetResult<Prisma.$PriceRangePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PriceRange that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PriceRangeFindUniqueOrThrowArgs} args - Arguments to find a PriceRange
     * @example
     * // Get one PriceRange
     * const priceRange = await prisma.priceRange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceRangeFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceRangeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceRangeClient<$Result.GetResult<Prisma.$PriceRangePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceRange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRangeFindFirstArgs} args - Arguments to find a PriceRange
     * @example
     * // Get one PriceRange
     * const priceRange = await prisma.priceRange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceRangeFindFirstArgs>(args?: SelectSubset<T, PriceRangeFindFirstArgs<ExtArgs>>): Prisma__PriceRangeClient<$Result.GetResult<Prisma.$PriceRangePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceRange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRangeFindFirstOrThrowArgs} args - Arguments to find a PriceRange
     * @example
     * // Get one PriceRange
     * const priceRange = await prisma.priceRange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceRangeFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceRangeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceRangeClient<$Result.GetResult<Prisma.$PriceRangePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PriceRanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceRanges
     * const priceRanges = await prisma.priceRange.findMany()
     * 
     * // Get first 10 PriceRanges
     * const priceRanges = await prisma.priceRange.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceRangeWithIdOnly = await prisma.priceRange.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceRangeFindManyArgs>(args?: SelectSubset<T, PriceRangeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceRangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PriceRange.
     * @param {PriceRangeCreateArgs} args - Arguments to create a PriceRange.
     * @example
     * // Create one PriceRange
     * const PriceRange = await prisma.priceRange.create({
     *   data: {
     *     // ... data to create a PriceRange
     *   }
     * })
     * 
     */
    create<T extends PriceRangeCreateArgs>(args: SelectSubset<T, PriceRangeCreateArgs<ExtArgs>>): Prisma__PriceRangeClient<$Result.GetResult<Prisma.$PriceRangePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PriceRanges.
     * @param {PriceRangeCreateManyArgs} args - Arguments to create many PriceRanges.
     * @example
     * // Create many PriceRanges
     * const priceRange = await prisma.priceRange.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceRangeCreateManyArgs>(args?: SelectSubset<T, PriceRangeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceRanges and returns the data saved in the database.
     * @param {PriceRangeCreateManyAndReturnArgs} args - Arguments to create many PriceRanges.
     * @example
     * // Create many PriceRanges
     * const priceRange = await prisma.priceRange.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceRanges and only return the `id`
     * const priceRangeWithIdOnly = await prisma.priceRange.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceRangeCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceRangeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceRangePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PriceRange.
     * @param {PriceRangeDeleteArgs} args - Arguments to delete one PriceRange.
     * @example
     * // Delete one PriceRange
     * const PriceRange = await prisma.priceRange.delete({
     *   where: {
     *     // ... filter to delete one PriceRange
     *   }
     * })
     * 
     */
    delete<T extends PriceRangeDeleteArgs>(args: SelectSubset<T, PriceRangeDeleteArgs<ExtArgs>>): Prisma__PriceRangeClient<$Result.GetResult<Prisma.$PriceRangePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PriceRange.
     * @param {PriceRangeUpdateArgs} args - Arguments to update one PriceRange.
     * @example
     * // Update one PriceRange
     * const priceRange = await prisma.priceRange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceRangeUpdateArgs>(args: SelectSubset<T, PriceRangeUpdateArgs<ExtArgs>>): Prisma__PriceRangeClient<$Result.GetResult<Prisma.$PriceRangePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PriceRanges.
     * @param {PriceRangeDeleteManyArgs} args - Arguments to filter PriceRanges to delete.
     * @example
     * // Delete a few PriceRanges
     * const { count } = await prisma.priceRange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceRangeDeleteManyArgs>(args?: SelectSubset<T, PriceRangeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceRanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceRanges
     * const priceRange = await prisma.priceRange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceRangeUpdateManyArgs>(args: SelectSubset<T, PriceRangeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceRanges and returns the data updated in the database.
     * @param {PriceRangeUpdateManyAndReturnArgs} args - Arguments to update many PriceRanges.
     * @example
     * // Update many PriceRanges
     * const priceRange = await prisma.priceRange.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PriceRanges and only return the `id`
     * const priceRangeWithIdOnly = await prisma.priceRange.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PriceRangeUpdateManyAndReturnArgs>(args: SelectSubset<T, PriceRangeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceRangePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PriceRange.
     * @param {PriceRangeUpsertArgs} args - Arguments to update or create a PriceRange.
     * @example
     * // Update or create a PriceRange
     * const priceRange = await prisma.priceRange.upsert({
     *   create: {
     *     // ... data to create a PriceRange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceRange we want to update
     *   }
     * })
     */
    upsert<T extends PriceRangeUpsertArgs>(args: SelectSubset<T, PriceRangeUpsertArgs<ExtArgs>>): Prisma__PriceRangeClient<$Result.GetResult<Prisma.$PriceRangePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PriceRanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRangeCountArgs} args - Arguments to filter PriceRanges to count.
     * @example
     * // Count the number of PriceRanges
     * const count = await prisma.priceRange.count({
     *   where: {
     *     // ... the filter for the PriceRanges we want to count
     *   }
     * })
    **/
    count<T extends PriceRangeCountArgs>(
      args?: Subset<T, PriceRangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceRangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceRange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceRangeAggregateArgs>(args: Subset<T, PriceRangeAggregateArgs>): Prisma.PrismaPromise<GetPriceRangeAggregateType<T>>

    /**
     * Group by PriceRange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceRangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceRangeGroupByArgs['orderBy'] }
        : { orderBy?: PriceRangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceRangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceRangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceRange model
   */
  readonly fields: PriceRangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceRange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceRangeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deliveryFee<T extends DeliveryFeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryFeeDefaultArgs<ExtArgs>>): Prisma__DeliveryFeeClient<$Result.GetResult<Prisma.$DeliveryFeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends PriceRange$productArgs<ExtArgs> = {}>(args?: Subset<T, PriceRange$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceRange model
   */
  interface PriceRangeFieldRefs {
    readonly id: FieldRef<"PriceRange", 'String'>
    readonly from: FieldRef<"PriceRange", 'Int'>
    readonly to: FieldRef<"PriceRange", 'Int'>
    readonly price: FieldRef<"PriceRange", 'Int'>
    readonly deliveryFeeId: FieldRef<"PriceRange", 'String'>
    readonly productId: FieldRef<"PriceRange", 'String'>
    readonly createdAt: FieldRef<"PriceRange", 'DateTime'>
    readonly updatedAt: FieldRef<"PriceRange", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PriceRange findUnique
   */
  export type PriceRangeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRange
     */
    select?: PriceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRange
     */
    omit?: PriceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceRangeInclude<ExtArgs> | null
    /**
     * Filter, which PriceRange to fetch.
     */
    where: PriceRangeWhereUniqueInput
  }

  /**
   * PriceRange findUniqueOrThrow
   */
  export type PriceRangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRange
     */
    select?: PriceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRange
     */
    omit?: PriceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceRangeInclude<ExtArgs> | null
    /**
     * Filter, which PriceRange to fetch.
     */
    where: PriceRangeWhereUniqueInput
  }

  /**
   * PriceRange findFirst
   */
  export type PriceRangeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRange
     */
    select?: PriceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRange
     */
    omit?: PriceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceRangeInclude<ExtArgs> | null
    /**
     * Filter, which PriceRange to fetch.
     */
    where?: PriceRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceRanges to fetch.
     */
    orderBy?: PriceRangeOrderByWithRelationInput | PriceRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceRanges.
     */
    cursor?: PriceRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceRanges.
     */
    distinct?: PriceRangeScalarFieldEnum | PriceRangeScalarFieldEnum[]
  }

  /**
   * PriceRange findFirstOrThrow
   */
  export type PriceRangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRange
     */
    select?: PriceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRange
     */
    omit?: PriceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceRangeInclude<ExtArgs> | null
    /**
     * Filter, which PriceRange to fetch.
     */
    where?: PriceRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceRanges to fetch.
     */
    orderBy?: PriceRangeOrderByWithRelationInput | PriceRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceRanges.
     */
    cursor?: PriceRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceRanges.
     */
    distinct?: PriceRangeScalarFieldEnum | PriceRangeScalarFieldEnum[]
  }

  /**
   * PriceRange findMany
   */
  export type PriceRangeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRange
     */
    select?: PriceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRange
     */
    omit?: PriceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceRangeInclude<ExtArgs> | null
    /**
     * Filter, which PriceRanges to fetch.
     */
    where?: PriceRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceRanges to fetch.
     */
    orderBy?: PriceRangeOrderByWithRelationInput | PriceRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceRanges.
     */
    cursor?: PriceRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceRanges.
     */
    skip?: number
    distinct?: PriceRangeScalarFieldEnum | PriceRangeScalarFieldEnum[]
  }

  /**
   * PriceRange create
   */
  export type PriceRangeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRange
     */
    select?: PriceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRange
     */
    omit?: PriceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceRangeInclude<ExtArgs> | null
    /**
     * The data needed to create a PriceRange.
     */
    data: XOR<PriceRangeCreateInput, PriceRangeUncheckedCreateInput>
  }

  /**
   * PriceRange createMany
   */
  export type PriceRangeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceRanges.
     */
    data: PriceRangeCreateManyInput | PriceRangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceRange createManyAndReturn
   */
  export type PriceRangeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRange
     */
    select?: PriceRangeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRange
     */
    omit?: PriceRangeOmit<ExtArgs> | null
    /**
     * The data used to create many PriceRanges.
     */
    data: PriceRangeCreateManyInput | PriceRangeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceRangeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceRange update
   */
  export type PriceRangeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRange
     */
    select?: PriceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRange
     */
    omit?: PriceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceRangeInclude<ExtArgs> | null
    /**
     * The data needed to update a PriceRange.
     */
    data: XOR<PriceRangeUpdateInput, PriceRangeUncheckedUpdateInput>
    /**
     * Choose, which PriceRange to update.
     */
    where: PriceRangeWhereUniqueInput
  }

  /**
   * PriceRange updateMany
   */
  export type PriceRangeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceRanges.
     */
    data: XOR<PriceRangeUpdateManyMutationInput, PriceRangeUncheckedUpdateManyInput>
    /**
     * Filter which PriceRanges to update
     */
    where?: PriceRangeWhereInput
    /**
     * Limit how many PriceRanges to update.
     */
    limit?: number
  }

  /**
   * PriceRange updateManyAndReturn
   */
  export type PriceRangeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRange
     */
    select?: PriceRangeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRange
     */
    omit?: PriceRangeOmit<ExtArgs> | null
    /**
     * The data used to update PriceRanges.
     */
    data: XOR<PriceRangeUpdateManyMutationInput, PriceRangeUncheckedUpdateManyInput>
    /**
     * Filter which PriceRanges to update
     */
    where?: PriceRangeWhereInput
    /**
     * Limit how many PriceRanges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceRangeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceRange upsert
   */
  export type PriceRangeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRange
     */
    select?: PriceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRange
     */
    omit?: PriceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceRangeInclude<ExtArgs> | null
    /**
     * The filter to search for the PriceRange to update in case it exists.
     */
    where: PriceRangeWhereUniqueInput
    /**
     * In case the PriceRange found by the `where` argument doesn't exist, create a new PriceRange with this data.
     */
    create: XOR<PriceRangeCreateInput, PriceRangeUncheckedCreateInput>
    /**
     * In case the PriceRange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceRangeUpdateInput, PriceRangeUncheckedUpdateInput>
  }

  /**
   * PriceRange delete
   */
  export type PriceRangeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRange
     */
    select?: PriceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRange
     */
    omit?: PriceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceRangeInclude<ExtArgs> | null
    /**
     * Filter which PriceRange to delete.
     */
    where: PriceRangeWhereUniqueInput
  }

  /**
   * PriceRange deleteMany
   */
  export type PriceRangeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceRanges to delete
     */
    where?: PriceRangeWhereInput
    /**
     * Limit how many PriceRanges to delete.
     */
    limit?: number
  }

  /**
   * PriceRange.product
   */
  export type PriceRange$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * PriceRange without action
   */
  export type PriceRangeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRange
     */
    select?: PriceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRange
     */
    omit?: PriceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceRangeInclude<ExtArgs> | null
  }


  /**
   * Model Discount
   */

  export type AggregateDiscount = {
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  export type DiscountAvgAggregateOutputType = {
    percentage: number | null
  }

  export type DiscountSumAggregateOutputType = {
    percentage: number | null
  }

  export type DiscountMinAggregateOutputType = {
    id: string | null
    name: string | null
    percentage: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscountMaxAggregateOutputType = {
    id: string | null
    name: string | null
    percentage: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscountCountAggregateOutputType = {
    id: number
    name: number
    percentage: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DiscountAvgAggregateInputType = {
    percentage?: true
  }

  export type DiscountSumAggregateInputType = {
    percentage?: true
  }

  export type DiscountMinAggregateInputType = {
    id?: true
    name?: true
    percentage?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscountMaxAggregateInputType = {
    id?: true
    name?: true
    percentage?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscountCountAggregateInputType = {
    id?: true
    name?: true
    percentage?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DiscountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discount to aggregate.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Discounts
    **/
    _count?: true | DiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountMaxAggregateInputType
  }

  export type GetDiscountAggregateType<T extends DiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscount[P]>
      : GetScalarType<T[P], AggregateDiscount[P]>
  }




  export type DiscountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountWhereInput
    orderBy?: DiscountOrderByWithAggregationInput | DiscountOrderByWithAggregationInput[]
    by: DiscountScalarFieldEnum[] | DiscountScalarFieldEnum
    having?: DiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountCountAggregateInputType | true
    _avg?: DiscountAvgAggregateInputType
    _sum?: DiscountSumAggregateInputType
    _min?: DiscountMinAggregateInputType
    _max?: DiscountMaxAggregateInputType
  }

  export type DiscountGroupByOutputType = {
    id: string
    name: string
    percentage: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  type GetDiscountGroupByPayload<T extends DiscountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountGroupByOutputType[P]>
        }
      >
    >


  export type DiscountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    percentage?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Discount$productsArgs<ExtArgs>
    _count?: boolean | DiscountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    percentage?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    percentage?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectScalar = {
    id?: boolean
    name?: boolean
    percentage?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DiscountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "percentage" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["discount"]>
  export type DiscountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Discount$productsArgs<ExtArgs>
    _count?: boolean | DiscountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DiscountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DiscountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DiscountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Discount"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      percentage: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["discount"]>
    composites: {}
  }

  type DiscountGetPayload<S extends boolean | null | undefined | DiscountDefaultArgs> = $Result.GetResult<Prisma.$DiscountPayload, S>

  type DiscountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscountCountAggregateInputType | true
    }

  export interface DiscountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Discount'], meta: { name: 'Discount' } }
    /**
     * Find zero or one Discount that matches the filter.
     * @param {DiscountFindUniqueArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscountFindUniqueArgs>(args: SelectSubset<T, DiscountFindUniqueArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Discount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscountFindUniqueOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscountFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscountFindFirstArgs>(args?: SelectSubset<T, DiscountFindFirstArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscountFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscountFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Discounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Discounts
     * const discounts = await prisma.discount.findMany()
     * 
     * // Get first 10 Discounts
     * const discounts = await prisma.discount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discountWithIdOnly = await prisma.discount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscountFindManyArgs>(args?: SelectSubset<T, DiscountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Discount.
     * @param {DiscountCreateArgs} args - Arguments to create a Discount.
     * @example
     * // Create one Discount
     * const Discount = await prisma.discount.create({
     *   data: {
     *     // ... data to create a Discount
     *   }
     * })
     * 
     */
    create<T extends DiscountCreateArgs>(args: SelectSubset<T, DiscountCreateArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Discounts.
     * @param {DiscountCreateManyArgs} args - Arguments to create many Discounts.
     * @example
     * // Create many Discounts
     * const discount = await prisma.discount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscountCreateManyArgs>(args?: SelectSubset<T, DiscountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Discounts and returns the data saved in the database.
     * @param {DiscountCreateManyAndReturnArgs} args - Arguments to create many Discounts.
     * @example
     * // Create many Discounts
     * const discount = await prisma.discount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Discounts and only return the `id`
     * const discountWithIdOnly = await prisma.discount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiscountCreateManyAndReturnArgs>(args?: SelectSubset<T, DiscountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Discount.
     * @param {DiscountDeleteArgs} args - Arguments to delete one Discount.
     * @example
     * // Delete one Discount
     * const Discount = await prisma.discount.delete({
     *   where: {
     *     // ... filter to delete one Discount
     *   }
     * })
     * 
     */
    delete<T extends DiscountDeleteArgs>(args: SelectSubset<T, DiscountDeleteArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Discount.
     * @param {DiscountUpdateArgs} args - Arguments to update one Discount.
     * @example
     * // Update one Discount
     * const discount = await prisma.discount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscountUpdateArgs>(args: SelectSubset<T, DiscountUpdateArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Discounts.
     * @param {DiscountDeleteManyArgs} args - Arguments to filter Discounts to delete.
     * @example
     * // Delete a few Discounts
     * const { count } = await prisma.discount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscountDeleteManyArgs>(args?: SelectSubset<T, DiscountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscountUpdateManyArgs>(args: SelectSubset<T, DiscountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts and returns the data updated in the database.
     * @param {DiscountUpdateManyAndReturnArgs} args - Arguments to update many Discounts.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Discounts and only return the `id`
     * const discountWithIdOnly = await prisma.discount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiscountUpdateManyAndReturnArgs>(args: SelectSubset<T, DiscountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Discount.
     * @param {DiscountUpsertArgs} args - Arguments to update or create a Discount.
     * @example
     * // Update or create a Discount
     * const discount = await prisma.discount.upsert({
     *   create: {
     *     // ... data to create a Discount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Discount we want to update
     *   }
     * })
     */
    upsert<T extends DiscountUpsertArgs>(args: SelectSubset<T, DiscountUpsertArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountCountArgs} args - Arguments to filter Discounts to count.
     * @example
     * // Count the number of Discounts
     * const count = await prisma.discount.count({
     *   where: {
     *     // ... the filter for the Discounts we want to count
     *   }
     * })
    **/
    count<T extends DiscountCountArgs>(
      args?: Subset<T, DiscountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountAggregateArgs>(args: Subset<T, DiscountAggregateArgs>): Prisma.PrismaPromise<GetDiscountAggregateType<T>>

    /**
     * Group by Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountGroupByArgs['orderBy'] }
        : { orderBy?: DiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Discount model
   */
  readonly fields: DiscountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Discount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Discount$productsArgs<ExtArgs> = {}>(args?: Subset<T, Discount$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Discount model
   */
  interface DiscountFieldRefs {
    readonly id: FieldRef<"Discount", 'String'>
    readonly name: FieldRef<"Discount", 'String'>
    readonly percentage: FieldRef<"Discount", 'Int'>
    readonly active: FieldRef<"Discount", 'Boolean'>
    readonly createdAt: FieldRef<"Discount", 'DateTime'>
    readonly updatedAt: FieldRef<"Discount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Discount findUnique
   */
  export type DiscountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount findUniqueOrThrow
   */
  export type DiscountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount findFirst
   */
  export type DiscountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount findFirstOrThrow
   */
  export type DiscountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount findMany
   */
  export type DiscountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discounts to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount create
   */
  export type DiscountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The data needed to create a Discount.
     */
    data: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
  }

  /**
   * Discount createMany
   */
  export type DiscountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Discounts.
     */
    data: DiscountCreateManyInput | DiscountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Discount createManyAndReturn
   */
  export type DiscountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * The data used to create many Discounts.
     */
    data: DiscountCreateManyInput | DiscountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Discount update
   */
  export type DiscountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The data needed to update a Discount.
     */
    data: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
    /**
     * Choose, which Discount to update.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount updateMany
   */
  export type DiscountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Discounts.
     */
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyInput>
    /**
     * Filter which Discounts to update
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to update.
     */
    limit?: number
  }

  /**
   * Discount updateManyAndReturn
   */
  export type DiscountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * The data used to update Discounts.
     */
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyInput>
    /**
     * Filter which Discounts to update
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to update.
     */
    limit?: number
  }

  /**
   * Discount upsert
   */
  export type DiscountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The filter to search for the Discount to update in case it exists.
     */
    where: DiscountWhereUniqueInput
    /**
     * In case the Discount found by the `where` argument doesn't exist, create a new Discount with this data.
     */
    create: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
    /**
     * In case the Discount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
  }

  /**
   * Discount delete
   */
  export type DiscountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter which Discount to delete.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount deleteMany
   */
  export type DiscountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discounts to delete
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to delete.
     */
    limit?: number
  }

  /**
   * Discount.products
   */
  export type Discount$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Discount without action
   */
  export type DiscountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
  }


  /**
   * Model TextPersonalizationField
   */

  export type AggregateTextPersonalizationField = {
    _count: TextPersonalizationFieldCountAggregateOutputType | null
    _min: TextPersonalizationFieldMinAggregateOutputType | null
    _max: TextPersonalizationFieldMaxAggregateOutputType | null
  }

  export type TextPersonalizationFieldMinAggregateOutputType = {
    id: string | null
    name: string | null
    placeholder: string | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TextPersonalizationFieldMaxAggregateOutputType = {
    id: string | null
    name: string | null
    placeholder: string | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TextPersonalizationFieldCountAggregateOutputType = {
    id: number
    name: number
    placeholder: number
    productId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TextPersonalizationFieldMinAggregateInputType = {
    id?: true
    name?: true
    placeholder?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TextPersonalizationFieldMaxAggregateInputType = {
    id?: true
    name?: true
    placeholder?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TextPersonalizationFieldCountAggregateInputType = {
    id?: true
    name?: true
    placeholder?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TextPersonalizationFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TextPersonalizationField to aggregate.
     */
    where?: TextPersonalizationFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextPersonalizationFields to fetch.
     */
    orderBy?: TextPersonalizationFieldOrderByWithRelationInput | TextPersonalizationFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TextPersonalizationFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextPersonalizationFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextPersonalizationFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TextPersonalizationFields
    **/
    _count?: true | TextPersonalizationFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TextPersonalizationFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TextPersonalizationFieldMaxAggregateInputType
  }

  export type GetTextPersonalizationFieldAggregateType<T extends TextPersonalizationFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateTextPersonalizationField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTextPersonalizationField[P]>
      : GetScalarType<T[P], AggregateTextPersonalizationField[P]>
  }




  export type TextPersonalizationFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextPersonalizationFieldWhereInput
    orderBy?: TextPersonalizationFieldOrderByWithAggregationInput | TextPersonalizationFieldOrderByWithAggregationInput[]
    by: TextPersonalizationFieldScalarFieldEnum[] | TextPersonalizationFieldScalarFieldEnum
    having?: TextPersonalizationFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TextPersonalizationFieldCountAggregateInputType | true
    _min?: TextPersonalizationFieldMinAggregateInputType
    _max?: TextPersonalizationFieldMaxAggregateInputType
  }

  export type TextPersonalizationFieldGroupByOutputType = {
    id: string
    name: string
    placeholder: string
    productId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TextPersonalizationFieldCountAggregateOutputType | null
    _min: TextPersonalizationFieldMinAggregateOutputType | null
    _max: TextPersonalizationFieldMaxAggregateOutputType | null
  }

  type GetTextPersonalizationFieldGroupByPayload<T extends TextPersonalizationFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TextPersonalizationFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TextPersonalizationFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TextPersonalizationFieldGroupByOutputType[P]>
            : GetScalarType<T[P], TextPersonalizationFieldGroupByOutputType[P]>
        }
      >
    >


  export type TextPersonalizationFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    placeholder?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | TextPersonalizationField$productArgs<ExtArgs>
  }, ExtArgs["result"]["textPersonalizationField"]>

  export type TextPersonalizationFieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    placeholder?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | TextPersonalizationField$productArgs<ExtArgs>
  }, ExtArgs["result"]["textPersonalizationField"]>

  export type TextPersonalizationFieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    placeholder?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | TextPersonalizationField$productArgs<ExtArgs>
  }, ExtArgs["result"]["textPersonalizationField"]>

  export type TextPersonalizationFieldSelectScalar = {
    id?: boolean
    name?: boolean
    placeholder?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TextPersonalizationFieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "placeholder" | "productId" | "createdAt" | "updatedAt", ExtArgs["result"]["textPersonalizationField"]>
  export type TextPersonalizationFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | TextPersonalizationField$productArgs<ExtArgs>
  }
  export type TextPersonalizationFieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | TextPersonalizationField$productArgs<ExtArgs>
  }
  export type TextPersonalizationFieldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | TextPersonalizationField$productArgs<ExtArgs>
  }

  export type $TextPersonalizationFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TextPersonalizationField"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      placeholder: string
      productId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["textPersonalizationField"]>
    composites: {}
  }

  type TextPersonalizationFieldGetPayload<S extends boolean | null | undefined | TextPersonalizationFieldDefaultArgs> = $Result.GetResult<Prisma.$TextPersonalizationFieldPayload, S>

  type TextPersonalizationFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TextPersonalizationFieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TextPersonalizationFieldCountAggregateInputType | true
    }

  export interface TextPersonalizationFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TextPersonalizationField'], meta: { name: 'TextPersonalizationField' } }
    /**
     * Find zero or one TextPersonalizationField that matches the filter.
     * @param {TextPersonalizationFieldFindUniqueArgs} args - Arguments to find a TextPersonalizationField
     * @example
     * // Get one TextPersonalizationField
     * const textPersonalizationField = await prisma.textPersonalizationField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TextPersonalizationFieldFindUniqueArgs>(args: SelectSubset<T, TextPersonalizationFieldFindUniqueArgs<ExtArgs>>): Prisma__TextPersonalizationFieldClient<$Result.GetResult<Prisma.$TextPersonalizationFieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TextPersonalizationField that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TextPersonalizationFieldFindUniqueOrThrowArgs} args - Arguments to find a TextPersonalizationField
     * @example
     * // Get one TextPersonalizationField
     * const textPersonalizationField = await prisma.textPersonalizationField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TextPersonalizationFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, TextPersonalizationFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TextPersonalizationFieldClient<$Result.GetResult<Prisma.$TextPersonalizationFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TextPersonalizationField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextPersonalizationFieldFindFirstArgs} args - Arguments to find a TextPersonalizationField
     * @example
     * // Get one TextPersonalizationField
     * const textPersonalizationField = await prisma.textPersonalizationField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TextPersonalizationFieldFindFirstArgs>(args?: SelectSubset<T, TextPersonalizationFieldFindFirstArgs<ExtArgs>>): Prisma__TextPersonalizationFieldClient<$Result.GetResult<Prisma.$TextPersonalizationFieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TextPersonalizationField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextPersonalizationFieldFindFirstOrThrowArgs} args - Arguments to find a TextPersonalizationField
     * @example
     * // Get one TextPersonalizationField
     * const textPersonalizationField = await prisma.textPersonalizationField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TextPersonalizationFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, TextPersonalizationFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__TextPersonalizationFieldClient<$Result.GetResult<Prisma.$TextPersonalizationFieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TextPersonalizationFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextPersonalizationFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TextPersonalizationFields
     * const textPersonalizationFields = await prisma.textPersonalizationField.findMany()
     * 
     * // Get first 10 TextPersonalizationFields
     * const textPersonalizationFields = await prisma.textPersonalizationField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const textPersonalizationFieldWithIdOnly = await prisma.textPersonalizationField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TextPersonalizationFieldFindManyArgs>(args?: SelectSubset<T, TextPersonalizationFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextPersonalizationFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TextPersonalizationField.
     * @param {TextPersonalizationFieldCreateArgs} args - Arguments to create a TextPersonalizationField.
     * @example
     * // Create one TextPersonalizationField
     * const TextPersonalizationField = await prisma.textPersonalizationField.create({
     *   data: {
     *     // ... data to create a TextPersonalizationField
     *   }
     * })
     * 
     */
    create<T extends TextPersonalizationFieldCreateArgs>(args: SelectSubset<T, TextPersonalizationFieldCreateArgs<ExtArgs>>): Prisma__TextPersonalizationFieldClient<$Result.GetResult<Prisma.$TextPersonalizationFieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TextPersonalizationFields.
     * @param {TextPersonalizationFieldCreateManyArgs} args - Arguments to create many TextPersonalizationFields.
     * @example
     * // Create many TextPersonalizationFields
     * const textPersonalizationField = await prisma.textPersonalizationField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TextPersonalizationFieldCreateManyArgs>(args?: SelectSubset<T, TextPersonalizationFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TextPersonalizationFields and returns the data saved in the database.
     * @param {TextPersonalizationFieldCreateManyAndReturnArgs} args - Arguments to create many TextPersonalizationFields.
     * @example
     * // Create many TextPersonalizationFields
     * const textPersonalizationField = await prisma.textPersonalizationField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TextPersonalizationFields and only return the `id`
     * const textPersonalizationFieldWithIdOnly = await prisma.textPersonalizationField.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TextPersonalizationFieldCreateManyAndReturnArgs>(args?: SelectSubset<T, TextPersonalizationFieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextPersonalizationFieldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TextPersonalizationField.
     * @param {TextPersonalizationFieldDeleteArgs} args - Arguments to delete one TextPersonalizationField.
     * @example
     * // Delete one TextPersonalizationField
     * const TextPersonalizationField = await prisma.textPersonalizationField.delete({
     *   where: {
     *     // ... filter to delete one TextPersonalizationField
     *   }
     * })
     * 
     */
    delete<T extends TextPersonalizationFieldDeleteArgs>(args: SelectSubset<T, TextPersonalizationFieldDeleteArgs<ExtArgs>>): Prisma__TextPersonalizationFieldClient<$Result.GetResult<Prisma.$TextPersonalizationFieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TextPersonalizationField.
     * @param {TextPersonalizationFieldUpdateArgs} args - Arguments to update one TextPersonalizationField.
     * @example
     * // Update one TextPersonalizationField
     * const textPersonalizationField = await prisma.textPersonalizationField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TextPersonalizationFieldUpdateArgs>(args: SelectSubset<T, TextPersonalizationFieldUpdateArgs<ExtArgs>>): Prisma__TextPersonalizationFieldClient<$Result.GetResult<Prisma.$TextPersonalizationFieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TextPersonalizationFields.
     * @param {TextPersonalizationFieldDeleteManyArgs} args - Arguments to filter TextPersonalizationFields to delete.
     * @example
     * // Delete a few TextPersonalizationFields
     * const { count } = await prisma.textPersonalizationField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TextPersonalizationFieldDeleteManyArgs>(args?: SelectSubset<T, TextPersonalizationFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TextPersonalizationFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextPersonalizationFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TextPersonalizationFields
     * const textPersonalizationField = await prisma.textPersonalizationField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TextPersonalizationFieldUpdateManyArgs>(args: SelectSubset<T, TextPersonalizationFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TextPersonalizationFields and returns the data updated in the database.
     * @param {TextPersonalizationFieldUpdateManyAndReturnArgs} args - Arguments to update many TextPersonalizationFields.
     * @example
     * // Update many TextPersonalizationFields
     * const textPersonalizationField = await prisma.textPersonalizationField.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TextPersonalizationFields and only return the `id`
     * const textPersonalizationFieldWithIdOnly = await prisma.textPersonalizationField.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TextPersonalizationFieldUpdateManyAndReturnArgs>(args: SelectSubset<T, TextPersonalizationFieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextPersonalizationFieldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TextPersonalizationField.
     * @param {TextPersonalizationFieldUpsertArgs} args - Arguments to update or create a TextPersonalizationField.
     * @example
     * // Update or create a TextPersonalizationField
     * const textPersonalizationField = await prisma.textPersonalizationField.upsert({
     *   create: {
     *     // ... data to create a TextPersonalizationField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TextPersonalizationField we want to update
     *   }
     * })
     */
    upsert<T extends TextPersonalizationFieldUpsertArgs>(args: SelectSubset<T, TextPersonalizationFieldUpsertArgs<ExtArgs>>): Prisma__TextPersonalizationFieldClient<$Result.GetResult<Prisma.$TextPersonalizationFieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TextPersonalizationFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextPersonalizationFieldCountArgs} args - Arguments to filter TextPersonalizationFields to count.
     * @example
     * // Count the number of TextPersonalizationFields
     * const count = await prisma.textPersonalizationField.count({
     *   where: {
     *     // ... the filter for the TextPersonalizationFields we want to count
     *   }
     * })
    **/
    count<T extends TextPersonalizationFieldCountArgs>(
      args?: Subset<T, TextPersonalizationFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TextPersonalizationFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TextPersonalizationField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextPersonalizationFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TextPersonalizationFieldAggregateArgs>(args: Subset<T, TextPersonalizationFieldAggregateArgs>): Prisma.PrismaPromise<GetTextPersonalizationFieldAggregateType<T>>

    /**
     * Group by TextPersonalizationField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextPersonalizationFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TextPersonalizationFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TextPersonalizationFieldGroupByArgs['orderBy'] }
        : { orderBy?: TextPersonalizationFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TextPersonalizationFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTextPersonalizationFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TextPersonalizationField model
   */
  readonly fields: TextPersonalizationFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TextPersonalizationField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TextPersonalizationFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends TextPersonalizationField$productArgs<ExtArgs> = {}>(args?: Subset<T, TextPersonalizationField$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TextPersonalizationField model
   */
  interface TextPersonalizationFieldFieldRefs {
    readonly id: FieldRef<"TextPersonalizationField", 'String'>
    readonly name: FieldRef<"TextPersonalizationField", 'String'>
    readonly placeholder: FieldRef<"TextPersonalizationField", 'String'>
    readonly productId: FieldRef<"TextPersonalizationField", 'String'>
    readonly createdAt: FieldRef<"TextPersonalizationField", 'DateTime'>
    readonly updatedAt: FieldRef<"TextPersonalizationField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TextPersonalizationField findUnique
   */
  export type TextPersonalizationFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalizationField
     */
    select?: TextPersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalizationField
     */
    omit?: TextPersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationFieldInclude<ExtArgs> | null
    /**
     * Filter, which TextPersonalizationField to fetch.
     */
    where: TextPersonalizationFieldWhereUniqueInput
  }

  /**
   * TextPersonalizationField findUniqueOrThrow
   */
  export type TextPersonalizationFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalizationField
     */
    select?: TextPersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalizationField
     */
    omit?: TextPersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationFieldInclude<ExtArgs> | null
    /**
     * Filter, which TextPersonalizationField to fetch.
     */
    where: TextPersonalizationFieldWhereUniqueInput
  }

  /**
   * TextPersonalizationField findFirst
   */
  export type TextPersonalizationFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalizationField
     */
    select?: TextPersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalizationField
     */
    omit?: TextPersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationFieldInclude<ExtArgs> | null
    /**
     * Filter, which TextPersonalizationField to fetch.
     */
    where?: TextPersonalizationFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextPersonalizationFields to fetch.
     */
    orderBy?: TextPersonalizationFieldOrderByWithRelationInput | TextPersonalizationFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TextPersonalizationFields.
     */
    cursor?: TextPersonalizationFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextPersonalizationFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextPersonalizationFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TextPersonalizationFields.
     */
    distinct?: TextPersonalizationFieldScalarFieldEnum | TextPersonalizationFieldScalarFieldEnum[]
  }

  /**
   * TextPersonalizationField findFirstOrThrow
   */
  export type TextPersonalizationFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalizationField
     */
    select?: TextPersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalizationField
     */
    omit?: TextPersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationFieldInclude<ExtArgs> | null
    /**
     * Filter, which TextPersonalizationField to fetch.
     */
    where?: TextPersonalizationFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextPersonalizationFields to fetch.
     */
    orderBy?: TextPersonalizationFieldOrderByWithRelationInput | TextPersonalizationFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TextPersonalizationFields.
     */
    cursor?: TextPersonalizationFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextPersonalizationFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextPersonalizationFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TextPersonalizationFields.
     */
    distinct?: TextPersonalizationFieldScalarFieldEnum | TextPersonalizationFieldScalarFieldEnum[]
  }

  /**
   * TextPersonalizationField findMany
   */
  export type TextPersonalizationFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalizationField
     */
    select?: TextPersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalizationField
     */
    omit?: TextPersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationFieldInclude<ExtArgs> | null
    /**
     * Filter, which TextPersonalizationFields to fetch.
     */
    where?: TextPersonalizationFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextPersonalizationFields to fetch.
     */
    orderBy?: TextPersonalizationFieldOrderByWithRelationInput | TextPersonalizationFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TextPersonalizationFields.
     */
    cursor?: TextPersonalizationFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextPersonalizationFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextPersonalizationFields.
     */
    skip?: number
    distinct?: TextPersonalizationFieldScalarFieldEnum | TextPersonalizationFieldScalarFieldEnum[]
  }

  /**
   * TextPersonalizationField create
   */
  export type TextPersonalizationFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalizationField
     */
    select?: TextPersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalizationField
     */
    omit?: TextPersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a TextPersonalizationField.
     */
    data: XOR<TextPersonalizationFieldCreateInput, TextPersonalizationFieldUncheckedCreateInput>
  }

  /**
   * TextPersonalizationField createMany
   */
  export type TextPersonalizationFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TextPersonalizationFields.
     */
    data: TextPersonalizationFieldCreateManyInput | TextPersonalizationFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TextPersonalizationField createManyAndReturn
   */
  export type TextPersonalizationFieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalizationField
     */
    select?: TextPersonalizationFieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalizationField
     */
    omit?: TextPersonalizationFieldOmit<ExtArgs> | null
    /**
     * The data used to create many TextPersonalizationFields.
     */
    data: TextPersonalizationFieldCreateManyInput | TextPersonalizationFieldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationFieldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TextPersonalizationField update
   */
  export type TextPersonalizationFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalizationField
     */
    select?: TextPersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalizationField
     */
    omit?: TextPersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a TextPersonalizationField.
     */
    data: XOR<TextPersonalizationFieldUpdateInput, TextPersonalizationFieldUncheckedUpdateInput>
    /**
     * Choose, which TextPersonalizationField to update.
     */
    where: TextPersonalizationFieldWhereUniqueInput
  }

  /**
   * TextPersonalizationField updateMany
   */
  export type TextPersonalizationFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TextPersonalizationFields.
     */
    data: XOR<TextPersonalizationFieldUpdateManyMutationInput, TextPersonalizationFieldUncheckedUpdateManyInput>
    /**
     * Filter which TextPersonalizationFields to update
     */
    where?: TextPersonalizationFieldWhereInput
    /**
     * Limit how many TextPersonalizationFields to update.
     */
    limit?: number
  }

  /**
   * TextPersonalizationField updateManyAndReturn
   */
  export type TextPersonalizationFieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalizationField
     */
    select?: TextPersonalizationFieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalizationField
     */
    omit?: TextPersonalizationFieldOmit<ExtArgs> | null
    /**
     * The data used to update TextPersonalizationFields.
     */
    data: XOR<TextPersonalizationFieldUpdateManyMutationInput, TextPersonalizationFieldUncheckedUpdateManyInput>
    /**
     * Filter which TextPersonalizationFields to update
     */
    where?: TextPersonalizationFieldWhereInput
    /**
     * Limit how many TextPersonalizationFields to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationFieldIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TextPersonalizationField upsert
   */
  export type TextPersonalizationFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalizationField
     */
    select?: TextPersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalizationField
     */
    omit?: TextPersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the TextPersonalizationField to update in case it exists.
     */
    where: TextPersonalizationFieldWhereUniqueInput
    /**
     * In case the TextPersonalizationField found by the `where` argument doesn't exist, create a new TextPersonalizationField with this data.
     */
    create: XOR<TextPersonalizationFieldCreateInput, TextPersonalizationFieldUncheckedCreateInput>
    /**
     * In case the TextPersonalizationField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TextPersonalizationFieldUpdateInput, TextPersonalizationFieldUncheckedUpdateInput>
  }

  /**
   * TextPersonalizationField delete
   */
  export type TextPersonalizationFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalizationField
     */
    select?: TextPersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalizationField
     */
    omit?: TextPersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationFieldInclude<ExtArgs> | null
    /**
     * Filter which TextPersonalizationField to delete.
     */
    where: TextPersonalizationFieldWhereUniqueInput
  }

  /**
   * TextPersonalizationField deleteMany
   */
  export type TextPersonalizationFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TextPersonalizationFields to delete
     */
    where?: TextPersonalizationFieldWhereInput
    /**
     * Limit how many TextPersonalizationFields to delete.
     */
    limit?: number
  }

  /**
   * TextPersonalizationField.product
   */
  export type TextPersonalizationField$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * TextPersonalizationField without action
   */
  export type TextPersonalizationFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalizationField
     */
    select?: TextPersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalizationField
     */
    omit?: TextPersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationFieldInclude<ExtArgs> | null
  }


  /**
   * Model ImagePersonalizationField
   */

  export type AggregateImagePersonalizationField = {
    _count: ImagePersonalizationFieldCountAggregateOutputType | null
    _avg: ImagePersonalizationFieldAvgAggregateOutputType | null
    _sum: ImagePersonalizationFieldSumAggregateOutputType | null
    _min: ImagePersonalizationFieldMinAggregateOutputType | null
    _max: ImagePersonalizationFieldMaxAggregateOutputType | null
  }

  export type ImagePersonalizationFieldAvgAggregateOutputType = {
    min: number | null
    max: number | null
  }

  export type ImagePersonalizationFieldSumAggregateOutputType = {
    min: number | null
    max: number | null
  }

  export type ImagePersonalizationFieldMinAggregateOutputType = {
    id: string | null
    name: string | null
    min: number | null
    max: number | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImagePersonalizationFieldMaxAggregateOutputType = {
    id: string | null
    name: string | null
    min: number | null
    max: number | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImagePersonalizationFieldCountAggregateOutputType = {
    id: number
    name: number
    min: number
    max: number
    productId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImagePersonalizationFieldAvgAggregateInputType = {
    min?: true
    max?: true
  }

  export type ImagePersonalizationFieldSumAggregateInputType = {
    min?: true
    max?: true
  }

  export type ImagePersonalizationFieldMinAggregateInputType = {
    id?: true
    name?: true
    min?: true
    max?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImagePersonalizationFieldMaxAggregateInputType = {
    id?: true
    name?: true
    min?: true
    max?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImagePersonalizationFieldCountAggregateInputType = {
    id?: true
    name?: true
    min?: true
    max?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImagePersonalizationFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImagePersonalizationField to aggregate.
     */
    where?: ImagePersonalizationFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImagePersonalizationFields to fetch.
     */
    orderBy?: ImagePersonalizationFieldOrderByWithRelationInput | ImagePersonalizationFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImagePersonalizationFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImagePersonalizationFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImagePersonalizationFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImagePersonalizationFields
    **/
    _count?: true | ImagePersonalizationFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImagePersonalizationFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImagePersonalizationFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImagePersonalizationFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImagePersonalizationFieldMaxAggregateInputType
  }

  export type GetImagePersonalizationFieldAggregateType<T extends ImagePersonalizationFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateImagePersonalizationField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImagePersonalizationField[P]>
      : GetScalarType<T[P], AggregateImagePersonalizationField[P]>
  }




  export type ImagePersonalizationFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImagePersonalizationFieldWhereInput
    orderBy?: ImagePersonalizationFieldOrderByWithAggregationInput | ImagePersonalizationFieldOrderByWithAggregationInput[]
    by: ImagePersonalizationFieldScalarFieldEnum[] | ImagePersonalizationFieldScalarFieldEnum
    having?: ImagePersonalizationFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImagePersonalizationFieldCountAggregateInputType | true
    _avg?: ImagePersonalizationFieldAvgAggregateInputType
    _sum?: ImagePersonalizationFieldSumAggregateInputType
    _min?: ImagePersonalizationFieldMinAggregateInputType
    _max?: ImagePersonalizationFieldMaxAggregateInputType
  }

  export type ImagePersonalizationFieldGroupByOutputType = {
    id: string
    name: string
    min: number
    max: number
    productId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ImagePersonalizationFieldCountAggregateOutputType | null
    _avg: ImagePersonalizationFieldAvgAggregateOutputType | null
    _sum: ImagePersonalizationFieldSumAggregateOutputType | null
    _min: ImagePersonalizationFieldMinAggregateOutputType | null
    _max: ImagePersonalizationFieldMaxAggregateOutputType | null
  }

  type GetImagePersonalizationFieldGroupByPayload<T extends ImagePersonalizationFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImagePersonalizationFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImagePersonalizationFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImagePersonalizationFieldGroupByOutputType[P]>
            : GetScalarType<T[P], ImagePersonalizationFieldGroupByOutputType[P]>
        }
      >
    >


  export type ImagePersonalizationFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    min?: boolean
    max?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ImagePersonalizationField$productArgs<ExtArgs>
  }, ExtArgs["result"]["imagePersonalizationField"]>

  export type ImagePersonalizationFieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    min?: boolean
    max?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ImagePersonalizationField$productArgs<ExtArgs>
  }, ExtArgs["result"]["imagePersonalizationField"]>

  export type ImagePersonalizationFieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    min?: boolean
    max?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ImagePersonalizationField$productArgs<ExtArgs>
  }, ExtArgs["result"]["imagePersonalizationField"]>

  export type ImagePersonalizationFieldSelectScalar = {
    id?: boolean
    name?: boolean
    min?: boolean
    max?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ImagePersonalizationFieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "min" | "max" | "productId" | "createdAt" | "updatedAt", ExtArgs["result"]["imagePersonalizationField"]>
  export type ImagePersonalizationFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ImagePersonalizationField$productArgs<ExtArgs>
  }
  export type ImagePersonalizationFieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ImagePersonalizationField$productArgs<ExtArgs>
  }
  export type ImagePersonalizationFieldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ImagePersonalizationField$productArgs<ExtArgs>
  }

  export type $ImagePersonalizationFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImagePersonalizationField"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      min: number
      max: number
      productId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["imagePersonalizationField"]>
    composites: {}
  }

  type ImagePersonalizationFieldGetPayload<S extends boolean | null | undefined | ImagePersonalizationFieldDefaultArgs> = $Result.GetResult<Prisma.$ImagePersonalizationFieldPayload, S>

  type ImagePersonalizationFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImagePersonalizationFieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImagePersonalizationFieldCountAggregateInputType | true
    }

  export interface ImagePersonalizationFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImagePersonalizationField'], meta: { name: 'ImagePersonalizationField' } }
    /**
     * Find zero or one ImagePersonalizationField that matches the filter.
     * @param {ImagePersonalizationFieldFindUniqueArgs} args - Arguments to find a ImagePersonalizationField
     * @example
     * // Get one ImagePersonalizationField
     * const imagePersonalizationField = await prisma.imagePersonalizationField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImagePersonalizationFieldFindUniqueArgs>(args: SelectSubset<T, ImagePersonalizationFieldFindUniqueArgs<ExtArgs>>): Prisma__ImagePersonalizationFieldClient<$Result.GetResult<Prisma.$ImagePersonalizationFieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImagePersonalizationField that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImagePersonalizationFieldFindUniqueOrThrowArgs} args - Arguments to find a ImagePersonalizationField
     * @example
     * // Get one ImagePersonalizationField
     * const imagePersonalizationField = await prisma.imagePersonalizationField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImagePersonalizationFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, ImagePersonalizationFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImagePersonalizationFieldClient<$Result.GetResult<Prisma.$ImagePersonalizationFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImagePersonalizationField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagePersonalizationFieldFindFirstArgs} args - Arguments to find a ImagePersonalizationField
     * @example
     * // Get one ImagePersonalizationField
     * const imagePersonalizationField = await prisma.imagePersonalizationField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImagePersonalizationFieldFindFirstArgs>(args?: SelectSubset<T, ImagePersonalizationFieldFindFirstArgs<ExtArgs>>): Prisma__ImagePersonalizationFieldClient<$Result.GetResult<Prisma.$ImagePersonalizationFieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImagePersonalizationField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagePersonalizationFieldFindFirstOrThrowArgs} args - Arguments to find a ImagePersonalizationField
     * @example
     * // Get one ImagePersonalizationField
     * const imagePersonalizationField = await prisma.imagePersonalizationField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImagePersonalizationFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, ImagePersonalizationFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImagePersonalizationFieldClient<$Result.GetResult<Prisma.$ImagePersonalizationFieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImagePersonalizationFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagePersonalizationFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImagePersonalizationFields
     * const imagePersonalizationFields = await prisma.imagePersonalizationField.findMany()
     * 
     * // Get first 10 ImagePersonalizationFields
     * const imagePersonalizationFields = await prisma.imagePersonalizationField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imagePersonalizationFieldWithIdOnly = await prisma.imagePersonalizationField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImagePersonalizationFieldFindManyArgs>(args?: SelectSubset<T, ImagePersonalizationFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePersonalizationFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImagePersonalizationField.
     * @param {ImagePersonalizationFieldCreateArgs} args - Arguments to create a ImagePersonalizationField.
     * @example
     * // Create one ImagePersonalizationField
     * const ImagePersonalizationField = await prisma.imagePersonalizationField.create({
     *   data: {
     *     // ... data to create a ImagePersonalizationField
     *   }
     * })
     * 
     */
    create<T extends ImagePersonalizationFieldCreateArgs>(args: SelectSubset<T, ImagePersonalizationFieldCreateArgs<ExtArgs>>): Prisma__ImagePersonalizationFieldClient<$Result.GetResult<Prisma.$ImagePersonalizationFieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImagePersonalizationFields.
     * @param {ImagePersonalizationFieldCreateManyArgs} args - Arguments to create many ImagePersonalizationFields.
     * @example
     * // Create many ImagePersonalizationFields
     * const imagePersonalizationField = await prisma.imagePersonalizationField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImagePersonalizationFieldCreateManyArgs>(args?: SelectSubset<T, ImagePersonalizationFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImagePersonalizationFields and returns the data saved in the database.
     * @param {ImagePersonalizationFieldCreateManyAndReturnArgs} args - Arguments to create many ImagePersonalizationFields.
     * @example
     * // Create many ImagePersonalizationFields
     * const imagePersonalizationField = await prisma.imagePersonalizationField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImagePersonalizationFields and only return the `id`
     * const imagePersonalizationFieldWithIdOnly = await prisma.imagePersonalizationField.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImagePersonalizationFieldCreateManyAndReturnArgs>(args?: SelectSubset<T, ImagePersonalizationFieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePersonalizationFieldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ImagePersonalizationField.
     * @param {ImagePersonalizationFieldDeleteArgs} args - Arguments to delete one ImagePersonalizationField.
     * @example
     * // Delete one ImagePersonalizationField
     * const ImagePersonalizationField = await prisma.imagePersonalizationField.delete({
     *   where: {
     *     // ... filter to delete one ImagePersonalizationField
     *   }
     * })
     * 
     */
    delete<T extends ImagePersonalizationFieldDeleteArgs>(args: SelectSubset<T, ImagePersonalizationFieldDeleteArgs<ExtArgs>>): Prisma__ImagePersonalizationFieldClient<$Result.GetResult<Prisma.$ImagePersonalizationFieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImagePersonalizationField.
     * @param {ImagePersonalizationFieldUpdateArgs} args - Arguments to update one ImagePersonalizationField.
     * @example
     * // Update one ImagePersonalizationField
     * const imagePersonalizationField = await prisma.imagePersonalizationField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImagePersonalizationFieldUpdateArgs>(args: SelectSubset<T, ImagePersonalizationFieldUpdateArgs<ExtArgs>>): Prisma__ImagePersonalizationFieldClient<$Result.GetResult<Prisma.$ImagePersonalizationFieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImagePersonalizationFields.
     * @param {ImagePersonalizationFieldDeleteManyArgs} args - Arguments to filter ImagePersonalizationFields to delete.
     * @example
     * // Delete a few ImagePersonalizationFields
     * const { count } = await prisma.imagePersonalizationField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImagePersonalizationFieldDeleteManyArgs>(args?: SelectSubset<T, ImagePersonalizationFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImagePersonalizationFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagePersonalizationFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImagePersonalizationFields
     * const imagePersonalizationField = await prisma.imagePersonalizationField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImagePersonalizationFieldUpdateManyArgs>(args: SelectSubset<T, ImagePersonalizationFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImagePersonalizationFields and returns the data updated in the database.
     * @param {ImagePersonalizationFieldUpdateManyAndReturnArgs} args - Arguments to update many ImagePersonalizationFields.
     * @example
     * // Update many ImagePersonalizationFields
     * const imagePersonalizationField = await prisma.imagePersonalizationField.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ImagePersonalizationFields and only return the `id`
     * const imagePersonalizationFieldWithIdOnly = await prisma.imagePersonalizationField.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImagePersonalizationFieldUpdateManyAndReturnArgs>(args: SelectSubset<T, ImagePersonalizationFieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePersonalizationFieldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ImagePersonalizationField.
     * @param {ImagePersonalizationFieldUpsertArgs} args - Arguments to update or create a ImagePersonalizationField.
     * @example
     * // Update or create a ImagePersonalizationField
     * const imagePersonalizationField = await prisma.imagePersonalizationField.upsert({
     *   create: {
     *     // ... data to create a ImagePersonalizationField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImagePersonalizationField we want to update
     *   }
     * })
     */
    upsert<T extends ImagePersonalizationFieldUpsertArgs>(args: SelectSubset<T, ImagePersonalizationFieldUpsertArgs<ExtArgs>>): Prisma__ImagePersonalizationFieldClient<$Result.GetResult<Prisma.$ImagePersonalizationFieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ImagePersonalizationFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagePersonalizationFieldCountArgs} args - Arguments to filter ImagePersonalizationFields to count.
     * @example
     * // Count the number of ImagePersonalizationFields
     * const count = await prisma.imagePersonalizationField.count({
     *   where: {
     *     // ... the filter for the ImagePersonalizationFields we want to count
     *   }
     * })
    **/
    count<T extends ImagePersonalizationFieldCountArgs>(
      args?: Subset<T, ImagePersonalizationFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImagePersonalizationFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImagePersonalizationField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagePersonalizationFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImagePersonalizationFieldAggregateArgs>(args: Subset<T, ImagePersonalizationFieldAggregateArgs>): Prisma.PrismaPromise<GetImagePersonalizationFieldAggregateType<T>>

    /**
     * Group by ImagePersonalizationField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagePersonalizationFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImagePersonalizationFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImagePersonalizationFieldGroupByArgs['orderBy'] }
        : { orderBy?: ImagePersonalizationFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImagePersonalizationFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImagePersonalizationFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImagePersonalizationField model
   */
  readonly fields: ImagePersonalizationFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImagePersonalizationField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImagePersonalizationFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ImagePersonalizationField$productArgs<ExtArgs> = {}>(args?: Subset<T, ImagePersonalizationField$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImagePersonalizationField model
   */
  interface ImagePersonalizationFieldFieldRefs {
    readonly id: FieldRef<"ImagePersonalizationField", 'String'>
    readonly name: FieldRef<"ImagePersonalizationField", 'String'>
    readonly min: FieldRef<"ImagePersonalizationField", 'Int'>
    readonly max: FieldRef<"ImagePersonalizationField", 'Int'>
    readonly productId: FieldRef<"ImagePersonalizationField", 'String'>
    readonly createdAt: FieldRef<"ImagePersonalizationField", 'DateTime'>
    readonly updatedAt: FieldRef<"ImagePersonalizationField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ImagePersonalizationField findUnique
   */
  export type ImagePersonalizationFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalizationField
     */
    select?: ImagePersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalizationField
     */
    omit?: ImagePersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationFieldInclude<ExtArgs> | null
    /**
     * Filter, which ImagePersonalizationField to fetch.
     */
    where: ImagePersonalizationFieldWhereUniqueInput
  }

  /**
   * ImagePersonalizationField findUniqueOrThrow
   */
  export type ImagePersonalizationFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalizationField
     */
    select?: ImagePersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalizationField
     */
    omit?: ImagePersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationFieldInclude<ExtArgs> | null
    /**
     * Filter, which ImagePersonalizationField to fetch.
     */
    where: ImagePersonalizationFieldWhereUniqueInput
  }

  /**
   * ImagePersonalizationField findFirst
   */
  export type ImagePersonalizationFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalizationField
     */
    select?: ImagePersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalizationField
     */
    omit?: ImagePersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationFieldInclude<ExtArgs> | null
    /**
     * Filter, which ImagePersonalizationField to fetch.
     */
    where?: ImagePersonalizationFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImagePersonalizationFields to fetch.
     */
    orderBy?: ImagePersonalizationFieldOrderByWithRelationInput | ImagePersonalizationFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImagePersonalizationFields.
     */
    cursor?: ImagePersonalizationFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImagePersonalizationFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImagePersonalizationFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImagePersonalizationFields.
     */
    distinct?: ImagePersonalizationFieldScalarFieldEnum | ImagePersonalizationFieldScalarFieldEnum[]
  }

  /**
   * ImagePersonalizationField findFirstOrThrow
   */
  export type ImagePersonalizationFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalizationField
     */
    select?: ImagePersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalizationField
     */
    omit?: ImagePersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationFieldInclude<ExtArgs> | null
    /**
     * Filter, which ImagePersonalizationField to fetch.
     */
    where?: ImagePersonalizationFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImagePersonalizationFields to fetch.
     */
    orderBy?: ImagePersonalizationFieldOrderByWithRelationInput | ImagePersonalizationFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImagePersonalizationFields.
     */
    cursor?: ImagePersonalizationFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImagePersonalizationFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImagePersonalizationFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImagePersonalizationFields.
     */
    distinct?: ImagePersonalizationFieldScalarFieldEnum | ImagePersonalizationFieldScalarFieldEnum[]
  }

  /**
   * ImagePersonalizationField findMany
   */
  export type ImagePersonalizationFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalizationField
     */
    select?: ImagePersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalizationField
     */
    omit?: ImagePersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationFieldInclude<ExtArgs> | null
    /**
     * Filter, which ImagePersonalizationFields to fetch.
     */
    where?: ImagePersonalizationFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImagePersonalizationFields to fetch.
     */
    orderBy?: ImagePersonalizationFieldOrderByWithRelationInput | ImagePersonalizationFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImagePersonalizationFields.
     */
    cursor?: ImagePersonalizationFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImagePersonalizationFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImagePersonalizationFields.
     */
    skip?: number
    distinct?: ImagePersonalizationFieldScalarFieldEnum | ImagePersonalizationFieldScalarFieldEnum[]
  }

  /**
   * ImagePersonalizationField create
   */
  export type ImagePersonalizationFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalizationField
     */
    select?: ImagePersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalizationField
     */
    omit?: ImagePersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a ImagePersonalizationField.
     */
    data: XOR<ImagePersonalizationFieldCreateInput, ImagePersonalizationFieldUncheckedCreateInput>
  }

  /**
   * ImagePersonalizationField createMany
   */
  export type ImagePersonalizationFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImagePersonalizationFields.
     */
    data: ImagePersonalizationFieldCreateManyInput | ImagePersonalizationFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImagePersonalizationField createManyAndReturn
   */
  export type ImagePersonalizationFieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalizationField
     */
    select?: ImagePersonalizationFieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalizationField
     */
    omit?: ImagePersonalizationFieldOmit<ExtArgs> | null
    /**
     * The data used to create many ImagePersonalizationFields.
     */
    data: ImagePersonalizationFieldCreateManyInput | ImagePersonalizationFieldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationFieldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImagePersonalizationField update
   */
  export type ImagePersonalizationFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalizationField
     */
    select?: ImagePersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalizationField
     */
    omit?: ImagePersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a ImagePersonalizationField.
     */
    data: XOR<ImagePersonalizationFieldUpdateInput, ImagePersonalizationFieldUncheckedUpdateInput>
    /**
     * Choose, which ImagePersonalizationField to update.
     */
    where: ImagePersonalizationFieldWhereUniqueInput
  }

  /**
   * ImagePersonalizationField updateMany
   */
  export type ImagePersonalizationFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImagePersonalizationFields.
     */
    data: XOR<ImagePersonalizationFieldUpdateManyMutationInput, ImagePersonalizationFieldUncheckedUpdateManyInput>
    /**
     * Filter which ImagePersonalizationFields to update
     */
    where?: ImagePersonalizationFieldWhereInput
    /**
     * Limit how many ImagePersonalizationFields to update.
     */
    limit?: number
  }

  /**
   * ImagePersonalizationField updateManyAndReturn
   */
  export type ImagePersonalizationFieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalizationField
     */
    select?: ImagePersonalizationFieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalizationField
     */
    omit?: ImagePersonalizationFieldOmit<ExtArgs> | null
    /**
     * The data used to update ImagePersonalizationFields.
     */
    data: XOR<ImagePersonalizationFieldUpdateManyMutationInput, ImagePersonalizationFieldUncheckedUpdateManyInput>
    /**
     * Filter which ImagePersonalizationFields to update
     */
    where?: ImagePersonalizationFieldWhereInput
    /**
     * Limit how many ImagePersonalizationFields to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationFieldIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImagePersonalizationField upsert
   */
  export type ImagePersonalizationFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalizationField
     */
    select?: ImagePersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalizationField
     */
    omit?: ImagePersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the ImagePersonalizationField to update in case it exists.
     */
    where: ImagePersonalizationFieldWhereUniqueInput
    /**
     * In case the ImagePersonalizationField found by the `where` argument doesn't exist, create a new ImagePersonalizationField with this data.
     */
    create: XOR<ImagePersonalizationFieldCreateInput, ImagePersonalizationFieldUncheckedCreateInput>
    /**
     * In case the ImagePersonalizationField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImagePersonalizationFieldUpdateInput, ImagePersonalizationFieldUncheckedUpdateInput>
  }

  /**
   * ImagePersonalizationField delete
   */
  export type ImagePersonalizationFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalizationField
     */
    select?: ImagePersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalizationField
     */
    omit?: ImagePersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationFieldInclude<ExtArgs> | null
    /**
     * Filter which ImagePersonalizationField to delete.
     */
    where: ImagePersonalizationFieldWhereUniqueInput
  }

  /**
   * ImagePersonalizationField deleteMany
   */
  export type ImagePersonalizationFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImagePersonalizationFields to delete
     */
    where?: ImagePersonalizationFieldWhereInput
    /**
     * Limit how many ImagePersonalizationFields to delete.
     */
    limit?: number
  }

  /**
   * ImagePersonalizationField.product
   */
  export type ImagePersonalizationField$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * ImagePersonalizationField without action
   */
  export type ImagePersonalizationFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalizationField
     */
    select?: ImagePersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalizationField
     */
    omit?: ImagePersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationFieldInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    price: number | null
    discountId: string | null
    material: string | null
    dimensions: string | null
    personalization: string | null
    description: string | null
    delivery: $Enums.DeliveryType | null
    inStock: boolean | null
    trending: boolean | null
    packageOptionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    price: number | null
    discountId: string | null
    material: string | null
    dimensions: string | null
    personalization: string | null
    description: string | null
    delivery: $Enums.DeliveryType | null
    inStock: boolean | null
    trending: boolean | null
    packageOptionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    code: number
    price: number
    discountId: number
    material: number
    dimensions: number
    personalization: number
    description: number
    delivery: number
    inStock: number
    trending: number
    packageOptionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    price?: true
    discountId?: true
    material?: true
    dimensions?: true
    personalization?: true
    description?: true
    delivery?: true
    inStock?: true
    trending?: true
    packageOptionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    price?: true
    discountId?: true
    material?: true
    dimensions?: true
    personalization?: true
    description?: true
    delivery?: true
    inStock?: true
    trending?: true
    packageOptionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    price?: true
    discountId?: true
    material?: true
    dimensions?: true
    personalization?: true
    description?: true
    delivery?: true
    inStock?: true
    trending?: true
    packageOptionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    code: string
    price: number
    discountId: string | null
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock: boolean
    trending: boolean
    packageOptionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    price?: boolean
    discountId?: boolean
    material?: boolean
    dimensions?: boolean
    personalization?: boolean
    description?: boolean
    delivery?: boolean
    inStock?: boolean
    trending?: boolean
    packageOptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categories?: boolean | Product$categoriesArgs<ExtArgs>
    priceTable?: boolean | Product$priceTableArgs<ExtArgs>
    discount?: boolean | Product$discountArgs<ExtArgs>
    packageOption?: boolean | Product$packageOptionArgs<ExtArgs>
    coverImage?: boolean | Product$coverImageArgs<ExtArgs>
    images?: boolean | Product$imagesArgs<ExtArgs>
    imagePersonalizationFields?: boolean | Product$imagePersonalizationFieldsArgs<ExtArgs>
    textPersonalizationFields?: boolean | Product$textPersonalizationFieldsArgs<ExtArgs>
    cartItems?: boolean | Product$cartItemsArgs<ExtArgs>
    ratings?: boolean | Product$ratingsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    price?: boolean
    discountId?: boolean
    material?: boolean
    dimensions?: boolean
    personalization?: boolean
    description?: boolean
    delivery?: boolean
    inStock?: boolean
    trending?: boolean
    packageOptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    discount?: boolean | Product$discountArgs<ExtArgs>
    packageOption?: boolean | Product$packageOptionArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    price?: boolean
    discountId?: boolean
    material?: boolean
    dimensions?: boolean
    personalization?: boolean
    description?: boolean
    delivery?: boolean
    inStock?: boolean
    trending?: boolean
    packageOptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    discount?: boolean | Product$discountArgs<ExtArgs>
    packageOption?: boolean | Product$packageOptionArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    price?: boolean
    discountId?: boolean
    material?: boolean
    dimensions?: boolean
    personalization?: boolean
    description?: boolean
    delivery?: boolean
    inStock?: boolean
    trending?: boolean
    packageOptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "price" | "discountId" | "material" | "dimensions" | "personalization" | "description" | "delivery" | "inStock" | "trending" | "packageOptionId" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | Product$categoriesArgs<ExtArgs>
    priceTable?: boolean | Product$priceTableArgs<ExtArgs>
    discount?: boolean | Product$discountArgs<ExtArgs>
    packageOption?: boolean | Product$packageOptionArgs<ExtArgs>
    coverImage?: boolean | Product$coverImageArgs<ExtArgs>
    images?: boolean | Product$imagesArgs<ExtArgs>
    imagePersonalizationFields?: boolean | Product$imagePersonalizationFieldsArgs<ExtArgs>
    textPersonalizationFields?: boolean | Product$textPersonalizationFieldsArgs<ExtArgs>
    cartItems?: boolean | Product$cartItemsArgs<ExtArgs>
    ratings?: boolean | Product$ratingsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discount?: boolean | Product$discountArgs<ExtArgs>
    packageOption?: boolean | Product$packageOptionArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discount?: boolean | Product$discountArgs<ExtArgs>
    packageOption?: boolean | Product$packageOptionArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      priceTable: Prisma.$PriceRangePayload<ExtArgs>[]
      discount: Prisma.$DiscountPayload<ExtArgs> | null
      packageOption: Prisma.$PackageOptionPayload<ExtArgs> | null
      coverImage: Prisma.$MediaPayload<ExtArgs> | null
      images: Prisma.$MediaPayload<ExtArgs>[]
      imagePersonalizationFields: Prisma.$ImagePersonalizationFieldPayload<ExtArgs>[]
      textPersonalizationFields: Prisma.$TextPersonalizationFieldPayload<ExtArgs>[]
      cartItems: Prisma.$CartItemPayload<ExtArgs>[]
      ratings: Prisma.$RatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      price: number
      discountId: string | null
      material: string
      dimensions: string
      personalization: string
      description: string
      delivery: $Enums.DeliveryType
      inStock: boolean
      trending: boolean
      packageOptionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends Product$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    priceTable<T extends Product$priceTableArgs<ExtArgs> = {}>(args?: Subset<T, Product$priceTableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceRangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    discount<T extends Product$discountArgs<ExtArgs> = {}>(args?: Subset<T, Product$discountArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    packageOption<T extends Product$packageOptionArgs<ExtArgs> = {}>(args?: Subset<T, Product$packageOptionArgs<ExtArgs>>): Prisma__PackageOptionClient<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    coverImage<T extends Product$coverImageArgs<ExtArgs> = {}>(args?: Subset<T, Product$coverImageArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    images<T extends Product$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Product$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    imagePersonalizationFields<T extends Product$imagePersonalizationFieldsArgs<ExtArgs> = {}>(args?: Subset<T, Product$imagePersonalizationFieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePersonalizationFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    textPersonalizationFields<T extends Product$textPersonalizationFieldsArgs<ExtArgs> = {}>(args?: Subset<T, Product$textPersonalizationFieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextPersonalizationFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cartItems<T extends Product$cartItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$cartItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ratings<T extends Product$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Product$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly code: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Int'>
    readonly discountId: FieldRef<"Product", 'String'>
    readonly material: FieldRef<"Product", 'String'>
    readonly dimensions: FieldRef<"Product", 'String'>
    readonly personalization: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly delivery: FieldRef<"Product", 'DeliveryType'>
    readonly inStock: FieldRef<"Product", 'Boolean'>
    readonly trending: FieldRef<"Product", 'Boolean'>
    readonly packageOptionId: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.categories
   */
  export type Product$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Product.priceTable
   */
  export type Product$priceTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRange
     */
    select?: PriceRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRange
     */
    omit?: PriceRangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceRangeInclude<ExtArgs> | null
    where?: PriceRangeWhereInput
    orderBy?: PriceRangeOrderByWithRelationInput | PriceRangeOrderByWithRelationInput[]
    cursor?: PriceRangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceRangeScalarFieldEnum | PriceRangeScalarFieldEnum[]
  }

  /**
   * Product.discount
   */
  export type Product$discountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    where?: DiscountWhereInput
  }

  /**
   * Product.packageOption
   */
  export type Product$packageOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageOptionInclude<ExtArgs> | null
    where?: PackageOptionWhereInput
  }

  /**
   * Product.coverImage
   */
  export type Product$coverImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Product.images
   */
  export type Product$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Product.imagePersonalizationFields
   */
  export type Product$imagePersonalizationFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalizationField
     */
    select?: ImagePersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalizationField
     */
    omit?: ImagePersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationFieldInclude<ExtArgs> | null
    where?: ImagePersonalizationFieldWhereInput
    orderBy?: ImagePersonalizationFieldOrderByWithRelationInput | ImagePersonalizationFieldOrderByWithRelationInput[]
    cursor?: ImagePersonalizationFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImagePersonalizationFieldScalarFieldEnum | ImagePersonalizationFieldScalarFieldEnum[]
  }

  /**
   * Product.textPersonalizationFields
   */
  export type Product$textPersonalizationFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalizationField
     */
    select?: TextPersonalizationFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalizationField
     */
    omit?: TextPersonalizationFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationFieldInclude<ExtArgs> | null
    where?: TextPersonalizationFieldWhereInput
    orderBy?: TextPersonalizationFieldOrderByWithRelationInput | TextPersonalizationFieldOrderByWithRelationInput[]
    cursor?: TextPersonalizationFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TextPersonalizationFieldScalarFieldEnum | TextPersonalizationFieldScalarFieldEnum[]
  }

  /**
   * Product.cartItems
   */
  export type Product$cartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Product.ratings
   */
  export type Product$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Rating
   */

  export type AggregateRating = {
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  export type RatingAvgAggregateOutputType = {
    score: number | null
  }

  export type RatingSumAggregateOutputType = {
    score: number | null
  }

  export type RatingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    name: string | null
    score: number | null
    comment: string | null
    status: $Enums.RatingStatusType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RatingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    name: string | null
    score: number | null
    comment: string | null
    status: $Enums.RatingStatusType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RatingCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    name: number
    score: number
    comment: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RatingAvgAggregateInputType = {
    score?: true
  }

  export type RatingSumAggregateInputType = {
    score?: true
  }

  export type RatingMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    name?: true
    score?: true
    comment?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RatingMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    name?: true
    score?: true
    comment?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RatingCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    name?: true
    score?: true
    comment?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rating to aggregate.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ratings
    **/
    _count?: true | RatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatingMaxAggregateInputType
  }

  export type GetRatingAggregateType<T extends RatingAggregateArgs> = {
        [P in keyof T & keyof AggregateRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRating[P]>
      : GetScalarType<T[P], AggregateRating[P]>
  }




  export type RatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithAggregationInput | RatingOrderByWithAggregationInput[]
    by: RatingScalarFieldEnum[] | RatingScalarFieldEnum
    having?: RatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatingCountAggregateInputType | true
    _avg?: RatingAvgAggregateInputType
    _sum?: RatingSumAggregateInputType
    _min?: RatingMinAggregateInputType
    _max?: RatingMaxAggregateInputType
  }

  export type RatingGroupByOutputType = {
    id: string
    userId: string
    productId: string
    name: string
    score: number
    comment: string
    status: $Enums.RatingStatusType
    createdAt: Date
    updatedAt: Date
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  type GetRatingGroupByPayload<T extends RatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatingGroupByOutputType[P]>
            : GetScalarType<T[P], RatingGroupByOutputType[P]>
        }
      >
    >


  export type RatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    name?: boolean
    score?: boolean
    comment?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    name?: boolean
    score?: boolean
    comment?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    name?: boolean
    score?: boolean
    comment?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    name?: boolean
    score?: boolean
    comment?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "productId" | "name" | "score" | "comment" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["rating"]>
  export type RatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type RatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type RatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $RatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rating"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      productId: string
      name: string
      score: number
      comment: string
      status: $Enums.RatingStatusType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rating"]>
    composites: {}
  }

  type RatingGetPayload<S extends boolean | null | undefined | RatingDefaultArgs> = $Result.GetResult<Prisma.$RatingPayload, S>

  type RatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RatingCountAggregateInputType | true
    }

  export interface RatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rating'], meta: { name: 'Rating' } }
    /**
     * Find zero or one Rating that matches the filter.
     * @param {RatingFindUniqueArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RatingFindUniqueArgs>(args: SelectSubset<T, RatingFindUniqueArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RatingFindUniqueOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RatingFindUniqueOrThrowArgs>(args: SelectSubset<T, RatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RatingFindFirstArgs>(args?: SelectSubset<T, RatingFindFirstArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RatingFindFirstOrThrowArgs>(args?: SelectSubset<T, RatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ratings
     * const ratings = await prisma.rating.findMany()
     * 
     * // Get first 10 Ratings
     * const ratings = await prisma.rating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ratingWithIdOnly = await prisma.rating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RatingFindManyArgs>(args?: SelectSubset<T, RatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rating.
     * @param {RatingCreateArgs} args - Arguments to create a Rating.
     * @example
     * // Create one Rating
     * const Rating = await prisma.rating.create({
     *   data: {
     *     // ... data to create a Rating
     *   }
     * })
     * 
     */
    create<T extends RatingCreateArgs>(args: SelectSubset<T, RatingCreateArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ratings.
     * @param {RatingCreateManyArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const rating = await prisma.rating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RatingCreateManyArgs>(args?: SelectSubset<T, RatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ratings and returns the data saved in the database.
     * @param {RatingCreateManyAndReturnArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const rating = await prisma.rating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ratings and only return the `id`
     * const ratingWithIdOnly = await prisma.rating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RatingCreateManyAndReturnArgs>(args?: SelectSubset<T, RatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rating.
     * @param {RatingDeleteArgs} args - Arguments to delete one Rating.
     * @example
     * // Delete one Rating
     * const Rating = await prisma.rating.delete({
     *   where: {
     *     // ... filter to delete one Rating
     *   }
     * })
     * 
     */
    delete<T extends RatingDeleteArgs>(args: SelectSubset<T, RatingDeleteArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rating.
     * @param {RatingUpdateArgs} args - Arguments to update one Rating.
     * @example
     * // Update one Rating
     * const rating = await prisma.rating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RatingUpdateArgs>(args: SelectSubset<T, RatingUpdateArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ratings.
     * @param {RatingDeleteManyArgs} args - Arguments to filter Ratings to delete.
     * @example
     * // Delete a few Ratings
     * const { count } = await prisma.rating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RatingDeleteManyArgs>(args?: SelectSubset<T, RatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RatingUpdateManyArgs>(args: SelectSubset<T, RatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings and returns the data updated in the database.
     * @param {RatingUpdateManyAndReturnArgs} args - Arguments to update many Ratings.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ratings and only return the `id`
     * const ratingWithIdOnly = await prisma.rating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RatingUpdateManyAndReturnArgs>(args: SelectSubset<T, RatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rating.
     * @param {RatingUpsertArgs} args - Arguments to update or create a Rating.
     * @example
     * // Update or create a Rating
     * const rating = await prisma.rating.upsert({
     *   create: {
     *     // ... data to create a Rating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rating we want to update
     *   }
     * })
     */
    upsert<T extends RatingUpsertArgs>(args: SelectSubset<T, RatingUpsertArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingCountArgs} args - Arguments to filter Ratings to count.
     * @example
     * // Count the number of Ratings
     * const count = await prisma.rating.count({
     *   where: {
     *     // ... the filter for the Ratings we want to count
     *   }
     * })
    **/
    count<T extends RatingCountArgs>(
      args?: Subset<T, RatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatingAggregateArgs>(args: Subset<T, RatingAggregateArgs>): Prisma.PrismaPromise<GetRatingAggregateType<T>>

    /**
     * Group by Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RatingGroupByArgs['orderBy'] }
        : { orderBy?: RatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rating model
   */
  readonly fields: RatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rating model
   */
  interface RatingFieldRefs {
    readonly id: FieldRef<"Rating", 'String'>
    readonly userId: FieldRef<"Rating", 'String'>
    readonly productId: FieldRef<"Rating", 'String'>
    readonly name: FieldRef<"Rating", 'String'>
    readonly score: FieldRef<"Rating", 'Int'>
    readonly comment: FieldRef<"Rating", 'String'>
    readonly status: FieldRef<"Rating", 'RatingStatusType'>
    readonly createdAt: FieldRef<"Rating", 'DateTime'>
    readonly updatedAt: FieldRef<"Rating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Rating findUnique
   */
  export type RatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating findUniqueOrThrow
   */
  export type RatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating findFirst
   */
  export type RatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating findFirstOrThrow
   */
  export type RatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating findMany
   */
  export type RatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Ratings to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating create
   */
  export type RatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to create a Rating.
     */
    data: XOR<RatingCreateInput, RatingUncheckedCreateInput>
  }

  /**
   * Rating createMany
   */
  export type RatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ratings.
     */
    data: RatingCreateManyInput | RatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rating createManyAndReturn
   */
  export type RatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * The data used to create many Ratings.
     */
    data: RatingCreateManyInput | RatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rating update
   */
  export type RatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to update a Rating.
     */
    data: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
    /**
     * Choose, which Rating to update.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating updateMany
   */
  export type RatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to update.
     */
    limit?: number
  }

  /**
   * Rating updateManyAndReturn
   */
  export type RatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rating upsert
   */
  export type RatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The filter to search for the Rating to update in case it exists.
     */
    where: RatingWhereUniqueInput
    /**
     * In case the Rating found by the `where` argument doesn't exist, create a new Rating with this data.
     */
    create: XOR<RatingCreateInput, RatingUncheckedCreateInput>
    /**
     * In case the Rating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
  }

  /**
   * Rating delete
   */
  export type RatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter which Rating to delete.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating deleteMany
   */
  export type RatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ratings to delete
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to delete.
     */
    limit?: number
  }

  /**
   * Rating without action
   */
  export type RatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    name: string | null
    key: string | null
    type: string | null
    url: string | null
    userId: string | null
    categoryId: string | null
    deliveryServiceId: string | null
    desktopBannerImageId: string | null
    mobileBannerImageId: string | null
    productCoverId: string | null
    productImagesId: string | null
    imagePersonalizationId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    name: string | null
    key: string | null
    type: string | null
    url: string | null
    userId: string | null
    categoryId: string | null
    deliveryServiceId: string | null
    desktopBannerImageId: string | null
    mobileBannerImageId: string | null
    productCoverId: string | null
    productImagesId: string | null
    imagePersonalizationId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    name: number
    key: number
    type: number
    url: number
    userId: number
    categoryId: number
    deliveryServiceId: number
    desktopBannerImageId: number
    mobileBannerImageId: number
    productCoverId: number
    productImagesId: number
    imagePersonalizationId: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type MediaMinAggregateInputType = {
    id?: true
    name?: true
    key?: true
    type?: true
    url?: true
    userId?: true
    categoryId?: true
    deliveryServiceId?: true
    desktopBannerImageId?: true
    mobileBannerImageId?: true
    productCoverId?: true
    productImagesId?: true
    imagePersonalizationId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    name?: true
    key?: true
    type?: true
    url?: true
    userId?: true
    categoryId?: true
    deliveryServiceId?: true
    desktopBannerImageId?: true
    mobileBannerImageId?: true
    productCoverId?: true
    productImagesId?: true
    imagePersonalizationId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    name?: true
    key?: true
    type?: true
    url?: true
    userId?: true
    categoryId?: true
    deliveryServiceId?: true
    desktopBannerImageId?: true
    mobileBannerImageId?: true
    productCoverId?: true
    productImagesId?: true
    imagePersonalizationId?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    name: string
    key: string
    type: string
    url: string
    userId: string | null
    categoryId: string | null
    deliveryServiceId: string | null
    desktopBannerImageId: string | null
    mobileBannerImageId: string | null
    productCoverId: string | null
    productImagesId: string | null
    imagePersonalizationId: string | null
    updatedAt: Date
    createdAt: Date
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    key?: boolean
    type?: boolean
    url?: boolean
    userId?: boolean
    categoryId?: boolean
    deliveryServiceId?: boolean
    desktopBannerImageId?: boolean
    mobileBannerImageId?: boolean
    productCoverId?: boolean
    productImagesId?: boolean
    imagePersonalizationId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | Media$userArgs<ExtArgs>
    category?: boolean | Media$categoryArgs<ExtArgs>
    deliveryService?: boolean | Media$deliveryServiceArgs<ExtArgs>
    desktopBannerImage?: boolean | Media$desktopBannerImageArgs<ExtArgs>
    mobileBannerImage?: boolean | Media$mobileBannerImageArgs<ExtArgs>
    productCover?: boolean | Media$productCoverArgs<ExtArgs>
    productImages?: boolean | Media$productImagesArgs<ExtArgs>
    imagePersonalization?: boolean | Media$imagePersonalizationArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    key?: boolean
    type?: boolean
    url?: boolean
    userId?: boolean
    categoryId?: boolean
    deliveryServiceId?: boolean
    desktopBannerImageId?: boolean
    mobileBannerImageId?: boolean
    productCoverId?: boolean
    productImagesId?: boolean
    imagePersonalizationId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | Media$userArgs<ExtArgs>
    category?: boolean | Media$categoryArgs<ExtArgs>
    deliveryService?: boolean | Media$deliveryServiceArgs<ExtArgs>
    desktopBannerImage?: boolean | Media$desktopBannerImageArgs<ExtArgs>
    mobileBannerImage?: boolean | Media$mobileBannerImageArgs<ExtArgs>
    productCover?: boolean | Media$productCoverArgs<ExtArgs>
    productImages?: boolean | Media$productImagesArgs<ExtArgs>
    imagePersonalization?: boolean | Media$imagePersonalizationArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    key?: boolean
    type?: boolean
    url?: boolean
    userId?: boolean
    categoryId?: boolean
    deliveryServiceId?: boolean
    desktopBannerImageId?: boolean
    mobileBannerImageId?: boolean
    productCoverId?: boolean
    productImagesId?: boolean
    imagePersonalizationId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | Media$userArgs<ExtArgs>
    category?: boolean | Media$categoryArgs<ExtArgs>
    deliveryService?: boolean | Media$deliveryServiceArgs<ExtArgs>
    desktopBannerImage?: boolean | Media$desktopBannerImageArgs<ExtArgs>
    mobileBannerImage?: boolean | Media$mobileBannerImageArgs<ExtArgs>
    productCover?: boolean | Media$productCoverArgs<ExtArgs>
    productImages?: boolean | Media$productImagesArgs<ExtArgs>
    imagePersonalization?: boolean | Media$imagePersonalizationArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    name?: boolean
    key?: boolean
    type?: boolean
    url?: boolean
    userId?: boolean
    categoryId?: boolean
    deliveryServiceId?: boolean
    desktopBannerImageId?: boolean
    mobileBannerImageId?: boolean
    productCoverId?: boolean
    productImagesId?: boolean
    imagePersonalizationId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type MediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "key" | "type" | "url" | "userId" | "categoryId" | "deliveryServiceId" | "desktopBannerImageId" | "mobileBannerImageId" | "productCoverId" | "productImagesId" | "imagePersonalizationId" | "updatedAt" | "createdAt", ExtArgs["result"]["media"]>
  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Media$userArgs<ExtArgs>
    category?: boolean | Media$categoryArgs<ExtArgs>
    deliveryService?: boolean | Media$deliveryServiceArgs<ExtArgs>
    desktopBannerImage?: boolean | Media$desktopBannerImageArgs<ExtArgs>
    mobileBannerImage?: boolean | Media$mobileBannerImageArgs<ExtArgs>
    productCover?: boolean | Media$productCoverArgs<ExtArgs>
    productImages?: boolean | Media$productImagesArgs<ExtArgs>
    imagePersonalization?: boolean | Media$imagePersonalizationArgs<ExtArgs>
  }
  export type MediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Media$userArgs<ExtArgs>
    category?: boolean | Media$categoryArgs<ExtArgs>
    deliveryService?: boolean | Media$deliveryServiceArgs<ExtArgs>
    desktopBannerImage?: boolean | Media$desktopBannerImageArgs<ExtArgs>
    mobileBannerImage?: boolean | Media$mobileBannerImageArgs<ExtArgs>
    productCover?: boolean | Media$productCoverArgs<ExtArgs>
    productImages?: boolean | Media$productImagesArgs<ExtArgs>
    imagePersonalization?: boolean | Media$imagePersonalizationArgs<ExtArgs>
  }
  export type MediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Media$userArgs<ExtArgs>
    category?: boolean | Media$categoryArgs<ExtArgs>
    deliveryService?: boolean | Media$deliveryServiceArgs<ExtArgs>
    desktopBannerImage?: boolean | Media$desktopBannerImageArgs<ExtArgs>
    mobileBannerImage?: boolean | Media$mobileBannerImageArgs<ExtArgs>
    productCover?: boolean | Media$productCoverArgs<ExtArgs>
    productImages?: boolean | Media$productImagesArgs<ExtArgs>
    imagePersonalization?: boolean | Media$imagePersonalizationArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      category: Prisma.$CategoryPayload<ExtArgs> | null
      deliveryService: Prisma.$DeliveryServicePayload<ExtArgs> | null
      desktopBannerImage: Prisma.$BannerPayload<ExtArgs> | null
      mobileBannerImage: Prisma.$BannerPayload<ExtArgs> | null
      productCover: Prisma.$ProductPayload<ExtArgs> | null
      productImages: Prisma.$ProductPayload<ExtArgs> | null
      imagePersonalization: Prisma.$ImagePersonalizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      key: string
      type: string
      url: string
      userId: string | null
      categoryId: string | null
      deliveryServiceId: string | null
      desktopBannerImageId: string | null
      mobileBannerImageId: string | null
      productCoverId: string | null
      productImagesId: string | null
      imagePersonalizationId: string | null
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media and returns the data updated in the database.
     * @param {MediaUpdateManyAndReturnArgs} args - Arguments to update many Media.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Media$userArgs<ExtArgs> = {}>(args?: Subset<T, Media$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends Media$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Media$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deliveryService<T extends Media$deliveryServiceArgs<ExtArgs> = {}>(args?: Subset<T, Media$deliveryServiceArgs<ExtArgs>>): Prisma__DeliveryServiceClient<$Result.GetResult<Prisma.$DeliveryServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    desktopBannerImage<T extends Media$desktopBannerImageArgs<ExtArgs> = {}>(args?: Subset<T, Media$desktopBannerImageArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mobileBannerImage<T extends Media$mobileBannerImageArgs<ExtArgs> = {}>(args?: Subset<T, Media$mobileBannerImageArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    productCover<T extends Media$productCoverArgs<ExtArgs> = {}>(args?: Subset<T, Media$productCoverArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    productImages<T extends Media$productImagesArgs<ExtArgs> = {}>(args?: Subset<T, Media$productImagesArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    imagePersonalization<T extends Media$imagePersonalizationArgs<ExtArgs> = {}>(args?: Subset<T, Media$imagePersonalizationArgs<ExtArgs>>): Prisma__ImagePersonalizationClient<$Result.GetResult<Prisma.$ImagePersonalizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly name: FieldRef<"Media", 'String'>
    readonly key: FieldRef<"Media", 'String'>
    readonly type: FieldRef<"Media", 'String'>
    readonly url: FieldRef<"Media", 'String'>
    readonly userId: FieldRef<"Media", 'String'>
    readonly categoryId: FieldRef<"Media", 'String'>
    readonly deliveryServiceId: FieldRef<"Media", 'String'>
    readonly desktopBannerImageId: FieldRef<"Media", 'String'>
    readonly mobileBannerImageId: FieldRef<"Media", 'String'>
    readonly productCoverId: FieldRef<"Media", 'String'>
    readonly productImagesId: FieldRef<"Media", 'String'>
    readonly imagePersonalizationId: FieldRef<"Media", 'String'>
    readonly updatedAt: FieldRef<"Media", 'DateTime'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media updateManyAndReturn
   */
  export type MediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to delete.
     */
    limit?: number
  }

  /**
   * Media.user
   */
  export type Media$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Media.category
   */
  export type Media$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Media.deliveryService
   */
  export type Media$deliveryServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryService
     */
    select?: DeliveryServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryService
     */
    omit?: DeliveryServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryServiceInclude<ExtArgs> | null
    where?: DeliveryServiceWhereInput
  }

  /**
   * Media.desktopBannerImage
   */
  export type Media$desktopBannerImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    where?: BannerWhereInput
  }

  /**
   * Media.mobileBannerImage
   */
  export type Media$mobileBannerImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    where?: BannerWhereInput
  }

  /**
   * Media.productCover
   */
  export type Media$productCoverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * Media.productImages
   */
  export type Media$productImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * Media.imagePersonalization
   */
  export type Media$imagePersonalizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalization
     */
    select?: ImagePersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalization
     */
    omit?: ImagePersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationInclude<ExtArgs> | null
    where?: ImagePersonalizationWhereInput
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model Cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  export type CartAvgAggregateOutputType = {
    onlinePrice: number | null
    totalPrice: number | null
    deliveryFee: number | null
    totalPriceWithDeliveryFee: number | null
    discount: number | null
  }

  export type CartSumAggregateOutputType = {
    onlinePrice: number | null
    totalPrice: number | null
    deliveryFee: number | null
    totalPriceWithDeliveryFee: number | null
    discount: number | null
  }

  export type CartMinAggregateOutputType = {
    id: string | null
    userId: string | null
    onlinePrice: number | null
    totalPrice: number | null
    deliveryFee: number | null
    totalPriceWithDeliveryFee: number | null
    discount: number | null
    couponId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    onlinePrice: number | null
    totalPrice: number | null
    deliveryFee: number | null
    totalPriceWithDeliveryFee: number | null
    discount: number | null
    couponId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartCountAggregateOutputType = {
    id: number
    userId: number
    onlinePrice: number
    totalPrice: number
    deliveryFee: number
    totalPriceWithDeliveryFee: number
    discount: number
    couponId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartAvgAggregateInputType = {
    onlinePrice?: true
    totalPrice?: true
    deliveryFee?: true
    totalPriceWithDeliveryFee?: true
    discount?: true
  }

  export type CartSumAggregateInputType = {
    onlinePrice?: true
    totalPrice?: true
    deliveryFee?: true
    totalPriceWithDeliveryFee?: true
    discount?: true
  }

  export type CartMinAggregateInputType = {
    id?: true
    userId?: true
    onlinePrice?: true
    totalPrice?: true
    deliveryFee?: true
    totalPriceWithDeliveryFee?: true
    discount?: true
    couponId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartMaxAggregateInputType = {
    id?: true
    userId?: true
    onlinePrice?: true
    totalPrice?: true
    deliveryFee?: true
    totalPriceWithDeliveryFee?: true
    discount?: true
    couponId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartCountAggregateInputType = {
    id?: true
    userId?: true
    onlinePrice?: true
    totalPrice?: true
    deliveryFee?: true
    totalPriceWithDeliveryFee?: true
    discount?: true
    couponId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cart to aggregate.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carts
    **/
    _count?: true | CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartMaxAggregateInputType
  }

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
        [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>
  }




  export type CartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
    orderBy?: CartOrderByWithAggregationInput | CartOrderByWithAggregationInput[]
    by: CartScalarFieldEnum[] | CartScalarFieldEnum
    having?: CartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartCountAggregateInputType | true
    _avg?: CartAvgAggregateInputType
    _sum?: CartSumAggregateInputType
    _min?: CartMinAggregateInputType
    _max?: CartMaxAggregateInputType
  }

  export type CartGroupByOutputType = {
    id: string
    userId: string
    onlinePrice: number
    totalPrice: number
    deliveryFee: number
    totalPriceWithDeliveryFee: number
    discount: number
    couponId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  type GetCartGroupByPayload<T extends CartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartGroupByOutputType[P]>
            : GetScalarType<T[P], CartGroupByOutputType[P]>
        }
      >
    >


  export type CartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    onlinePrice?: boolean
    totalPrice?: boolean
    deliveryFee?: boolean
    totalPriceWithDeliveryFee?: boolean
    discount?: boolean
    couponId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Cart$itemsArgs<ExtArgs>
    coupon?: boolean | Cart$couponArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    onlinePrice?: boolean
    totalPrice?: boolean
    deliveryFee?: boolean
    totalPriceWithDeliveryFee?: boolean
    discount?: boolean
    couponId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | Cart$couponArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    onlinePrice?: boolean
    totalPrice?: boolean
    deliveryFee?: boolean
    totalPriceWithDeliveryFee?: boolean
    discount?: boolean
    couponId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | Cart$couponArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectScalar = {
    id?: boolean
    userId?: boolean
    onlinePrice?: boolean
    totalPrice?: boolean
    deliveryFee?: boolean
    totalPriceWithDeliveryFee?: boolean
    discount?: boolean
    couponId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "onlinePrice" | "totalPrice" | "deliveryFee" | "totalPriceWithDeliveryFee" | "discount" | "couponId" | "createdAt" | "updatedAt", ExtArgs["result"]["cart"]>
  export type CartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Cart$itemsArgs<ExtArgs>
    coupon?: boolean | Cart$couponArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | Cart$couponArgs<ExtArgs>
  }
  export type CartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | Cart$couponArgs<ExtArgs>
  }

  export type $CartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cart"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$CartItemPayload<ExtArgs>[]
      coupon: Prisma.$CouponPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      onlinePrice: number
      totalPrice: number
      deliveryFee: number
      totalPriceWithDeliveryFee: number
      discount: number
      couponId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cart"]>
    composites: {}
  }

  type CartGetPayload<S extends boolean | null | undefined | CartDefaultArgs> = $Result.GetResult<Prisma.$CartPayload, S>

  type CartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartCountAggregateInputType | true
    }

  export interface CartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cart'], meta: { name: 'Cart' } }
    /**
     * Find zero or one Cart that matches the filter.
     * @param {CartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartFindUniqueArgs>(args: SelectSubset<T, CartFindUniqueArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartFindUniqueOrThrowArgs>(args: SelectSubset<T, CartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartFindFirstArgs>(args?: SelectSubset<T, CartFindFirstArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartFindFirstOrThrowArgs>(args?: SelectSubset<T, CartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartFindManyArgs>(args?: SelectSubset<T, CartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cart.
     * @param {CartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     * 
     */
    create<T extends CartCreateArgs>(args: SelectSubset<T, CartCreateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carts.
     * @param {CartCreateManyArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartCreateManyArgs>(args?: SelectSubset<T, CartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carts and returns the data saved in the database.
     * @param {CartCreateManyAndReturnArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartCreateManyAndReturnArgs>(args?: SelectSubset<T, CartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cart.
     * @param {CartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     * 
     */
    delete<T extends CartDeleteArgs>(args: SelectSubset<T, CartDeleteArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cart.
     * @param {CartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartUpdateArgs>(args: SelectSubset<T, CartUpdateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carts.
     * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartDeleteManyArgs>(args?: SelectSubset<T, CartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartUpdateManyArgs>(args: SelectSubset<T, CartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts and returns the data updated in the database.
     * @param {CartUpdateManyAndReturnArgs} args - Arguments to update many Carts.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartUpdateManyAndReturnArgs>(args: SelectSubset<T, CartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cart.
     * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
     */
    upsert<T extends CartUpsertArgs>(args: SelectSubset<T, CartUpsertArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends CartCountArgs>(
      args?: Subset<T, CartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartGroupByArgs['orderBy'] }
        : { orderBy?: CartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cart model
   */
  readonly fields: CartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Cart$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Cart$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coupon<T extends Cart$couponArgs<ExtArgs> = {}>(args?: Subset<T, Cart$couponArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cart model
   */
  interface CartFieldRefs {
    readonly id: FieldRef<"Cart", 'String'>
    readonly userId: FieldRef<"Cart", 'String'>
    readonly onlinePrice: FieldRef<"Cart", 'Int'>
    readonly totalPrice: FieldRef<"Cart", 'Int'>
    readonly deliveryFee: FieldRef<"Cart", 'Int'>
    readonly totalPriceWithDeliveryFee: FieldRef<"Cart", 'Int'>
    readonly discount: FieldRef<"Cart", 'Int'>
    readonly couponId: FieldRef<"Cart", 'String'>
    readonly createdAt: FieldRef<"Cart", 'DateTime'>
    readonly updatedAt: FieldRef<"Cart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cart findUnique
   */
  export type CartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findUniqueOrThrow
   */
  export type CartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findFirst
   */
  export type CartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findFirstOrThrow
   */
  export type CartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findMany
   */
  export type CartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart create
   */
  export type CartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to create a Cart.
     */
    data: XOR<CartCreateInput, CartUncheckedCreateInput>
  }

  /**
   * Cart createMany
   */
  export type CartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cart createManyAndReturn
   */
  export type CartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart update
   */
  export type CartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to update a Cart.
     */
    data: XOR<CartUpdateInput, CartUncheckedUpdateInput>
    /**
     * Choose, which Cart to update.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart updateMany
   */
  export type CartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
  }

  /**
   * Cart updateManyAndReturn
   */
  export type CartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart upsert
   */
  export type CartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The filter to search for the Cart to update in case it exists.
     */
    where: CartWhereUniqueInput
    /**
     * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
     */
    create: XOR<CartCreateInput, CartUncheckedCreateInput>
    /**
     * In case the Cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartUpdateInput, CartUncheckedUpdateInput>
  }

  /**
   * Cart delete
   */
  export type CartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter which Cart to delete.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart deleteMany
   */
  export type CartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carts to delete
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to delete.
     */
    limit?: number
  }

  /**
   * Cart.items
   */
  export type Cart$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Cart.coupon
   */
  export type Cart$couponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    where?: CouponWhereInput
  }

  /**
   * Cart without action
   */
  export type CartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
  }


  /**
   * Model CartItem
   */

  export type AggregateCartItem = {
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  export type CartItemAvgAggregateOutputType = {
    price: number | null
    deliveryFee: number | null
    quantity: number | null
  }

  export type CartItemSumAggregateOutputType = {
    price: number | null
    deliveryFee: number | null
    quantity: number | null
  }

  export type CartItemMinAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    price: number | null
    deliveryFee: number | null
    quantity: number | null
    fontType: $Enums.FontType | null
    packageOptionSelected: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartItemMaxAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    price: number | null
    deliveryFee: number | null
    quantity: number | null
    fontType: $Enums.FontType | null
    packageOptionSelected: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartItemCountAggregateOutputType = {
    id: number
    cartId: number
    productId: number
    price: number
    deliveryFee: number
    quantity: number
    fontType: number
    packageOptionSelected: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartItemAvgAggregateInputType = {
    price?: true
    deliveryFee?: true
    quantity?: true
  }

  export type CartItemSumAggregateInputType = {
    price?: true
    deliveryFee?: true
    quantity?: true
  }

  export type CartItemMinAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    price?: true
    deliveryFee?: true
    quantity?: true
    fontType?: true
    packageOptionSelected?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartItemMaxAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    price?: true
    deliveryFee?: true
    quantity?: true
    fontType?: true
    packageOptionSelected?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartItemCountAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    price?: true
    deliveryFee?: true
    quantity?: true
    fontType?: true
    packageOptionSelected?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItem to aggregate.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CartItems
    **/
    _count?: true | CartItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartItemMaxAggregateInputType
  }

  export type GetCartItemAggregateType<T extends CartItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCartItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartItem[P]>
      : GetScalarType<T[P], AggregateCartItem[P]>
  }




  export type CartItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithAggregationInput | CartItemOrderByWithAggregationInput[]
    by: CartItemScalarFieldEnum[] | CartItemScalarFieldEnum
    having?: CartItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartItemCountAggregateInputType | true
    _avg?: CartItemAvgAggregateInputType
    _sum?: CartItemSumAggregateInputType
    _min?: CartItemMinAggregateInputType
    _max?: CartItemMaxAggregateInputType
  }

  export type CartItemGroupByOutputType = {
    id: string
    cartId: string
    productId: string
    price: number
    deliveryFee: number
    quantity: number
    fontType: $Enums.FontType
    packageOptionSelected: boolean
    createdAt: Date
    updatedAt: Date
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  type GetCartItemGroupByPayload<T extends CartItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartItemGroupByOutputType[P]>
            : GetScalarType<T[P], CartItemGroupByOutputType[P]>
        }
      >
    >


  export type CartItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    price?: boolean
    deliveryFee?: boolean
    quantity?: boolean
    fontType?: boolean
    packageOptionSelected?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    textPersonalizations?: boolean | CartItem$textPersonalizationsArgs<ExtArgs>
    imagePersonalizations?: boolean | CartItem$imagePersonalizationsArgs<ExtArgs>
    _count?: boolean | CartItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    price?: boolean
    deliveryFee?: boolean
    quantity?: boolean
    fontType?: boolean
    packageOptionSelected?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    price?: boolean
    deliveryFee?: boolean
    quantity?: boolean
    fontType?: boolean
    packageOptionSelected?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectScalar = {
    id?: boolean
    cartId?: boolean
    productId?: boolean
    price?: boolean
    deliveryFee?: boolean
    quantity?: boolean
    fontType?: boolean
    packageOptionSelected?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CartItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cartId" | "productId" | "price" | "deliveryFee" | "quantity" | "fontType" | "packageOptionSelected" | "createdAt" | "updatedAt", ExtArgs["result"]["cartItem"]>
  export type CartItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    textPersonalizations?: boolean | CartItem$textPersonalizationsArgs<ExtArgs>
    imagePersonalizations?: boolean | CartItem$imagePersonalizationsArgs<ExtArgs>
    _count?: boolean | CartItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CartItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CartItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $CartItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CartItem"
    objects: {
      cart: Prisma.$CartPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      textPersonalizations: Prisma.$TextPersonalizationPayload<ExtArgs>[]
      imagePersonalizations: Prisma.$ImagePersonalizationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cartId: string
      productId: string
      price: number
      deliveryFee: number
      quantity: number
      fontType: $Enums.FontType
      packageOptionSelected: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cartItem"]>
    composites: {}
  }

  type CartItemGetPayload<S extends boolean | null | undefined | CartItemDefaultArgs> = $Result.GetResult<Prisma.$CartItemPayload, S>

  type CartItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartItemCountAggregateInputType | true
    }

  export interface CartItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CartItem'], meta: { name: 'CartItem' } }
    /**
     * Find zero or one CartItem that matches the filter.
     * @param {CartItemFindUniqueArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartItemFindUniqueArgs>(args: SelectSubset<T, CartItemFindUniqueArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CartItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartItemFindUniqueOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CartItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartItemFindFirstArgs>(args?: SelectSubset<T, CartItemFindFirstArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CartItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CartItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartItems
     * const cartItems = await prisma.cartItem.findMany()
     * 
     * // Get first 10 CartItems
     * const cartItems = await prisma.cartItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartItemFindManyArgs>(args?: SelectSubset<T, CartItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CartItem.
     * @param {CartItemCreateArgs} args - Arguments to create a CartItem.
     * @example
     * // Create one CartItem
     * const CartItem = await prisma.cartItem.create({
     *   data: {
     *     // ... data to create a CartItem
     *   }
     * })
     * 
     */
    create<T extends CartItemCreateArgs>(args: SelectSubset<T, CartItemCreateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CartItems.
     * @param {CartItemCreateManyArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartItemCreateManyArgs>(args?: SelectSubset<T, CartItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CartItems and returns the data saved in the database.
     * @param {CartItemCreateManyAndReturnArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CartItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CartItem.
     * @param {CartItemDeleteArgs} args - Arguments to delete one CartItem.
     * @example
     * // Delete one CartItem
     * const CartItem = await prisma.cartItem.delete({
     *   where: {
     *     // ... filter to delete one CartItem
     *   }
     * })
     * 
     */
    delete<T extends CartItemDeleteArgs>(args: SelectSubset<T, CartItemDeleteArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CartItem.
     * @param {CartItemUpdateArgs} args - Arguments to update one CartItem.
     * @example
     * // Update one CartItem
     * const cartItem = await prisma.cartItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartItemUpdateArgs>(args: SelectSubset<T, CartItemUpdateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CartItems.
     * @param {CartItemDeleteManyArgs} args - Arguments to filter CartItems to delete.
     * @example
     * // Delete a few CartItems
     * const { count } = await prisma.cartItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartItemDeleteManyArgs>(args?: SelectSubset<T, CartItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartItemUpdateManyArgs>(args: SelectSubset<T, CartItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems and returns the data updated in the database.
     * @param {CartItemUpdateManyAndReturnArgs} args - Arguments to update many CartItems.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CartItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CartItem.
     * @param {CartItemUpsertArgs} args - Arguments to update or create a CartItem.
     * @example
     * // Update or create a CartItem
     * const cartItem = await prisma.cartItem.upsert({
     *   create: {
     *     // ... data to create a CartItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartItem we want to update
     *   }
     * })
     */
    upsert<T extends CartItemUpsertArgs>(args: SelectSubset<T, CartItemUpsertArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemCountArgs} args - Arguments to filter CartItems to count.
     * @example
     * // Count the number of CartItems
     * const count = await prisma.cartItem.count({
     *   where: {
     *     // ... the filter for the CartItems we want to count
     *   }
     * })
    **/
    count<T extends CartItemCountArgs>(
      args?: Subset<T, CartItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartItemAggregateArgs>(args: Subset<T, CartItemAggregateArgs>): Prisma.PrismaPromise<GetCartItemAggregateType<T>>

    /**
     * Group by CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartItemGroupByArgs['orderBy'] }
        : { orderBy?: CartItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CartItem model
   */
  readonly fields: CartItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cart<T extends CartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CartDefaultArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    textPersonalizations<T extends CartItem$textPersonalizationsArgs<ExtArgs> = {}>(args?: Subset<T, CartItem$textPersonalizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextPersonalizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    imagePersonalizations<T extends CartItem$imagePersonalizationsArgs<ExtArgs> = {}>(args?: Subset<T, CartItem$imagePersonalizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePersonalizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CartItem model
   */
  interface CartItemFieldRefs {
    readonly id: FieldRef<"CartItem", 'String'>
    readonly cartId: FieldRef<"CartItem", 'String'>
    readonly productId: FieldRef<"CartItem", 'String'>
    readonly price: FieldRef<"CartItem", 'Int'>
    readonly deliveryFee: FieldRef<"CartItem", 'Int'>
    readonly quantity: FieldRef<"CartItem", 'Int'>
    readonly fontType: FieldRef<"CartItem", 'FontType'>
    readonly packageOptionSelected: FieldRef<"CartItem", 'Boolean'>
    readonly createdAt: FieldRef<"CartItem", 'DateTime'>
    readonly updatedAt: FieldRef<"CartItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CartItem findUnique
   */
  export type CartItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findUniqueOrThrow
   */
  export type CartItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findFirst
   */
  export type CartItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findFirstOrThrow
   */
  export type CartItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findMany
   */
  export type CartItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItems to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem create
   */
  export type CartItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CartItem.
     */
    data: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
  }

  /**
   * CartItem createMany
   */
  export type CartItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CartItem createManyAndReturn
   */
  export type CartItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItem update
   */
  export type CartItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CartItem.
     */
    data: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
    /**
     * Choose, which CartItem to update.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem updateMany
   */
  export type CartItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
  }

  /**
   * CartItem updateManyAndReturn
   */
  export type CartItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItem upsert
   */
  export type CartItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CartItem to update in case it exists.
     */
    where: CartItemWhereUniqueInput
    /**
     * In case the CartItem found by the `where` argument doesn't exist, create a new CartItem with this data.
     */
    create: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
    /**
     * In case the CartItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
  }

  /**
   * CartItem delete
   */
  export type CartItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter which CartItem to delete.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem deleteMany
   */
  export type CartItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItems to delete
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to delete.
     */
    limit?: number
  }

  /**
   * CartItem.textPersonalizations
   */
  export type CartItem$textPersonalizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalization
     */
    select?: TextPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalization
     */
    omit?: TextPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationInclude<ExtArgs> | null
    where?: TextPersonalizationWhereInput
    orderBy?: TextPersonalizationOrderByWithRelationInput | TextPersonalizationOrderByWithRelationInput[]
    cursor?: TextPersonalizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TextPersonalizationScalarFieldEnum | TextPersonalizationScalarFieldEnum[]
  }

  /**
   * CartItem.imagePersonalizations
   */
  export type CartItem$imagePersonalizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalization
     */
    select?: ImagePersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalization
     */
    omit?: ImagePersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationInclude<ExtArgs> | null
    where?: ImagePersonalizationWhereInput
    orderBy?: ImagePersonalizationOrderByWithRelationInput | ImagePersonalizationOrderByWithRelationInput[]
    cursor?: ImagePersonalizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImagePersonalizationScalarFieldEnum | ImagePersonalizationScalarFieldEnum[]
  }

  /**
   * CartItem without action
   */
  export type CartItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
  }


  /**
   * Model TextPersonalization
   */

  export type AggregateTextPersonalization = {
    _count: TextPersonalizationCountAggregateOutputType | null
    _min: TextPersonalizationMinAggregateOutputType | null
    _max: TextPersonalizationMaxAggregateOutputType | null
  }

  export type TextPersonalizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    value: string | null
    cartItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TextPersonalizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    value: string | null
    cartItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TextPersonalizationCountAggregateOutputType = {
    id: number
    name: number
    value: number
    cartItemId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TextPersonalizationMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    cartItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TextPersonalizationMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    cartItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TextPersonalizationCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    cartItemId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TextPersonalizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TextPersonalization to aggregate.
     */
    where?: TextPersonalizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextPersonalizations to fetch.
     */
    orderBy?: TextPersonalizationOrderByWithRelationInput | TextPersonalizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TextPersonalizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextPersonalizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextPersonalizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TextPersonalizations
    **/
    _count?: true | TextPersonalizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TextPersonalizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TextPersonalizationMaxAggregateInputType
  }

  export type GetTextPersonalizationAggregateType<T extends TextPersonalizationAggregateArgs> = {
        [P in keyof T & keyof AggregateTextPersonalization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTextPersonalization[P]>
      : GetScalarType<T[P], AggregateTextPersonalization[P]>
  }




  export type TextPersonalizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextPersonalizationWhereInput
    orderBy?: TextPersonalizationOrderByWithAggregationInput | TextPersonalizationOrderByWithAggregationInput[]
    by: TextPersonalizationScalarFieldEnum[] | TextPersonalizationScalarFieldEnum
    having?: TextPersonalizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TextPersonalizationCountAggregateInputType | true
    _min?: TextPersonalizationMinAggregateInputType
    _max?: TextPersonalizationMaxAggregateInputType
  }

  export type TextPersonalizationGroupByOutputType = {
    id: string
    name: string
    value: string
    cartItemId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TextPersonalizationCountAggregateOutputType | null
    _min: TextPersonalizationMinAggregateOutputType | null
    _max: TextPersonalizationMaxAggregateOutputType | null
  }

  type GetTextPersonalizationGroupByPayload<T extends TextPersonalizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TextPersonalizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TextPersonalizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TextPersonalizationGroupByOutputType[P]>
            : GetScalarType<T[P], TextPersonalizationGroupByOutputType[P]>
        }
      >
    >


  export type TextPersonalizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    cartItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cartItem?: boolean | TextPersonalization$cartItemArgs<ExtArgs>
  }, ExtArgs["result"]["textPersonalization"]>

  export type TextPersonalizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    cartItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cartItem?: boolean | TextPersonalization$cartItemArgs<ExtArgs>
  }, ExtArgs["result"]["textPersonalization"]>

  export type TextPersonalizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    cartItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cartItem?: boolean | TextPersonalization$cartItemArgs<ExtArgs>
  }, ExtArgs["result"]["textPersonalization"]>

  export type TextPersonalizationSelectScalar = {
    id?: boolean
    name?: boolean
    value?: boolean
    cartItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TextPersonalizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "value" | "cartItemId" | "createdAt" | "updatedAt", ExtArgs["result"]["textPersonalization"]>
  export type TextPersonalizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cartItem?: boolean | TextPersonalization$cartItemArgs<ExtArgs>
  }
  export type TextPersonalizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cartItem?: boolean | TextPersonalization$cartItemArgs<ExtArgs>
  }
  export type TextPersonalizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cartItem?: boolean | TextPersonalization$cartItemArgs<ExtArgs>
  }

  export type $TextPersonalizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TextPersonalization"
    objects: {
      cartItem: Prisma.$CartItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      value: string
      cartItemId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["textPersonalization"]>
    composites: {}
  }

  type TextPersonalizationGetPayload<S extends boolean | null | undefined | TextPersonalizationDefaultArgs> = $Result.GetResult<Prisma.$TextPersonalizationPayload, S>

  type TextPersonalizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TextPersonalizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TextPersonalizationCountAggregateInputType | true
    }

  export interface TextPersonalizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TextPersonalization'], meta: { name: 'TextPersonalization' } }
    /**
     * Find zero or one TextPersonalization that matches the filter.
     * @param {TextPersonalizationFindUniqueArgs} args - Arguments to find a TextPersonalization
     * @example
     * // Get one TextPersonalization
     * const textPersonalization = await prisma.textPersonalization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TextPersonalizationFindUniqueArgs>(args: SelectSubset<T, TextPersonalizationFindUniqueArgs<ExtArgs>>): Prisma__TextPersonalizationClient<$Result.GetResult<Prisma.$TextPersonalizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TextPersonalization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TextPersonalizationFindUniqueOrThrowArgs} args - Arguments to find a TextPersonalization
     * @example
     * // Get one TextPersonalization
     * const textPersonalization = await prisma.textPersonalization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TextPersonalizationFindUniqueOrThrowArgs>(args: SelectSubset<T, TextPersonalizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TextPersonalizationClient<$Result.GetResult<Prisma.$TextPersonalizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TextPersonalization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextPersonalizationFindFirstArgs} args - Arguments to find a TextPersonalization
     * @example
     * // Get one TextPersonalization
     * const textPersonalization = await prisma.textPersonalization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TextPersonalizationFindFirstArgs>(args?: SelectSubset<T, TextPersonalizationFindFirstArgs<ExtArgs>>): Prisma__TextPersonalizationClient<$Result.GetResult<Prisma.$TextPersonalizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TextPersonalization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextPersonalizationFindFirstOrThrowArgs} args - Arguments to find a TextPersonalization
     * @example
     * // Get one TextPersonalization
     * const textPersonalization = await prisma.textPersonalization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TextPersonalizationFindFirstOrThrowArgs>(args?: SelectSubset<T, TextPersonalizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TextPersonalizationClient<$Result.GetResult<Prisma.$TextPersonalizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TextPersonalizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextPersonalizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TextPersonalizations
     * const textPersonalizations = await prisma.textPersonalization.findMany()
     * 
     * // Get first 10 TextPersonalizations
     * const textPersonalizations = await prisma.textPersonalization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const textPersonalizationWithIdOnly = await prisma.textPersonalization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TextPersonalizationFindManyArgs>(args?: SelectSubset<T, TextPersonalizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextPersonalizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TextPersonalization.
     * @param {TextPersonalizationCreateArgs} args - Arguments to create a TextPersonalization.
     * @example
     * // Create one TextPersonalization
     * const TextPersonalization = await prisma.textPersonalization.create({
     *   data: {
     *     // ... data to create a TextPersonalization
     *   }
     * })
     * 
     */
    create<T extends TextPersonalizationCreateArgs>(args: SelectSubset<T, TextPersonalizationCreateArgs<ExtArgs>>): Prisma__TextPersonalizationClient<$Result.GetResult<Prisma.$TextPersonalizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TextPersonalizations.
     * @param {TextPersonalizationCreateManyArgs} args - Arguments to create many TextPersonalizations.
     * @example
     * // Create many TextPersonalizations
     * const textPersonalization = await prisma.textPersonalization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TextPersonalizationCreateManyArgs>(args?: SelectSubset<T, TextPersonalizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TextPersonalizations and returns the data saved in the database.
     * @param {TextPersonalizationCreateManyAndReturnArgs} args - Arguments to create many TextPersonalizations.
     * @example
     * // Create many TextPersonalizations
     * const textPersonalization = await prisma.textPersonalization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TextPersonalizations and only return the `id`
     * const textPersonalizationWithIdOnly = await prisma.textPersonalization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TextPersonalizationCreateManyAndReturnArgs>(args?: SelectSubset<T, TextPersonalizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextPersonalizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TextPersonalization.
     * @param {TextPersonalizationDeleteArgs} args - Arguments to delete one TextPersonalization.
     * @example
     * // Delete one TextPersonalization
     * const TextPersonalization = await prisma.textPersonalization.delete({
     *   where: {
     *     // ... filter to delete one TextPersonalization
     *   }
     * })
     * 
     */
    delete<T extends TextPersonalizationDeleteArgs>(args: SelectSubset<T, TextPersonalizationDeleteArgs<ExtArgs>>): Prisma__TextPersonalizationClient<$Result.GetResult<Prisma.$TextPersonalizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TextPersonalization.
     * @param {TextPersonalizationUpdateArgs} args - Arguments to update one TextPersonalization.
     * @example
     * // Update one TextPersonalization
     * const textPersonalization = await prisma.textPersonalization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TextPersonalizationUpdateArgs>(args: SelectSubset<T, TextPersonalizationUpdateArgs<ExtArgs>>): Prisma__TextPersonalizationClient<$Result.GetResult<Prisma.$TextPersonalizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TextPersonalizations.
     * @param {TextPersonalizationDeleteManyArgs} args - Arguments to filter TextPersonalizations to delete.
     * @example
     * // Delete a few TextPersonalizations
     * const { count } = await prisma.textPersonalization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TextPersonalizationDeleteManyArgs>(args?: SelectSubset<T, TextPersonalizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TextPersonalizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextPersonalizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TextPersonalizations
     * const textPersonalization = await prisma.textPersonalization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TextPersonalizationUpdateManyArgs>(args: SelectSubset<T, TextPersonalizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TextPersonalizations and returns the data updated in the database.
     * @param {TextPersonalizationUpdateManyAndReturnArgs} args - Arguments to update many TextPersonalizations.
     * @example
     * // Update many TextPersonalizations
     * const textPersonalization = await prisma.textPersonalization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TextPersonalizations and only return the `id`
     * const textPersonalizationWithIdOnly = await prisma.textPersonalization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TextPersonalizationUpdateManyAndReturnArgs>(args: SelectSubset<T, TextPersonalizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextPersonalizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TextPersonalization.
     * @param {TextPersonalizationUpsertArgs} args - Arguments to update or create a TextPersonalization.
     * @example
     * // Update or create a TextPersonalization
     * const textPersonalization = await prisma.textPersonalization.upsert({
     *   create: {
     *     // ... data to create a TextPersonalization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TextPersonalization we want to update
     *   }
     * })
     */
    upsert<T extends TextPersonalizationUpsertArgs>(args: SelectSubset<T, TextPersonalizationUpsertArgs<ExtArgs>>): Prisma__TextPersonalizationClient<$Result.GetResult<Prisma.$TextPersonalizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TextPersonalizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextPersonalizationCountArgs} args - Arguments to filter TextPersonalizations to count.
     * @example
     * // Count the number of TextPersonalizations
     * const count = await prisma.textPersonalization.count({
     *   where: {
     *     // ... the filter for the TextPersonalizations we want to count
     *   }
     * })
    **/
    count<T extends TextPersonalizationCountArgs>(
      args?: Subset<T, TextPersonalizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TextPersonalizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TextPersonalization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextPersonalizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TextPersonalizationAggregateArgs>(args: Subset<T, TextPersonalizationAggregateArgs>): Prisma.PrismaPromise<GetTextPersonalizationAggregateType<T>>

    /**
     * Group by TextPersonalization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextPersonalizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TextPersonalizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TextPersonalizationGroupByArgs['orderBy'] }
        : { orderBy?: TextPersonalizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TextPersonalizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTextPersonalizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TextPersonalization model
   */
  readonly fields: TextPersonalizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TextPersonalization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TextPersonalizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cartItem<T extends TextPersonalization$cartItemArgs<ExtArgs> = {}>(args?: Subset<T, TextPersonalization$cartItemArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TextPersonalization model
   */
  interface TextPersonalizationFieldRefs {
    readonly id: FieldRef<"TextPersonalization", 'String'>
    readonly name: FieldRef<"TextPersonalization", 'String'>
    readonly value: FieldRef<"TextPersonalization", 'String'>
    readonly cartItemId: FieldRef<"TextPersonalization", 'String'>
    readonly createdAt: FieldRef<"TextPersonalization", 'DateTime'>
    readonly updatedAt: FieldRef<"TextPersonalization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TextPersonalization findUnique
   */
  export type TextPersonalizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalization
     */
    select?: TextPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalization
     */
    omit?: TextPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationInclude<ExtArgs> | null
    /**
     * Filter, which TextPersonalization to fetch.
     */
    where: TextPersonalizationWhereUniqueInput
  }

  /**
   * TextPersonalization findUniqueOrThrow
   */
  export type TextPersonalizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalization
     */
    select?: TextPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalization
     */
    omit?: TextPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationInclude<ExtArgs> | null
    /**
     * Filter, which TextPersonalization to fetch.
     */
    where: TextPersonalizationWhereUniqueInput
  }

  /**
   * TextPersonalization findFirst
   */
  export type TextPersonalizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalization
     */
    select?: TextPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalization
     */
    omit?: TextPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationInclude<ExtArgs> | null
    /**
     * Filter, which TextPersonalization to fetch.
     */
    where?: TextPersonalizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextPersonalizations to fetch.
     */
    orderBy?: TextPersonalizationOrderByWithRelationInput | TextPersonalizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TextPersonalizations.
     */
    cursor?: TextPersonalizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextPersonalizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextPersonalizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TextPersonalizations.
     */
    distinct?: TextPersonalizationScalarFieldEnum | TextPersonalizationScalarFieldEnum[]
  }

  /**
   * TextPersonalization findFirstOrThrow
   */
  export type TextPersonalizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalization
     */
    select?: TextPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalization
     */
    omit?: TextPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationInclude<ExtArgs> | null
    /**
     * Filter, which TextPersonalization to fetch.
     */
    where?: TextPersonalizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextPersonalizations to fetch.
     */
    orderBy?: TextPersonalizationOrderByWithRelationInput | TextPersonalizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TextPersonalizations.
     */
    cursor?: TextPersonalizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextPersonalizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextPersonalizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TextPersonalizations.
     */
    distinct?: TextPersonalizationScalarFieldEnum | TextPersonalizationScalarFieldEnum[]
  }

  /**
   * TextPersonalization findMany
   */
  export type TextPersonalizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalization
     */
    select?: TextPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalization
     */
    omit?: TextPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationInclude<ExtArgs> | null
    /**
     * Filter, which TextPersonalizations to fetch.
     */
    where?: TextPersonalizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextPersonalizations to fetch.
     */
    orderBy?: TextPersonalizationOrderByWithRelationInput | TextPersonalizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TextPersonalizations.
     */
    cursor?: TextPersonalizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextPersonalizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextPersonalizations.
     */
    skip?: number
    distinct?: TextPersonalizationScalarFieldEnum | TextPersonalizationScalarFieldEnum[]
  }

  /**
   * TextPersonalization create
   */
  export type TextPersonalizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalization
     */
    select?: TextPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalization
     */
    omit?: TextPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationInclude<ExtArgs> | null
    /**
     * The data needed to create a TextPersonalization.
     */
    data: XOR<TextPersonalizationCreateInput, TextPersonalizationUncheckedCreateInput>
  }

  /**
   * TextPersonalization createMany
   */
  export type TextPersonalizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TextPersonalizations.
     */
    data: TextPersonalizationCreateManyInput | TextPersonalizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TextPersonalization createManyAndReturn
   */
  export type TextPersonalizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalization
     */
    select?: TextPersonalizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalization
     */
    omit?: TextPersonalizationOmit<ExtArgs> | null
    /**
     * The data used to create many TextPersonalizations.
     */
    data: TextPersonalizationCreateManyInput | TextPersonalizationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TextPersonalization update
   */
  export type TextPersonalizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalization
     */
    select?: TextPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalization
     */
    omit?: TextPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationInclude<ExtArgs> | null
    /**
     * The data needed to update a TextPersonalization.
     */
    data: XOR<TextPersonalizationUpdateInput, TextPersonalizationUncheckedUpdateInput>
    /**
     * Choose, which TextPersonalization to update.
     */
    where: TextPersonalizationWhereUniqueInput
  }

  /**
   * TextPersonalization updateMany
   */
  export type TextPersonalizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TextPersonalizations.
     */
    data: XOR<TextPersonalizationUpdateManyMutationInput, TextPersonalizationUncheckedUpdateManyInput>
    /**
     * Filter which TextPersonalizations to update
     */
    where?: TextPersonalizationWhereInput
    /**
     * Limit how many TextPersonalizations to update.
     */
    limit?: number
  }

  /**
   * TextPersonalization updateManyAndReturn
   */
  export type TextPersonalizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalization
     */
    select?: TextPersonalizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalization
     */
    omit?: TextPersonalizationOmit<ExtArgs> | null
    /**
     * The data used to update TextPersonalizations.
     */
    data: XOR<TextPersonalizationUpdateManyMutationInput, TextPersonalizationUncheckedUpdateManyInput>
    /**
     * Filter which TextPersonalizations to update
     */
    where?: TextPersonalizationWhereInput
    /**
     * Limit how many TextPersonalizations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TextPersonalization upsert
   */
  export type TextPersonalizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalization
     */
    select?: TextPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalization
     */
    omit?: TextPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationInclude<ExtArgs> | null
    /**
     * The filter to search for the TextPersonalization to update in case it exists.
     */
    where: TextPersonalizationWhereUniqueInput
    /**
     * In case the TextPersonalization found by the `where` argument doesn't exist, create a new TextPersonalization with this data.
     */
    create: XOR<TextPersonalizationCreateInput, TextPersonalizationUncheckedCreateInput>
    /**
     * In case the TextPersonalization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TextPersonalizationUpdateInput, TextPersonalizationUncheckedUpdateInput>
  }

  /**
   * TextPersonalization delete
   */
  export type TextPersonalizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalization
     */
    select?: TextPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalization
     */
    omit?: TextPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationInclude<ExtArgs> | null
    /**
     * Filter which TextPersonalization to delete.
     */
    where: TextPersonalizationWhereUniqueInput
  }

  /**
   * TextPersonalization deleteMany
   */
  export type TextPersonalizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TextPersonalizations to delete
     */
    where?: TextPersonalizationWhereInput
    /**
     * Limit how many TextPersonalizations to delete.
     */
    limit?: number
  }

  /**
   * TextPersonalization.cartItem
   */
  export type TextPersonalization$cartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
  }

  /**
   * TextPersonalization without action
   */
  export type TextPersonalizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextPersonalization
     */
    select?: TextPersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextPersonalization
     */
    omit?: TextPersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextPersonalizationInclude<ExtArgs> | null
  }


  /**
   * Model ImagePersonalization
   */

  export type AggregateImagePersonalization = {
    _count: ImagePersonalizationCountAggregateOutputType | null
    _min: ImagePersonalizationMinAggregateOutputType | null
    _max: ImagePersonalizationMaxAggregateOutputType | null
  }

  export type ImagePersonalizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    cartItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImagePersonalizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    cartItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImagePersonalizationCountAggregateOutputType = {
    id: number
    name: number
    cartItemId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImagePersonalizationMinAggregateInputType = {
    id?: true
    name?: true
    cartItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImagePersonalizationMaxAggregateInputType = {
    id?: true
    name?: true
    cartItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImagePersonalizationCountAggregateInputType = {
    id?: true
    name?: true
    cartItemId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImagePersonalizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImagePersonalization to aggregate.
     */
    where?: ImagePersonalizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImagePersonalizations to fetch.
     */
    orderBy?: ImagePersonalizationOrderByWithRelationInput | ImagePersonalizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImagePersonalizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImagePersonalizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImagePersonalizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImagePersonalizations
    **/
    _count?: true | ImagePersonalizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImagePersonalizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImagePersonalizationMaxAggregateInputType
  }

  export type GetImagePersonalizationAggregateType<T extends ImagePersonalizationAggregateArgs> = {
        [P in keyof T & keyof AggregateImagePersonalization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImagePersonalization[P]>
      : GetScalarType<T[P], AggregateImagePersonalization[P]>
  }




  export type ImagePersonalizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImagePersonalizationWhereInput
    orderBy?: ImagePersonalizationOrderByWithAggregationInput | ImagePersonalizationOrderByWithAggregationInput[]
    by: ImagePersonalizationScalarFieldEnum[] | ImagePersonalizationScalarFieldEnum
    having?: ImagePersonalizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImagePersonalizationCountAggregateInputType | true
    _min?: ImagePersonalizationMinAggregateInputType
    _max?: ImagePersonalizationMaxAggregateInputType
  }

  export type ImagePersonalizationGroupByOutputType = {
    id: string
    name: string
    cartItemId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ImagePersonalizationCountAggregateOutputType | null
    _min: ImagePersonalizationMinAggregateOutputType | null
    _max: ImagePersonalizationMaxAggregateOutputType | null
  }

  type GetImagePersonalizationGroupByPayload<T extends ImagePersonalizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImagePersonalizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImagePersonalizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImagePersonalizationGroupByOutputType[P]>
            : GetScalarType<T[P], ImagePersonalizationGroupByOutputType[P]>
        }
      >
    >


  export type ImagePersonalizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cartItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    images?: boolean | ImagePersonalization$imagesArgs<ExtArgs>
    cartItem?: boolean | ImagePersonalization$cartItemArgs<ExtArgs>
    _count?: boolean | ImagePersonalizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imagePersonalization"]>

  export type ImagePersonalizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cartItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cartItem?: boolean | ImagePersonalization$cartItemArgs<ExtArgs>
  }, ExtArgs["result"]["imagePersonalization"]>

  export type ImagePersonalizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cartItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cartItem?: boolean | ImagePersonalization$cartItemArgs<ExtArgs>
  }, ExtArgs["result"]["imagePersonalization"]>

  export type ImagePersonalizationSelectScalar = {
    id?: boolean
    name?: boolean
    cartItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ImagePersonalizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "cartItemId" | "createdAt" | "updatedAt", ExtArgs["result"]["imagePersonalization"]>
  export type ImagePersonalizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | ImagePersonalization$imagesArgs<ExtArgs>
    cartItem?: boolean | ImagePersonalization$cartItemArgs<ExtArgs>
    _count?: boolean | ImagePersonalizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ImagePersonalizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cartItem?: boolean | ImagePersonalization$cartItemArgs<ExtArgs>
  }
  export type ImagePersonalizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cartItem?: boolean | ImagePersonalization$cartItemArgs<ExtArgs>
  }

  export type $ImagePersonalizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImagePersonalization"
    objects: {
      images: Prisma.$MediaPayload<ExtArgs>[]
      cartItem: Prisma.$CartItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      cartItemId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["imagePersonalization"]>
    composites: {}
  }

  type ImagePersonalizationGetPayload<S extends boolean | null | undefined | ImagePersonalizationDefaultArgs> = $Result.GetResult<Prisma.$ImagePersonalizationPayload, S>

  type ImagePersonalizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImagePersonalizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImagePersonalizationCountAggregateInputType | true
    }

  export interface ImagePersonalizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImagePersonalization'], meta: { name: 'ImagePersonalization' } }
    /**
     * Find zero or one ImagePersonalization that matches the filter.
     * @param {ImagePersonalizationFindUniqueArgs} args - Arguments to find a ImagePersonalization
     * @example
     * // Get one ImagePersonalization
     * const imagePersonalization = await prisma.imagePersonalization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImagePersonalizationFindUniqueArgs>(args: SelectSubset<T, ImagePersonalizationFindUniqueArgs<ExtArgs>>): Prisma__ImagePersonalizationClient<$Result.GetResult<Prisma.$ImagePersonalizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImagePersonalization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImagePersonalizationFindUniqueOrThrowArgs} args - Arguments to find a ImagePersonalization
     * @example
     * // Get one ImagePersonalization
     * const imagePersonalization = await prisma.imagePersonalization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImagePersonalizationFindUniqueOrThrowArgs>(args: SelectSubset<T, ImagePersonalizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImagePersonalizationClient<$Result.GetResult<Prisma.$ImagePersonalizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImagePersonalization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagePersonalizationFindFirstArgs} args - Arguments to find a ImagePersonalization
     * @example
     * // Get one ImagePersonalization
     * const imagePersonalization = await prisma.imagePersonalization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImagePersonalizationFindFirstArgs>(args?: SelectSubset<T, ImagePersonalizationFindFirstArgs<ExtArgs>>): Prisma__ImagePersonalizationClient<$Result.GetResult<Prisma.$ImagePersonalizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImagePersonalization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagePersonalizationFindFirstOrThrowArgs} args - Arguments to find a ImagePersonalization
     * @example
     * // Get one ImagePersonalization
     * const imagePersonalization = await prisma.imagePersonalization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImagePersonalizationFindFirstOrThrowArgs>(args?: SelectSubset<T, ImagePersonalizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImagePersonalizationClient<$Result.GetResult<Prisma.$ImagePersonalizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImagePersonalizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagePersonalizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImagePersonalizations
     * const imagePersonalizations = await prisma.imagePersonalization.findMany()
     * 
     * // Get first 10 ImagePersonalizations
     * const imagePersonalizations = await prisma.imagePersonalization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imagePersonalizationWithIdOnly = await prisma.imagePersonalization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImagePersonalizationFindManyArgs>(args?: SelectSubset<T, ImagePersonalizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePersonalizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImagePersonalization.
     * @param {ImagePersonalizationCreateArgs} args - Arguments to create a ImagePersonalization.
     * @example
     * // Create one ImagePersonalization
     * const ImagePersonalization = await prisma.imagePersonalization.create({
     *   data: {
     *     // ... data to create a ImagePersonalization
     *   }
     * })
     * 
     */
    create<T extends ImagePersonalizationCreateArgs>(args: SelectSubset<T, ImagePersonalizationCreateArgs<ExtArgs>>): Prisma__ImagePersonalizationClient<$Result.GetResult<Prisma.$ImagePersonalizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImagePersonalizations.
     * @param {ImagePersonalizationCreateManyArgs} args - Arguments to create many ImagePersonalizations.
     * @example
     * // Create many ImagePersonalizations
     * const imagePersonalization = await prisma.imagePersonalization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImagePersonalizationCreateManyArgs>(args?: SelectSubset<T, ImagePersonalizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImagePersonalizations and returns the data saved in the database.
     * @param {ImagePersonalizationCreateManyAndReturnArgs} args - Arguments to create many ImagePersonalizations.
     * @example
     * // Create many ImagePersonalizations
     * const imagePersonalization = await prisma.imagePersonalization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImagePersonalizations and only return the `id`
     * const imagePersonalizationWithIdOnly = await prisma.imagePersonalization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImagePersonalizationCreateManyAndReturnArgs>(args?: SelectSubset<T, ImagePersonalizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePersonalizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ImagePersonalization.
     * @param {ImagePersonalizationDeleteArgs} args - Arguments to delete one ImagePersonalization.
     * @example
     * // Delete one ImagePersonalization
     * const ImagePersonalization = await prisma.imagePersonalization.delete({
     *   where: {
     *     // ... filter to delete one ImagePersonalization
     *   }
     * })
     * 
     */
    delete<T extends ImagePersonalizationDeleteArgs>(args: SelectSubset<T, ImagePersonalizationDeleteArgs<ExtArgs>>): Prisma__ImagePersonalizationClient<$Result.GetResult<Prisma.$ImagePersonalizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImagePersonalization.
     * @param {ImagePersonalizationUpdateArgs} args - Arguments to update one ImagePersonalization.
     * @example
     * // Update one ImagePersonalization
     * const imagePersonalization = await prisma.imagePersonalization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImagePersonalizationUpdateArgs>(args: SelectSubset<T, ImagePersonalizationUpdateArgs<ExtArgs>>): Prisma__ImagePersonalizationClient<$Result.GetResult<Prisma.$ImagePersonalizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImagePersonalizations.
     * @param {ImagePersonalizationDeleteManyArgs} args - Arguments to filter ImagePersonalizations to delete.
     * @example
     * // Delete a few ImagePersonalizations
     * const { count } = await prisma.imagePersonalization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImagePersonalizationDeleteManyArgs>(args?: SelectSubset<T, ImagePersonalizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImagePersonalizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagePersonalizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImagePersonalizations
     * const imagePersonalization = await prisma.imagePersonalization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImagePersonalizationUpdateManyArgs>(args: SelectSubset<T, ImagePersonalizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImagePersonalizations and returns the data updated in the database.
     * @param {ImagePersonalizationUpdateManyAndReturnArgs} args - Arguments to update many ImagePersonalizations.
     * @example
     * // Update many ImagePersonalizations
     * const imagePersonalization = await prisma.imagePersonalization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ImagePersonalizations and only return the `id`
     * const imagePersonalizationWithIdOnly = await prisma.imagePersonalization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImagePersonalizationUpdateManyAndReturnArgs>(args: SelectSubset<T, ImagePersonalizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePersonalizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ImagePersonalization.
     * @param {ImagePersonalizationUpsertArgs} args - Arguments to update or create a ImagePersonalization.
     * @example
     * // Update or create a ImagePersonalization
     * const imagePersonalization = await prisma.imagePersonalization.upsert({
     *   create: {
     *     // ... data to create a ImagePersonalization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImagePersonalization we want to update
     *   }
     * })
     */
    upsert<T extends ImagePersonalizationUpsertArgs>(args: SelectSubset<T, ImagePersonalizationUpsertArgs<ExtArgs>>): Prisma__ImagePersonalizationClient<$Result.GetResult<Prisma.$ImagePersonalizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ImagePersonalizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagePersonalizationCountArgs} args - Arguments to filter ImagePersonalizations to count.
     * @example
     * // Count the number of ImagePersonalizations
     * const count = await prisma.imagePersonalization.count({
     *   where: {
     *     // ... the filter for the ImagePersonalizations we want to count
     *   }
     * })
    **/
    count<T extends ImagePersonalizationCountArgs>(
      args?: Subset<T, ImagePersonalizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImagePersonalizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImagePersonalization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagePersonalizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImagePersonalizationAggregateArgs>(args: Subset<T, ImagePersonalizationAggregateArgs>): Prisma.PrismaPromise<GetImagePersonalizationAggregateType<T>>

    /**
     * Group by ImagePersonalization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagePersonalizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImagePersonalizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImagePersonalizationGroupByArgs['orderBy'] }
        : { orderBy?: ImagePersonalizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImagePersonalizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImagePersonalizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImagePersonalization model
   */
  readonly fields: ImagePersonalizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImagePersonalization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImagePersonalizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends ImagePersonalization$imagesArgs<ExtArgs> = {}>(args?: Subset<T, ImagePersonalization$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cartItem<T extends ImagePersonalization$cartItemArgs<ExtArgs> = {}>(args?: Subset<T, ImagePersonalization$cartItemArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImagePersonalization model
   */
  interface ImagePersonalizationFieldRefs {
    readonly id: FieldRef<"ImagePersonalization", 'String'>
    readonly name: FieldRef<"ImagePersonalization", 'String'>
    readonly cartItemId: FieldRef<"ImagePersonalization", 'String'>
    readonly createdAt: FieldRef<"ImagePersonalization", 'DateTime'>
    readonly updatedAt: FieldRef<"ImagePersonalization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ImagePersonalization findUnique
   */
  export type ImagePersonalizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalization
     */
    select?: ImagePersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalization
     */
    omit?: ImagePersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationInclude<ExtArgs> | null
    /**
     * Filter, which ImagePersonalization to fetch.
     */
    where: ImagePersonalizationWhereUniqueInput
  }

  /**
   * ImagePersonalization findUniqueOrThrow
   */
  export type ImagePersonalizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalization
     */
    select?: ImagePersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalization
     */
    omit?: ImagePersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationInclude<ExtArgs> | null
    /**
     * Filter, which ImagePersonalization to fetch.
     */
    where: ImagePersonalizationWhereUniqueInput
  }

  /**
   * ImagePersonalization findFirst
   */
  export type ImagePersonalizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalization
     */
    select?: ImagePersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalization
     */
    omit?: ImagePersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationInclude<ExtArgs> | null
    /**
     * Filter, which ImagePersonalization to fetch.
     */
    where?: ImagePersonalizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImagePersonalizations to fetch.
     */
    orderBy?: ImagePersonalizationOrderByWithRelationInput | ImagePersonalizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImagePersonalizations.
     */
    cursor?: ImagePersonalizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImagePersonalizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImagePersonalizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImagePersonalizations.
     */
    distinct?: ImagePersonalizationScalarFieldEnum | ImagePersonalizationScalarFieldEnum[]
  }

  /**
   * ImagePersonalization findFirstOrThrow
   */
  export type ImagePersonalizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalization
     */
    select?: ImagePersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalization
     */
    omit?: ImagePersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationInclude<ExtArgs> | null
    /**
     * Filter, which ImagePersonalization to fetch.
     */
    where?: ImagePersonalizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImagePersonalizations to fetch.
     */
    orderBy?: ImagePersonalizationOrderByWithRelationInput | ImagePersonalizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImagePersonalizations.
     */
    cursor?: ImagePersonalizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImagePersonalizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImagePersonalizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImagePersonalizations.
     */
    distinct?: ImagePersonalizationScalarFieldEnum | ImagePersonalizationScalarFieldEnum[]
  }

  /**
   * ImagePersonalization findMany
   */
  export type ImagePersonalizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalization
     */
    select?: ImagePersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalization
     */
    omit?: ImagePersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationInclude<ExtArgs> | null
    /**
     * Filter, which ImagePersonalizations to fetch.
     */
    where?: ImagePersonalizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImagePersonalizations to fetch.
     */
    orderBy?: ImagePersonalizationOrderByWithRelationInput | ImagePersonalizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImagePersonalizations.
     */
    cursor?: ImagePersonalizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImagePersonalizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImagePersonalizations.
     */
    skip?: number
    distinct?: ImagePersonalizationScalarFieldEnum | ImagePersonalizationScalarFieldEnum[]
  }

  /**
   * ImagePersonalization create
   */
  export type ImagePersonalizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalization
     */
    select?: ImagePersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalization
     */
    omit?: ImagePersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationInclude<ExtArgs> | null
    /**
     * The data needed to create a ImagePersonalization.
     */
    data: XOR<ImagePersonalizationCreateInput, ImagePersonalizationUncheckedCreateInput>
  }

  /**
   * ImagePersonalization createMany
   */
  export type ImagePersonalizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImagePersonalizations.
     */
    data: ImagePersonalizationCreateManyInput | ImagePersonalizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImagePersonalization createManyAndReturn
   */
  export type ImagePersonalizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalization
     */
    select?: ImagePersonalizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalization
     */
    omit?: ImagePersonalizationOmit<ExtArgs> | null
    /**
     * The data used to create many ImagePersonalizations.
     */
    data: ImagePersonalizationCreateManyInput | ImagePersonalizationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImagePersonalization update
   */
  export type ImagePersonalizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalization
     */
    select?: ImagePersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalization
     */
    omit?: ImagePersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationInclude<ExtArgs> | null
    /**
     * The data needed to update a ImagePersonalization.
     */
    data: XOR<ImagePersonalizationUpdateInput, ImagePersonalizationUncheckedUpdateInput>
    /**
     * Choose, which ImagePersonalization to update.
     */
    where: ImagePersonalizationWhereUniqueInput
  }

  /**
   * ImagePersonalization updateMany
   */
  export type ImagePersonalizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImagePersonalizations.
     */
    data: XOR<ImagePersonalizationUpdateManyMutationInput, ImagePersonalizationUncheckedUpdateManyInput>
    /**
     * Filter which ImagePersonalizations to update
     */
    where?: ImagePersonalizationWhereInput
    /**
     * Limit how many ImagePersonalizations to update.
     */
    limit?: number
  }

  /**
   * ImagePersonalization updateManyAndReturn
   */
  export type ImagePersonalizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalization
     */
    select?: ImagePersonalizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalization
     */
    omit?: ImagePersonalizationOmit<ExtArgs> | null
    /**
     * The data used to update ImagePersonalizations.
     */
    data: XOR<ImagePersonalizationUpdateManyMutationInput, ImagePersonalizationUncheckedUpdateManyInput>
    /**
     * Filter which ImagePersonalizations to update
     */
    where?: ImagePersonalizationWhereInput
    /**
     * Limit how many ImagePersonalizations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImagePersonalization upsert
   */
  export type ImagePersonalizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalization
     */
    select?: ImagePersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalization
     */
    omit?: ImagePersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationInclude<ExtArgs> | null
    /**
     * The filter to search for the ImagePersonalization to update in case it exists.
     */
    where: ImagePersonalizationWhereUniqueInput
    /**
     * In case the ImagePersonalization found by the `where` argument doesn't exist, create a new ImagePersonalization with this data.
     */
    create: XOR<ImagePersonalizationCreateInput, ImagePersonalizationUncheckedCreateInput>
    /**
     * In case the ImagePersonalization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImagePersonalizationUpdateInput, ImagePersonalizationUncheckedUpdateInput>
  }

  /**
   * ImagePersonalization delete
   */
  export type ImagePersonalizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalization
     */
    select?: ImagePersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalization
     */
    omit?: ImagePersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationInclude<ExtArgs> | null
    /**
     * Filter which ImagePersonalization to delete.
     */
    where: ImagePersonalizationWhereUniqueInput
  }

  /**
   * ImagePersonalization deleteMany
   */
  export type ImagePersonalizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImagePersonalizations to delete
     */
    where?: ImagePersonalizationWhereInput
    /**
     * Limit how many ImagePersonalizations to delete.
     */
    limit?: number
  }

  /**
   * ImagePersonalization.images
   */
  export type ImagePersonalization$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * ImagePersonalization.cartItem
   */
  export type ImagePersonalization$cartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
  }

  /**
   * ImagePersonalization without action
   */
  export type ImagePersonalizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagePersonalization
     */
    select?: ImagePersonalizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagePersonalization
     */
    omit?: ImagePersonalizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagePersonalizationInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryAddress
   */

  export type AggregateDeliveryAddress = {
    _count: DeliveryAddressCountAggregateOutputType | null
    _min: DeliveryAddressMinAggregateOutputType | null
    _max: DeliveryAddressMaxAggregateOutputType | null
  }

  export type DeliveryAddressMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    zip: string | null
    phone: string | null
    email: string | null
    note: string | null
    type: $Enums.DeliveryAddressType | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryAddressMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    zip: string | null
    phone: string | null
    email: string | null
    note: string | null
    type: $Enums.DeliveryAddressType | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryAddressCountAggregateOutputType = {
    id: number
    name: number
    address: number
    city: number
    zip: number
    phone: number
    email: number
    note: number
    type: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeliveryAddressMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    zip?: true
    phone?: true
    email?: true
    note?: true
    type?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryAddressMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    zip?: true
    phone?: true
    email?: true
    note?: true
    type?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryAddressCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    zip?: true
    phone?: true
    email?: true
    note?: true
    type?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeliveryAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryAddress to aggregate.
     */
    where?: DeliveryAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryAddresses to fetch.
     */
    orderBy?: DeliveryAddressOrderByWithRelationInput | DeliveryAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryAddresses
    **/
    _count?: true | DeliveryAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryAddressMaxAggregateInputType
  }

  export type GetDeliveryAddressAggregateType<T extends DeliveryAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryAddress[P]>
      : GetScalarType<T[P], AggregateDeliveryAddress[P]>
  }




  export type DeliveryAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryAddressWhereInput
    orderBy?: DeliveryAddressOrderByWithAggregationInput | DeliveryAddressOrderByWithAggregationInput[]
    by: DeliveryAddressScalarFieldEnum[] | DeliveryAddressScalarFieldEnum
    having?: DeliveryAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryAddressCountAggregateInputType | true
    _min?: DeliveryAddressMinAggregateInputType
    _max?: DeliveryAddressMaxAggregateInputType
  }

  export type DeliveryAddressGroupByOutputType = {
    id: string
    name: string
    address: string
    city: string
    zip: string
    phone: string
    email: string
    note: string | null
    type: $Enums.DeliveryAddressType
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: DeliveryAddressCountAggregateOutputType | null
    _min: DeliveryAddressMinAggregateOutputType | null
    _max: DeliveryAddressMaxAggregateOutputType | null
  }

  type GetDeliveryAddressGroupByPayload<T extends DeliveryAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryAddressGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryAddressGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    zip?: boolean
    phone?: boolean
    email?: boolean
    note?: boolean
    type?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryAddress"]>

  export type DeliveryAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    zip?: boolean
    phone?: boolean
    email?: boolean
    note?: boolean
    type?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryAddress"]>

  export type DeliveryAddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    zip?: boolean
    phone?: boolean
    email?: boolean
    note?: boolean
    type?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryAddress"]>

  export type DeliveryAddressSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    zip?: boolean
    phone?: boolean
    email?: boolean
    note?: boolean
    type?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeliveryAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "city" | "zip" | "phone" | "email" | "note" | "type" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["deliveryAddress"]>
  export type DeliveryAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeliveryAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeliveryAddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeliveryAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryAddress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      city: string
      zip: string
      phone: string
      email: string
      note: string | null
      type: $Enums.DeliveryAddressType
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deliveryAddress"]>
    composites: {}
  }

  type DeliveryAddressGetPayload<S extends boolean | null | undefined | DeliveryAddressDefaultArgs> = $Result.GetResult<Prisma.$DeliveryAddressPayload, S>

  type DeliveryAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryAddressCountAggregateInputType | true
    }

  export interface DeliveryAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryAddress'], meta: { name: 'DeliveryAddress' } }
    /**
     * Find zero or one DeliveryAddress that matches the filter.
     * @param {DeliveryAddressFindUniqueArgs} args - Arguments to find a DeliveryAddress
     * @example
     * // Get one DeliveryAddress
     * const deliveryAddress = await prisma.deliveryAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryAddressFindUniqueArgs>(args: SelectSubset<T, DeliveryAddressFindUniqueArgs<ExtArgs>>): Prisma__DeliveryAddressClient<$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryAddressFindUniqueOrThrowArgs} args - Arguments to find a DeliveryAddress
     * @example
     * // Get one DeliveryAddress
     * const deliveryAddress = await prisma.deliveryAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryAddressClient<$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAddressFindFirstArgs} args - Arguments to find a DeliveryAddress
     * @example
     * // Get one DeliveryAddress
     * const deliveryAddress = await prisma.deliveryAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryAddressFindFirstArgs>(args?: SelectSubset<T, DeliveryAddressFindFirstArgs<ExtArgs>>): Prisma__DeliveryAddressClient<$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAddressFindFirstOrThrowArgs} args - Arguments to find a DeliveryAddress
     * @example
     * // Get one DeliveryAddress
     * const deliveryAddress = await prisma.deliveryAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryAddressClient<$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryAddresses
     * const deliveryAddresses = await prisma.deliveryAddress.findMany()
     * 
     * // Get first 10 DeliveryAddresses
     * const deliveryAddresses = await prisma.deliveryAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryAddressWithIdOnly = await prisma.deliveryAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryAddressFindManyArgs>(args?: SelectSubset<T, DeliveryAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryAddress.
     * @param {DeliveryAddressCreateArgs} args - Arguments to create a DeliveryAddress.
     * @example
     * // Create one DeliveryAddress
     * const DeliveryAddress = await prisma.deliveryAddress.create({
     *   data: {
     *     // ... data to create a DeliveryAddress
     *   }
     * })
     * 
     */
    create<T extends DeliveryAddressCreateArgs>(args: SelectSubset<T, DeliveryAddressCreateArgs<ExtArgs>>): Prisma__DeliveryAddressClient<$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryAddresses.
     * @param {DeliveryAddressCreateManyArgs} args - Arguments to create many DeliveryAddresses.
     * @example
     * // Create many DeliveryAddresses
     * const deliveryAddress = await prisma.deliveryAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryAddressCreateManyArgs>(args?: SelectSubset<T, DeliveryAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryAddresses and returns the data saved in the database.
     * @param {DeliveryAddressCreateManyAndReturnArgs} args - Arguments to create many DeliveryAddresses.
     * @example
     * // Create many DeliveryAddresses
     * const deliveryAddress = await prisma.deliveryAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryAddresses and only return the `id`
     * const deliveryAddressWithIdOnly = await prisma.deliveryAddress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryAddress.
     * @param {DeliveryAddressDeleteArgs} args - Arguments to delete one DeliveryAddress.
     * @example
     * // Delete one DeliveryAddress
     * const DeliveryAddress = await prisma.deliveryAddress.delete({
     *   where: {
     *     // ... filter to delete one DeliveryAddress
     *   }
     * })
     * 
     */
    delete<T extends DeliveryAddressDeleteArgs>(args: SelectSubset<T, DeliveryAddressDeleteArgs<ExtArgs>>): Prisma__DeliveryAddressClient<$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryAddress.
     * @param {DeliveryAddressUpdateArgs} args - Arguments to update one DeliveryAddress.
     * @example
     * // Update one DeliveryAddress
     * const deliveryAddress = await prisma.deliveryAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryAddressUpdateArgs>(args: SelectSubset<T, DeliveryAddressUpdateArgs<ExtArgs>>): Prisma__DeliveryAddressClient<$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryAddresses.
     * @param {DeliveryAddressDeleteManyArgs} args - Arguments to filter DeliveryAddresses to delete.
     * @example
     * // Delete a few DeliveryAddresses
     * const { count } = await prisma.deliveryAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryAddressDeleteManyArgs>(args?: SelectSubset<T, DeliveryAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryAddresses
     * const deliveryAddress = await prisma.deliveryAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryAddressUpdateManyArgs>(args: SelectSubset<T, DeliveryAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryAddresses and returns the data updated in the database.
     * @param {DeliveryAddressUpdateManyAndReturnArgs} args - Arguments to update many DeliveryAddresses.
     * @example
     * // Update many DeliveryAddresses
     * const deliveryAddress = await prisma.deliveryAddress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryAddresses and only return the `id`
     * const deliveryAddressWithIdOnly = await prisma.deliveryAddress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryAddressUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryAddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryAddress.
     * @param {DeliveryAddressUpsertArgs} args - Arguments to update or create a DeliveryAddress.
     * @example
     * // Update or create a DeliveryAddress
     * const deliveryAddress = await prisma.deliveryAddress.upsert({
     *   create: {
     *     // ... data to create a DeliveryAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryAddress we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryAddressUpsertArgs>(args: SelectSubset<T, DeliveryAddressUpsertArgs<ExtArgs>>): Prisma__DeliveryAddressClient<$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAddressCountArgs} args - Arguments to filter DeliveryAddresses to count.
     * @example
     * // Count the number of DeliveryAddresses
     * const count = await prisma.deliveryAddress.count({
     *   where: {
     *     // ... the filter for the DeliveryAddresses we want to count
     *   }
     * })
    **/
    count<T extends DeliveryAddressCountArgs>(
      args?: Subset<T, DeliveryAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryAddressAggregateArgs>(args: Subset<T, DeliveryAddressAggregateArgs>): Prisma.PrismaPromise<GetDeliveryAddressAggregateType<T>>

    /**
     * Group by DeliveryAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryAddressGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryAddress model
   */
  readonly fields: DeliveryAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryAddress model
   */
  interface DeliveryAddressFieldRefs {
    readonly id: FieldRef<"DeliveryAddress", 'String'>
    readonly name: FieldRef<"DeliveryAddress", 'String'>
    readonly address: FieldRef<"DeliveryAddress", 'String'>
    readonly city: FieldRef<"DeliveryAddress", 'String'>
    readonly zip: FieldRef<"DeliveryAddress", 'String'>
    readonly phone: FieldRef<"DeliveryAddress", 'String'>
    readonly email: FieldRef<"DeliveryAddress", 'String'>
    readonly note: FieldRef<"DeliveryAddress", 'String'>
    readonly type: FieldRef<"DeliveryAddress", 'DeliveryAddressType'>
    readonly userId: FieldRef<"DeliveryAddress", 'String'>
    readonly createdAt: FieldRef<"DeliveryAddress", 'DateTime'>
    readonly updatedAt: FieldRef<"DeliveryAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryAddress findUnique
   */
  export type DeliveryAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAddress
     */
    omit?: DeliveryAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAddressInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryAddress to fetch.
     */
    where: DeliveryAddressWhereUniqueInput
  }

  /**
   * DeliveryAddress findUniqueOrThrow
   */
  export type DeliveryAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAddress
     */
    omit?: DeliveryAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAddressInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryAddress to fetch.
     */
    where: DeliveryAddressWhereUniqueInput
  }

  /**
   * DeliveryAddress findFirst
   */
  export type DeliveryAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAddress
     */
    omit?: DeliveryAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAddressInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryAddress to fetch.
     */
    where?: DeliveryAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryAddresses to fetch.
     */
    orderBy?: DeliveryAddressOrderByWithRelationInput | DeliveryAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryAddresses.
     */
    cursor?: DeliveryAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryAddresses.
     */
    distinct?: DeliveryAddressScalarFieldEnum | DeliveryAddressScalarFieldEnum[]
  }

  /**
   * DeliveryAddress findFirstOrThrow
   */
  export type DeliveryAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAddress
     */
    omit?: DeliveryAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAddressInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryAddress to fetch.
     */
    where?: DeliveryAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryAddresses to fetch.
     */
    orderBy?: DeliveryAddressOrderByWithRelationInput | DeliveryAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryAddresses.
     */
    cursor?: DeliveryAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryAddresses.
     */
    distinct?: DeliveryAddressScalarFieldEnum | DeliveryAddressScalarFieldEnum[]
  }

  /**
   * DeliveryAddress findMany
   */
  export type DeliveryAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAddress
     */
    omit?: DeliveryAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAddressInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryAddresses to fetch.
     */
    where?: DeliveryAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryAddresses to fetch.
     */
    orderBy?: DeliveryAddressOrderByWithRelationInput | DeliveryAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryAddresses.
     */
    cursor?: DeliveryAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryAddresses.
     */
    skip?: number
    distinct?: DeliveryAddressScalarFieldEnum | DeliveryAddressScalarFieldEnum[]
  }

  /**
   * DeliveryAddress create
   */
  export type DeliveryAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAddress
     */
    omit?: DeliveryAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryAddress.
     */
    data: XOR<DeliveryAddressCreateInput, DeliveryAddressUncheckedCreateInput>
  }

  /**
   * DeliveryAddress createMany
   */
  export type DeliveryAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryAddresses.
     */
    data: DeliveryAddressCreateManyInput | DeliveryAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryAddress createManyAndReturn
   */
  export type DeliveryAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAddress
     */
    omit?: DeliveryAddressOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryAddresses.
     */
    data: DeliveryAddressCreateManyInput | DeliveryAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryAddress update
   */
  export type DeliveryAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAddress
     */
    omit?: DeliveryAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryAddress.
     */
    data: XOR<DeliveryAddressUpdateInput, DeliveryAddressUncheckedUpdateInput>
    /**
     * Choose, which DeliveryAddress to update.
     */
    where: DeliveryAddressWhereUniqueInput
  }

  /**
   * DeliveryAddress updateMany
   */
  export type DeliveryAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryAddresses.
     */
    data: XOR<DeliveryAddressUpdateManyMutationInput, DeliveryAddressUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryAddresses to update
     */
    where?: DeliveryAddressWhereInput
    /**
     * Limit how many DeliveryAddresses to update.
     */
    limit?: number
  }

  /**
   * DeliveryAddress updateManyAndReturn
   */
  export type DeliveryAddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAddress
     */
    omit?: DeliveryAddressOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryAddresses.
     */
    data: XOR<DeliveryAddressUpdateManyMutationInput, DeliveryAddressUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryAddresses to update
     */
    where?: DeliveryAddressWhereInput
    /**
     * Limit how many DeliveryAddresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryAddress upsert
   */
  export type DeliveryAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAddress
     */
    omit?: DeliveryAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryAddress to update in case it exists.
     */
    where: DeliveryAddressWhereUniqueInput
    /**
     * In case the DeliveryAddress found by the `where` argument doesn't exist, create a new DeliveryAddress with this data.
     */
    create: XOR<DeliveryAddressCreateInput, DeliveryAddressUncheckedCreateInput>
    /**
     * In case the DeliveryAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryAddressUpdateInput, DeliveryAddressUncheckedUpdateInput>
  }

  /**
   * DeliveryAddress delete
   */
  export type DeliveryAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAddress
     */
    omit?: DeliveryAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAddressInclude<ExtArgs> | null
    /**
     * Filter which DeliveryAddress to delete.
     */
    where: DeliveryAddressWhereUniqueInput
  }

  /**
   * DeliveryAddress deleteMany
   */
  export type DeliveryAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryAddresses to delete
     */
    where?: DeliveryAddressWhereInput
    /**
     * Limit how many DeliveryAddresses to delete.
     */
    limit?: number
  }

  /**
   * DeliveryAddress without action
   */
  export type DeliveryAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAddress
     */
    omit?: DeliveryAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAddressInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    orderOnlinePrice: number | null
    orderDiscount: number | null
    orderDeliveryFee: number | null
    orderTotalPrice: number | null
  }

  export type OrderSumAggregateOutputType = {
    orderOnlinePrice: number | null
    orderDiscount: number | null
    orderDeliveryFee: number | null
    orderTotalPrice: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    termsAccepted: boolean | null
    shippingNumber: string | null
    deliveryType: $Enums.OrderDeliveryType | null
    paymentType: $Enums.OrderPaymentType | null
    status: $Enums.OrderStatusType | null
    mediaRemoved: boolean | null
    paymentId: string | null
    paymentStatus: $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode: string | null
    paymentStatusCode: string | null
    paymentTimestamp: string | null
    paymentAmount: string | null
    paymentCurrency: string | null
    paymentBrand: string | null
    checkoutId: string | null
    deliveryName: string | null
    deliveryAddress: string | null
    deliveryCity: string | null
    deliveryZip: string | null
    deliveryPhone: string | null
    deliveryEmail: string | null
    deliveryNote: string | null
    pickupName: string | null
    pickupPhone: string | null
    pickupEmail: string | null
    billingName: string | null
    billingAddress: string | null
    billingCity: string | null
    billingZip: string | null
    billingPhone: string | null
    billingEmail: string | null
    billingNote: string | null
    deliveryServiceName: string | null
    orderOnlinePrice: number | null
    orderDiscount: number | null
    orderDeliveryFee: number | null
    orderTotalPrice: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    termsAccepted: boolean | null
    shippingNumber: string | null
    deliveryType: $Enums.OrderDeliveryType | null
    paymentType: $Enums.OrderPaymentType | null
    status: $Enums.OrderStatusType | null
    mediaRemoved: boolean | null
    paymentId: string | null
    paymentStatus: $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode: string | null
    paymentStatusCode: string | null
    paymentTimestamp: string | null
    paymentAmount: string | null
    paymentCurrency: string | null
    paymentBrand: string | null
    checkoutId: string | null
    deliveryName: string | null
    deliveryAddress: string | null
    deliveryCity: string | null
    deliveryZip: string | null
    deliveryPhone: string | null
    deliveryEmail: string | null
    deliveryNote: string | null
    pickupName: string | null
    pickupPhone: string | null
    pickupEmail: string | null
    billingName: string | null
    billingAddress: string | null
    billingCity: string | null
    billingZip: string | null
    billingPhone: string | null
    billingEmail: string | null
    billingNote: string | null
    deliveryServiceName: string | null
    orderOnlinePrice: number | null
    orderDiscount: number | null
    orderDeliveryFee: number | null
    orderTotalPrice: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    termsAccepted: number
    shippingNumber: number
    deliveryType: number
    paymentType: number
    status: number
    mediaRemoved: number
    paymentId: number
    paymentStatus: number
    paymentAuthorizationCode: number
    paymentStatusCode: number
    paymentTimestamp: number
    paymentAmount: number
    paymentCurrency: number
    paymentBrand: number
    paymentDetails: number
    checkoutId: number
    cart: number
    deliveryName: number
    deliveryAddress: number
    deliveryCity: number
    deliveryZip: number
    deliveryPhone: number
    deliveryEmail: number
    deliveryNote: number
    pickupName: number
    pickupPhone: number
    pickupEmail: number
    billingName: number
    billingAddress: number
    billingCity: number
    billingZip: number
    billingPhone: number
    billingEmail: number
    billingNote: number
    deliveryServiceName: number
    orderOnlinePrice: number
    orderDiscount: number
    orderDeliveryFee: number
    orderTotalPrice: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    orderOnlinePrice?: true
    orderDiscount?: true
    orderDeliveryFee?: true
    orderTotalPrice?: true
  }

  export type OrderSumAggregateInputType = {
    orderOnlinePrice?: true
    orderDiscount?: true
    orderDeliveryFee?: true
    orderTotalPrice?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    termsAccepted?: true
    shippingNumber?: true
    deliveryType?: true
    paymentType?: true
    status?: true
    mediaRemoved?: true
    paymentId?: true
    paymentStatus?: true
    paymentAuthorizationCode?: true
    paymentStatusCode?: true
    paymentTimestamp?: true
    paymentAmount?: true
    paymentCurrency?: true
    paymentBrand?: true
    checkoutId?: true
    deliveryName?: true
    deliveryAddress?: true
    deliveryCity?: true
    deliveryZip?: true
    deliveryPhone?: true
    deliveryEmail?: true
    deliveryNote?: true
    pickupName?: true
    pickupPhone?: true
    pickupEmail?: true
    billingName?: true
    billingAddress?: true
    billingCity?: true
    billingZip?: true
    billingPhone?: true
    billingEmail?: true
    billingNote?: true
    deliveryServiceName?: true
    orderOnlinePrice?: true
    orderDiscount?: true
    orderDeliveryFee?: true
    orderTotalPrice?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    termsAccepted?: true
    shippingNumber?: true
    deliveryType?: true
    paymentType?: true
    status?: true
    mediaRemoved?: true
    paymentId?: true
    paymentStatus?: true
    paymentAuthorizationCode?: true
    paymentStatusCode?: true
    paymentTimestamp?: true
    paymentAmount?: true
    paymentCurrency?: true
    paymentBrand?: true
    checkoutId?: true
    deliveryName?: true
    deliveryAddress?: true
    deliveryCity?: true
    deliveryZip?: true
    deliveryPhone?: true
    deliveryEmail?: true
    deliveryNote?: true
    pickupName?: true
    pickupPhone?: true
    pickupEmail?: true
    billingName?: true
    billingAddress?: true
    billingCity?: true
    billingZip?: true
    billingPhone?: true
    billingEmail?: true
    billingNote?: true
    deliveryServiceName?: true
    orderOnlinePrice?: true
    orderDiscount?: true
    orderDeliveryFee?: true
    orderTotalPrice?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    termsAccepted?: true
    shippingNumber?: true
    deliveryType?: true
    paymentType?: true
    status?: true
    mediaRemoved?: true
    paymentId?: true
    paymentStatus?: true
    paymentAuthorizationCode?: true
    paymentStatusCode?: true
    paymentTimestamp?: true
    paymentAmount?: true
    paymentCurrency?: true
    paymentBrand?: true
    paymentDetails?: true
    checkoutId?: true
    cart?: true
    deliveryName?: true
    deliveryAddress?: true
    deliveryCity?: true
    deliveryZip?: true
    deliveryPhone?: true
    deliveryEmail?: true
    deliveryNote?: true
    pickupName?: true
    pickupPhone?: true
    pickupEmail?: true
    billingName?: true
    billingAddress?: true
    billingCity?: true
    billingZip?: true
    billingPhone?: true
    billingEmail?: true
    billingNote?: true
    deliveryServiceName?: true
    orderOnlinePrice?: true
    orderDiscount?: true
    orderDeliveryFee?: true
    orderTotalPrice?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    orderNumber: string
    termsAccepted: boolean
    shippingNumber: string
    deliveryType: $Enums.OrderDeliveryType
    paymentType: $Enums.OrderPaymentType
    status: $Enums.OrderStatusType
    mediaRemoved: boolean
    paymentId: string | null
    paymentStatus: $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode: string | null
    paymentStatusCode: string | null
    paymentTimestamp: string | null
    paymentAmount: string | null
    paymentCurrency: string | null
    paymentBrand: string | null
    paymentDetails: JsonValue | null
    checkoutId: string | null
    cart: JsonValue
    deliveryName: string
    deliveryAddress: string
    deliveryCity: string
    deliveryZip: string
    deliveryPhone: string
    deliveryEmail: string
    deliveryNote: string
    pickupName: string
    pickupPhone: string
    pickupEmail: string
    billingName: string
    billingAddress: string
    billingCity: string
    billingZip: string
    billingPhone: string
    billingEmail: string
    billingNote: string
    deliveryServiceName: string
    orderOnlinePrice: number
    orderDiscount: number
    orderDeliveryFee: number
    orderTotalPrice: number
    userId: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    termsAccepted?: boolean
    shippingNumber?: boolean
    deliveryType?: boolean
    paymentType?: boolean
    status?: boolean
    mediaRemoved?: boolean
    paymentId?: boolean
    paymentStatus?: boolean
    paymentAuthorizationCode?: boolean
    paymentStatusCode?: boolean
    paymentTimestamp?: boolean
    paymentAmount?: boolean
    paymentCurrency?: boolean
    paymentBrand?: boolean
    paymentDetails?: boolean
    checkoutId?: boolean
    cart?: boolean
    deliveryName?: boolean
    deliveryAddress?: boolean
    deliveryCity?: boolean
    deliveryZip?: boolean
    deliveryPhone?: boolean
    deliveryEmail?: boolean
    deliveryNote?: boolean
    pickupName?: boolean
    pickupPhone?: boolean
    pickupEmail?: boolean
    billingName?: boolean
    billingAddress?: boolean
    billingCity?: boolean
    billingZip?: boolean
    billingPhone?: boolean
    billingEmail?: boolean
    billingNote?: boolean
    deliveryServiceName?: boolean
    orderOnlinePrice?: boolean
    orderDiscount?: boolean
    orderDeliveryFee?: boolean
    orderTotalPrice?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Order$userArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    termsAccepted?: boolean
    shippingNumber?: boolean
    deliveryType?: boolean
    paymentType?: boolean
    status?: boolean
    mediaRemoved?: boolean
    paymentId?: boolean
    paymentStatus?: boolean
    paymentAuthorizationCode?: boolean
    paymentStatusCode?: boolean
    paymentTimestamp?: boolean
    paymentAmount?: boolean
    paymentCurrency?: boolean
    paymentBrand?: boolean
    paymentDetails?: boolean
    checkoutId?: boolean
    cart?: boolean
    deliveryName?: boolean
    deliveryAddress?: boolean
    deliveryCity?: boolean
    deliveryZip?: boolean
    deliveryPhone?: boolean
    deliveryEmail?: boolean
    deliveryNote?: boolean
    pickupName?: boolean
    pickupPhone?: boolean
    pickupEmail?: boolean
    billingName?: boolean
    billingAddress?: boolean
    billingCity?: boolean
    billingZip?: boolean
    billingPhone?: boolean
    billingEmail?: boolean
    billingNote?: boolean
    deliveryServiceName?: boolean
    orderOnlinePrice?: boolean
    orderDiscount?: boolean
    orderDeliveryFee?: boolean
    orderTotalPrice?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Order$userArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    termsAccepted?: boolean
    shippingNumber?: boolean
    deliveryType?: boolean
    paymentType?: boolean
    status?: boolean
    mediaRemoved?: boolean
    paymentId?: boolean
    paymentStatus?: boolean
    paymentAuthorizationCode?: boolean
    paymentStatusCode?: boolean
    paymentTimestamp?: boolean
    paymentAmount?: boolean
    paymentCurrency?: boolean
    paymentBrand?: boolean
    paymentDetails?: boolean
    checkoutId?: boolean
    cart?: boolean
    deliveryName?: boolean
    deliveryAddress?: boolean
    deliveryCity?: boolean
    deliveryZip?: boolean
    deliveryPhone?: boolean
    deliveryEmail?: boolean
    deliveryNote?: boolean
    pickupName?: boolean
    pickupPhone?: boolean
    pickupEmail?: boolean
    billingName?: boolean
    billingAddress?: boolean
    billingCity?: boolean
    billingZip?: boolean
    billingPhone?: boolean
    billingEmail?: boolean
    billingNote?: boolean
    deliveryServiceName?: boolean
    orderOnlinePrice?: boolean
    orderDiscount?: boolean
    orderDeliveryFee?: boolean
    orderTotalPrice?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Order$userArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    termsAccepted?: boolean
    shippingNumber?: boolean
    deliveryType?: boolean
    paymentType?: boolean
    status?: boolean
    mediaRemoved?: boolean
    paymentId?: boolean
    paymentStatus?: boolean
    paymentAuthorizationCode?: boolean
    paymentStatusCode?: boolean
    paymentTimestamp?: boolean
    paymentAmount?: boolean
    paymentCurrency?: boolean
    paymentBrand?: boolean
    paymentDetails?: boolean
    checkoutId?: boolean
    cart?: boolean
    deliveryName?: boolean
    deliveryAddress?: boolean
    deliveryCity?: boolean
    deliveryZip?: boolean
    deliveryPhone?: boolean
    deliveryEmail?: boolean
    deliveryNote?: boolean
    pickupName?: boolean
    pickupPhone?: boolean
    pickupEmail?: boolean
    billingName?: boolean
    billingAddress?: boolean
    billingCity?: boolean
    billingZip?: boolean
    billingPhone?: boolean
    billingEmail?: boolean
    billingNote?: boolean
    deliveryServiceName?: boolean
    orderOnlinePrice?: boolean
    orderDiscount?: boolean
    orderDeliveryFee?: boolean
    orderTotalPrice?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "termsAccepted" | "shippingNumber" | "deliveryType" | "paymentType" | "status" | "mediaRemoved" | "paymentId" | "paymentStatus" | "paymentAuthorizationCode" | "paymentStatusCode" | "paymentTimestamp" | "paymentAmount" | "paymentCurrency" | "paymentBrand" | "paymentDetails" | "checkoutId" | "cart" | "deliveryName" | "deliveryAddress" | "deliveryCity" | "deliveryZip" | "deliveryPhone" | "deliveryEmail" | "deliveryNote" | "pickupName" | "pickupPhone" | "pickupEmail" | "billingName" | "billingAddress" | "billingCity" | "billingZip" | "billingPhone" | "billingEmail" | "billingNote" | "deliveryServiceName" | "orderOnlinePrice" | "orderDiscount" | "orderDeliveryFee" | "orderTotalPrice" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Order$userArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Order$userArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Order$userArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      termsAccepted: boolean
      shippingNumber: string
      deliveryType: $Enums.OrderDeliveryType
      paymentType: $Enums.OrderPaymentType
      status: $Enums.OrderStatusType
      mediaRemoved: boolean
      paymentId: string | null
      paymentStatus: $Enums.OrderPaymentStatusType | null
      paymentAuthorizationCode: string | null
      paymentStatusCode: string | null
      paymentTimestamp: string | null
      paymentAmount: string | null
      paymentCurrency: string | null
      paymentBrand: string | null
      paymentDetails: Prisma.JsonValue | null
      checkoutId: string | null
      cart: Prisma.JsonValue
      deliveryName: string
      deliveryAddress: string
      deliveryCity: string
      deliveryZip: string
      deliveryPhone: string
      deliveryEmail: string
      deliveryNote: string
      pickupName: string
      pickupPhone: string
      pickupEmail: string
      billingName: string
      billingAddress: string
      billingCity: string
      billingZip: string
      billingPhone: string
      billingEmail: string
      billingNote: string
      deliveryServiceName: string
      orderOnlinePrice: number
      orderDiscount: number
      orderDeliveryFee: number
      orderTotalPrice: number
      userId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Order$userArgs<ExtArgs> = {}>(args?: Subset<T, Order$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly termsAccepted: FieldRef<"Order", 'Boolean'>
    readonly shippingNumber: FieldRef<"Order", 'String'>
    readonly deliveryType: FieldRef<"Order", 'OrderDeliveryType'>
    readonly paymentType: FieldRef<"Order", 'OrderPaymentType'>
    readonly status: FieldRef<"Order", 'OrderStatusType'>
    readonly mediaRemoved: FieldRef<"Order", 'Boolean'>
    readonly paymentId: FieldRef<"Order", 'String'>
    readonly paymentStatus: FieldRef<"Order", 'OrderPaymentStatusType'>
    readonly paymentAuthorizationCode: FieldRef<"Order", 'String'>
    readonly paymentStatusCode: FieldRef<"Order", 'String'>
    readonly paymentTimestamp: FieldRef<"Order", 'String'>
    readonly paymentAmount: FieldRef<"Order", 'String'>
    readonly paymentCurrency: FieldRef<"Order", 'String'>
    readonly paymentBrand: FieldRef<"Order", 'String'>
    readonly paymentDetails: FieldRef<"Order", 'Json'>
    readonly checkoutId: FieldRef<"Order", 'String'>
    readonly cart: FieldRef<"Order", 'Json'>
    readonly deliveryName: FieldRef<"Order", 'String'>
    readonly deliveryAddress: FieldRef<"Order", 'String'>
    readonly deliveryCity: FieldRef<"Order", 'String'>
    readonly deliveryZip: FieldRef<"Order", 'String'>
    readonly deliveryPhone: FieldRef<"Order", 'String'>
    readonly deliveryEmail: FieldRef<"Order", 'String'>
    readonly deliveryNote: FieldRef<"Order", 'String'>
    readonly pickupName: FieldRef<"Order", 'String'>
    readonly pickupPhone: FieldRef<"Order", 'String'>
    readonly pickupEmail: FieldRef<"Order", 'String'>
    readonly billingName: FieldRef<"Order", 'String'>
    readonly billingAddress: FieldRef<"Order", 'String'>
    readonly billingCity: FieldRef<"Order", 'String'>
    readonly billingZip: FieldRef<"Order", 'String'>
    readonly billingPhone: FieldRef<"Order", 'String'>
    readonly billingEmail: FieldRef<"Order", 'String'>
    readonly billingNote: FieldRef<"Order", 'String'>
    readonly deliveryServiceName: FieldRef<"Order", 'String'>
    readonly orderOnlinePrice: FieldRef<"Order", 'Int'>
    readonly orderDiscount: FieldRef<"Order", 'Int'>
    readonly orderDeliveryFee: FieldRef<"Order", 'Int'>
    readonly orderTotalPrice: FieldRef<"Order", 'Int'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.user
   */
  export type Order$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    role: $Enums.UserRoleType | null
    createdAt: Date | null
    updatedAt: Date | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    role: $Enums.UserRoleType | null
    createdAt: Date | null
    updatedAt: Date | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    email: number
    emailVerified: number
    image: number
    role: number
    createdAt: number
    updatedAt: number
    banned: number
    banReason: number
    banExpires: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    banned?: true
    banReason?: true
    banExpires?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    banned?: true
    banReason?: true
    banExpires?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    banned?: true
    banReason?: true
    banExpires?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    phone: string | null
    email: string
    emailVerified: boolean
    image: string | null
    role: $Enums.UserRoleType
    createdAt: Date
    updatedAt: Date
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    media?: boolean | User$mediaArgs<ExtArgs>
    cart?: boolean | User$cartArgs<ExtArgs>
    deliveryAddresses?: boolean | User$deliveryAddressesArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    ratings?: boolean | User$ratingsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "email" | "emailVerified" | "image" | "role" | "createdAt" | "updatedAt" | "banned" | "banReason" | "banExpires", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | User$mediaArgs<ExtArgs>
    cart?: boolean | User$cartArgs<ExtArgs>
    deliveryAddresses?: boolean | User$deliveryAddressesArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    ratings?: boolean | User$ratingsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      media: Prisma.$MediaPayload<ExtArgs>[]
      cart: Prisma.$CartPayload<ExtArgs> | null
      deliveryAddresses: Prisma.$DeliveryAddressPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      ratings: Prisma.$RatingPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      phone: string | null
      email: string
      emailVerified: boolean
      image: string | null
      role: $Enums.UserRoleType
      createdAt: Date
      updatedAt: Date
      banned: boolean | null
      banReason: string | null
      banExpires: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends User$mediaArgs<ExtArgs> = {}>(args?: Subset<T, User$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cart<T extends User$cartArgs<ExtArgs> = {}>(args?: Subset<T, User$cartArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deliveryAddresses<T extends User$deliveryAddressesArgs<ExtArgs> = {}>(args?: Subset<T, User$deliveryAddressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ratings<T extends User$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, User$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRoleType'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly banned: FieldRef<"User", 'Boolean'>
    readonly banReason: FieldRef<"User", 'String'>
    readonly banExpires: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.media
   */
  export type User$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * User.cart
   */
  export type User$cartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    where?: CartWhereInput
  }

  /**
   * User.deliveryAddresses
   */
  export type User$deliveryAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAddress
     */
    select?: DeliveryAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAddress
     */
    omit?: DeliveryAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAddressInclude<ExtArgs> | null
    where?: DeliveryAddressWhereInput
    orderBy?: DeliveryAddressOrderByWithRelationInput | DeliveryAddressOrderByWithRelationInput[]
    cursor?: DeliveryAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryAddressScalarFieldEnum | DeliveryAddressScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.ratings
   */
  export type User$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    scope: string | null
    createdAt: Date | null
    updatedAt: Date | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    password: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    scope: string | null
    createdAt: Date | null
    updatedAt: Date | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    password: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    scope: number
    createdAt: number
    updatedAt: number
    accountId: number
    providerId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    password: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    scope?: true
    createdAt?: true
    updatedAt?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    password?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    scope?: true
    createdAt?: true
    updatedAt?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    password?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    scope?: true
    createdAt?: true
    updatedAt?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    password?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    scope: string | null
    createdAt: Date
    updatedAt: Date
    accountId: string
    providerId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    password: string | null
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scope?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    password?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scope?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    password?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scope?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    password?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    scope?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    password?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "scope" | "createdAt" | "updatedAt" | "accountId" | "providerId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "password", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      scope: string | null
      createdAt: Date
      updatedAt: Date
      accountId: string
      providerId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      password: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly password: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    impersonatedBy: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    impersonatedBy: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    expiresAt: number
    token: number
    ipAddress: number
    userAgent: number
    impersonatedBy: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    impersonatedBy?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    impersonatedBy?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    impersonatedBy?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    updatedAt: Date
    expiresAt: Date
    token: string
    ipAddress: string | null
    userAgent: string | null
    impersonatedBy: string | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    impersonatedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    impersonatedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    impersonatedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    impersonatedBy?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdAt" | "updatedAt" | "expiresAt" | "token" | "ipAddress" | "userAgent" | "impersonatedBy", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      updatedAt: Date
      expiresAt: Date
      token: string
      ipAddress: string | null
      userAgent: string | null
      impersonatedBy: string | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly impersonatedBy: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    active: 'active',
    special: 'special',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const PackageOptionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PackageOptionScalarFieldEnum = (typeof PackageOptionScalarFieldEnum)[keyof typeof PackageOptionScalarFieldEnum]


  export const DeliveryServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    link: 'link',
    active: 'active',
    predefinedPrices: 'predefinedPrices',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeliveryServiceScalarFieldEnum = (typeof DeliveryServiceScalarFieldEnum)[keyof typeof DeliveryServiceScalarFieldEnum]


  export const BannerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    link: 'link',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BannerScalarFieldEnum = (typeof BannerScalarFieldEnum)[keyof typeof BannerScalarFieldEnum]


  export const CouponScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    discountType: 'discountType',
    discount: 'discount',
    cartValue: 'cartValue',
    available: 'available',
    used: 'used',
    active: 'active',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum]


  export const DeliveryFeeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    fee: 'fee',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeliveryFeeScalarFieldEnum = (typeof DeliveryFeeScalarFieldEnum)[keyof typeof DeliveryFeeScalarFieldEnum]


  export const PriceRangeScalarFieldEnum: {
    id: 'id',
    from: 'from',
    to: 'to',
    price: 'price',
    deliveryFeeId: 'deliveryFeeId',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PriceRangeScalarFieldEnum = (typeof PriceRangeScalarFieldEnum)[keyof typeof PriceRangeScalarFieldEnum]


  export const DiscountScalarFieldEnum: {
    id: 'id',
    name: 'name',
    percentage: 'percentage',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DiscountScalarFieldEnum = (typeof DiscountScalarFieldEnum)[keyof typeof DiscountScalarFieldEnum]


  export const TextPersonalizationFieldScalarFieldEnum: {
    id: 'id',
    name: 'name',
    placeholder: 'placeholder',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TextPersonalizationFieldScalarFieldEnum = (typeof TextPersonalizationFieldScalarFieldEnum)[keyof typeof TextPersonalizationFieldScalarFieldEnum]


  export const ImagePersonalizationFieldScalarFieldEnum: {
    id: 'id',
    name: 'name',
    min: 'min',
    max: 'max',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImagePersonalizationFieldScalarFieldEnum = (typeof ImagePersonalizationFieldScalarFieldEnum)[keyof typeof ImagePersonalizationFieldScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    price: 'price',
    discountId: 'discountId',
    material: 'material',
    dimensions: 'dimensions',
    personalization: 'personalization',
    description: 'description',
    delivery: 'delivery',
    inStock: 'inStock',
    trending: 'trending',
    packageOptionId: 'packageOptionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const RatingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    name: 'name',
    score: 'score',
    comment: 'comment',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RatingScalarFieldEnum = (typeof RatingScalarFieldEnum)[keyof typeof RatingScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    key: 'key',
    type: 'type',
    url: 'url',
    userId: 'userId',
    categoryId: 'categoryId',
    deliveryServiceId: 'deliveryServiceId',
    desktopBannerImageId: 'desktopBannerImageId',
    mobileBannerImageId: 'mobileBannerImageId',
    productCoverId: 'productCoverId',
    productImagesId: 'productImagesId',
    imagePersonalizationId: 'imagePersonalizationId',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const CartScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    onlinePrice: 'onlinePrice',
    totalPrice: 'totalPrice',
    deliveryFee: 'deliveryFee',
    totalPriceWithDeliveryFee: 'totalPriceWithDeliveryFee',
    discount: 'discount',
    couponId: 'couponId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


  export const CartItemScalarFieldEnum: {
    id: 'id',
    cartId: 'cartId',
    productId: 'productId',
    price: 'price',
    deliveryFee: 'deliveryFee',
    quantity: 'quantity',
    fontType: 'fontType',
    packageOptionSelected: 'packageOptionSelected',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartItemScalarFieldEnum = (typeof CartItemScalarFieldEnum)[keyof typeof CartItemScalarFieldEnum]


  export const TextPersonalizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    cartItemId: 'cartItemId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TextPersonalizationScalarFieldEnum = (typeof TextPersonalizationScalarFieldEnum)[keyof typeof TextPersonalizationScalarFieldEnum]


  export const ImagePersonalizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    cartItemId: 'cartItemId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImagePersonalizationScalarFieldEnum = (typeof ImagePersonalizationScalarFieldEnum)[keyof typeof ImagePersonalizationScalarFieldEnum]


  export const DeliveryAddressScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    city: 'city',
    zip: 'zip',
    phone: 'phone',
    email: 'email',
    note: 'note',
    type: 'type',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeliveryAddressScalarFieldEnum = (typeof DeliveryAddressScalarFieldEnum)[keyof typeof DeliveryAddressScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    termsAccepted: 'termsAccepted',
    shippingNumber: 'shippingNumber',
    deliveryType: 'deliveryType',
    paymentType: 'paymentType',
    status: 'status',
    mediaRemoved: 'mediaRemoved',
    paymentId: 'paymentId',
    paymentStatus: 'paymentStatus',
    paymentAuthorizationCode: 'paymentAuthorizationCode',
    paymentStatusCode: 'paymentStatusCode',
    paymentTimestamp: 'paymentTimestamp',
    paymentAmount: 'paymentAmount',
    paymentCurrency: 'paymentCurrency',
    paymentBrand: 'paymentBrand',
    paymentDetails: 'paymentDetails',
    checkoutId: 'checkoutId',
    cart: 'cart',
    deliveryName: 'deliveryName',
    deliveryAddress: 'deliveryAddress',
    deliveryCity: 'deliveryCity',
    deliveryZip: 'deliveryZip',
    deliveryPhone: 'deliveryPhone',
    deliveryEmail: 'deliveryEmail',
    deliveryNote: 'deliveryNote',
    pickupName: 'pickupName',
    pickupPhone: 'pickupPhone',
    pickupEmail: 'pickupEmail',
    billingName: 'billingName',
    billingAddress: 'billingAddress',
    billingCity: 'billingCity',
    billingZip: 'billingZip',
    billingPhone: 'billingPhone',
    billingEmail: 'billingEmail',
    billingNote: 'billingNote',
    deliveryServiceName: 'deliveryServiceName',
    orderOnlinePrice: 'orderOnlinePrice',
    orderDiscount: 'orderDiscount',
    orderDeliveryFee: 'orderDeliveryFee',
    orderTotalPrice: 'orderTotalPrice',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    banned: 'banned',
    banReason: 'banReason',
    banExpires: 'banExpires'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    scope: 'scope',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    accountId: 'accountId',
    providerId: 'providerId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    password: 'password'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expiresAt: 'expiresAt',
    token: 'token',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    impersonatedBy: 'impersonatedBy'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'DiscountType'
   */
  export type EnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType'>
    


  /**
   * Reference to a field of type 'DiscountType[]'
   */
  export type ListEnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType[]'>
    


  /**
   * Reference to a field of type 'DeliveryType'
   */
  export type EnumDeliveryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryType'>
    


  /**
   * Reference to a field of type 'DeliveryType[]'
   */
  export type ListEnumDeliveryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryType[]'>
    


  /**
   * Reference to a field of type 'RatingStatusType'
   */
  export type EnumRatingStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RatingStatusType'>
    


  /**
   * Reference to a field of type 'RatingStatusType[]'
   */
  export type ListEnumRatingStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RatingStatusType[]'>
    


  /**
   * Reference to a field of type 'FontType'
   */
  export type EnumFontTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FontType'>
    


  /**
   * Reference to a field of type 'FontType[]'
   */
  export type ListEnumFontTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FontType[]'>
    


  /**
   * Reference to a field of type 'DeliveryAddressType'
   */
  export type EnumDeliveryAddressTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryAddressType'>
    


  /**
   * Reference to a field of type 'DeliveryAddressType[]'
   */
  export type ListEnumDeliveryAddressTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryAddressType[]'>
    


  /**
   * Reference to a field of type 'OrderDeliveryType'
   */
  export type EnumOrderDeliveryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderDeliveryType'>
    


  /**
   * Reference to a field of type 'OrderDeliveryType[]'
   */
  export type ListEnumOrderDeliveryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderDeliveryType[]'>
    


  /**
   * Reference to a field of type 'OrderPaymentType'
   */
  export type EnumOrderPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderPaymentType'>
    


  /**
   * Reference to a field of type 'OrderPaymentType[]'
   */
  export type ListEnumOrderPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderPaymentType[]'>
    


  /**
   * Reference to a field of type 'OrderStatusType'
   */
  export type EnumOrderStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatusType'>
    


  /**
   * Reference to a field of type 'OrderStatusType[]'
   */
  export type ListEnumOrderStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatusType[]'>
    


  /**
   * Reference to a field of type 'OrderPaymentStatusType'
   */
  export type EnumOrderPaymentStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderPaymentStatusType'>
    


  /**
   * Reference to a field of type 'OrderPaymentStatusType[]'
   */
  export type ListEnumOrderPaymentStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderPaymentStatusType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'UserRoleType'
   */
  export type EnumUserRoleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRoleType'>
    


  /**
   * Reference to a field of type 'UserRoleType[]'
   */
  export type ListEnumUserRoleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRoleType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    active?: BoolFilter<"Category"> | boolean
    special?: BoolFilter<"Category"> | boolean
    position?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    image?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    active?: SortOrder
    special?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    image?: MediaOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    active?: BoolFilter<"Category"> | boolean
    special?: BoolFilter<"Category"> | boolean
    position?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    image?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    products?: ProductListRelationFilter
  }, "id" | "name" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    active?: SortOrder
    special?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    active?: BoolWithAggregatesFilter<"Category"> | boolean
    special?: BoolWithAggregatesFilter<"Category"> | boolean
    position?: IntWithAggregatesFilter<"Category"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type PackageOptionWhereInput = {
    AND?: PackageOptionWhereInput | PackageOptionWhereInput[]
    OR?: PackageOptionWhereInput[]
    NOT?: PackageOptionWhereInput | PackageOptionWhereInput[]
    id?: StringFilter<"PackageOption"> | string
    name?: StringFilter<"PackageOption"> | string
    description?: StringFilter<"PackageOption"> | string
    price?: IntFilter<"PackageOption"> | number
    createdAt?: DateTimeFilter<"PackageOption"> | Date | string
    updatedAt?: DateTimeFilter<"PackageOption"> | Date | string
    products?: ProductListRelationFilter
  }

  export type PackageOptionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type PackageOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PackageOptionWhereInput | PackageOptionWhereInput[]
    OR?: PackageOptionWhereInput[]
    NOT?: PackageOptionWhereInput | PackageOptionWhereInput[]
    description?: StringFilter<"PackageOption"> | string
    price?: IntFilter<"PackageOption"> | number
    createdAt?: DateTimeFilter<"PackageOption"> | Date | string
    updatedAt?: DateTimeFilter<"PackageOption"> | Date | string
    products?: ProductListRelationFilter
  }, "id" | "name">

  export type PackageOptionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PackageOptionCountOrderByAggregateInput
    _avg?: PackageOptionAvgOrderByAggregateInput
    _max?: PackageOptionMaxOrderByAggregateInput
    _min?: PackageOptionMinOrderByAggregateInput
    _sum?: PackageOptionSumOrderByAggregateInput
  }

  export type PackageOptionScalarWhereWithAggregatesInput = {
    AND?: PackageOptionScalarWhereWithAggregatesInput | PackageOptionScalarWhereWithAggregatesInput[]
    OR?: PackageOptionScalarWhereWithAggregatesInput[]
    NOT?: PackageOptionScalarWhereWithAggregatesInput | PackageOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PackageOption"> | string
    name?: StringWithAggregatesFilter<"PackageOption"> | string
    description?: StringWithAggregatesFilter<"PackageOption"> | string
    price?: IntWithAggregatesFilter<"PackageOption"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PackageOption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PackageOption"> | Date | string
  }

  export type DeliveryServiceWhereInput = {
    AND?: DeliveryServiceWhereInput | DeliveryServiceWhereInput[]
    OR?: DeliveryServiceWhereInput[]
    NOT?: DeliveryServiceWhereInput | DeliveryServiceWhereInput[]
    id?: StringFilter<"DeliveryService"> | string
    name?: StringFilter<"DeliveryService"> | string
    link?: StringFilter<"DeliveryService"> | string
    active?: BoolFilter<"DeliveryService"> | boolean
    predefinedPrices?: BoolFilter<"DeliveryService"> | boolean
    createdAt?: DateTimeFilter<"DeliveryService"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryService"> | Date | string
    pdf?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
  }

  export type DeliveryServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    active?: SortOrder
    predefinedPrices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pdf?: MediaOrderByWithRelationInput
  }

  export type DeliveryServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DeliveryServiceWhereInput | DeliveryServiceWhereInput[]
    OR?: DeliveryServiceWhereInput[]
    NOT?: DeliveryServiceWhereInput | DeliveryServiceWhereInput[]
    link?: StringFilter<"DeliveryService"> | string
    active?: BoolFilter<"DeliveryService"> | boolean
    predefinedPrices?: BoolFilter<"DeliveryService"> | boolean
    createdAt?: DateTimeFilter<"DeliveryService"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryService"> | Date | string
    pdf?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
  }, "id" | "name">

  export type DeliveryServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    active?: SortOrder
    predefinedPrices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeliveryServiceCountOrderByAggregateInput
    _max?: DeliveryServiceMaxOrderByAggregateInput
    _min?: DeliveryServiceMinOrderByAggregateInput
  }

  export type DeliveryServiceScalarWhereWithAggregatesInput = {
    AND?: DeliveryServiceScalarWhereWithAggregatesInput | DeliveryServiceScalarWhereWithAggregatesInput[]
    OR?: DeliveryServiceScalarWhereWithAggregatesInput[]
    NOT?: DeliveryServiceScalarWhereWithAggregatesInput | DeliveryServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryService"> | string
    name?: StringWithAggregatesFilter<"DeliveryService"> | string
    link?: StringWithAggregatesFilter<"DeliveryService"> | string
    active?: BoolWithAggregatesFilter<"DeliveryService"> | boolean
    predefinedPrices?: BoolWithAggregatesFilter<"DeliveryService"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryService"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeliveryService"> | Date | string
  }

  export type BannerWhereInput = {
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    id?: StringFilter<"Banner"> | string
    name?: StringFilter<"Banner"> | string
    link?: StringFilter<"Banner"> | string
    active?: BoolFilter<"Banner"> | boolean
    createdAt?: DateTimeFilter<"Banner"> | Date | string
    updatedAt?: DateTimeFilter<"Banner"> | Date | string
    desktopImage?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    mobileImage?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
  }

  export type BannerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    desktopImage?: MediaOrderByWithRelationInput
    mobileImage?: MediaOrderByWithRelationInput
  }

  export type BannerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    name?: StringFilter<"Banner"> | string
    link?: StringFilter<"Banner"> | string
    active?: BoolFilter<"Banner"> | boolean
    createdAt?: DateTimeFilter<"Banner"> | Date | string
    updatedAt?: DateTimeFilter<"Banner"> | Date | string
    desktopImage?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    mobileImage?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
  }, "id">

  export type BannerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BannerCountOrderByAggregateInput
    _max?: BannerMaxOrderByAggregateInput
    _min?: BannerMinOrderByAggregateInput
  }

  export type BannerScalarWhereWithAggregatesInput = {
    AND?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    OR?: BannerScalarWhereWithAggregatesInput[]
    NOT?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Banner"> | string
    name?: StringWithAggregatesFilter<"Banner"> | string
    link?: StringWithAggregatesFilter<"Banner"> | string
    active?: BoolWithAggregatesFilter<"Banner"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string
  }

  export type CouponWhereInput = {
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    id?: StringFilter<"Coupon"> | string
    name?: StringFilter<"Coupon"> | string
    code?: StringFilter<"Coupon"> | string
    discountType?: EnumDiscountTypeFilter<"Coupon"> | $Enums.DiscountType
    discount?: IntFilter<"Coupon"> | number
    cartValue?: IntFilter<"Coupon"> | number
    available?: IntFilter<"Coupon"> | number
    used?: IntFilter<"Coupon"> | number
    active?: BoolFilter<"Coupon"> | boolean
    expiresAt?: DateTimeFilter<"Coupon"> | Date | string
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
    carts?: CartListRelationFilter
  }

  export type CouponOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    discountType?: SortOrder
    discount?: SortOrder
    cartValue?: SortOrder
    available?: SortOrder
    used?: SortOrder
    active?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    carts?: CartOrderByRelationAggregateInput
  }

  export type CouponWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    name?: StringFilter<"Coupon"> | string
    discountType?: EnumDiscountTypeFilter<"Coupon"> | $Enums.DiscountType
    discount?: IntFilter<"Coupon"> | number
    cartValue?: IntFilter<"Coupon"> | number
    available?: IntFilter<"Coupon"> | number
    used?: IntFilter<"Coupon"> | number
    active?: BoolFilter<"Coupon"> | boolean
    expiresAt?: DateTimeFilter<"Coupon"> | Date | string
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
    carts?: CartListRelationFilter
  }, "id" | "code">

  export type CouponOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    discountType?: SortOrder
    discount?: SortOrder
    cartValue?: SortOrder
    available?: SortOrder
    used?: SortOrder
    active?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CouponCountOrderByAggregateInput
    _avg?: CouponAvgOrderByAggregateInput
    _max?: CouponMaxOrderByAggregateInput
    _min?: CouponMinOrderByAggregateInput
    _sum?: CouponSumOrderByAggregateInput
  }

  export type CouponScalarWhereWithAggregatesInput = {
    AND?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    OR?: CouponScalarWhereWithAggregatesInput[]
    NOT?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Coupon"> | string
    name?: StringWithAggregatesFilter<"Coupon"> | string
    code?: StringWithAggregatesFilter<"Coupon"> | string
    discountType?: EnumDiscountTypeWithAggregatesFilter<"Coupon"> | $Enums.DiscountType
    discount?: IntWithAggregatesFilter<"Coupon"> | number
    cartValue?: IntWithAggregatesFilter<"Coupon"> | number
    available?: IntWithAggregatesFilter<"Coupon"> | number
    used?: IntWithAggregatesFilter<"Coupon"> | number
    active?: BoolWithAggregatesFilter<"Coupon"> | boolean
    expiresAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
  }

  export type DeliveryFeeWhereInput = {
    AND?: DeliveryFeeWhereInput | DeliveryFeeWhereInput[]
    OR?: DeliveryFeeWhereInput[]
    NOT?: DeliveryFeeWhereInput | DeliveryFeeWhereInput[]
    id?: StringFilter<"DeliveryFee"> | string
    name?: StringFilter<"DeliveryFee"> | string
    fee?: IntFilter<"DeliveryFee"> | number
    createdAt?: DateTimeFilter<"DeliveryFee"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryFee"> | Date | string
    priceRange?: PriceRangeListRelationFilter
  }

  export type DeliveryFeeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    fee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    priceRange?: PriceRangeOrderByRelationAggregateInput
  }

  export type DeliveryFeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryFeeWhereInput | DeliveryFeeWhereInput[]
    OR?: DeliveryFeeWhereInput[]
    NOT?: DeliveryFeeWhereInput | DeliveryFeeWhereInput[]
    name?: StringFilter<"DeliveryFee"> | string
    fee?: IntFilter<"DeliveryFee"> | number
    createdAt?: DateTimeFilter<"DeliveryFee"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryFee"> | Date | string
    priceRange?: PriceRangeListRelationFilter
  }, "id">

  export type DeliveryFeeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    fee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeliveryFeeCountOrderByAggregateInput
    _avg?: DeliveryFeeAvgOrderByAggregateInput
    _max?: DeliveryFeeMaxOrderByAggregateInput
    _min?: DeliveryFeeMinOrderByAggregateInput
    _sum?: DeliveryFeeSumOrderByAggregateInput
  }

  export type DeliveryFeeScalarWhereWithAggregatesInput = {
    AND?: DeliveryFeeScalarWhereWithAggregatesInput | DeliveryFeeScalarWhereWithAggregatesInput[]
    OR?: DeliveryFeeScalarWhereWithAggregatesInput[]
    NOT?: DeliveryFeeScalarWhereWithAggregatesInput | DeliveryFeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryFee"> | string
    name?: StringWithAggregatesFilter<"DeliveryFee"> | string
    fee?: IntWithAggregatesFilter<"DeliveryFee"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryFee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeliveryFee"> | Date | string
  }

  export type PriceRangeWhereInput = {
    AND?: PriceRangeWhereInput | PriceRangeWhereInput[]
    OR?: PriceRangeWhereInput[]
    NOT?: PriceRangeWhereInput | PriceRangeWhereInput[]
    id?: StringFilter<"PriceRange"> | string
    from?: IntFilter<"PriceRange"> | number
    to?: IntFilter<"PriceRange"> | number
    price?: IntFilter<"PriceRange"> | number
    deliveryFeeId?: StringFilter<"PriceRange"> | string
    productId?: StringNullableFilter<"PriceRange"> | string | null
    createdAt?: DateTimeFilter<"PriceRange"> | Date | string
    updatedAt?: DateTimeFilter<"PriceRange"> | Date | string
    deliveryFee?: XOR<DeliveryFeeScalarRelationFilter, DeliveryFeeWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }

  export type PriceRangeOrderByWithRelationInput = {
    id?: SortOrder
    from?: SortOrder
    to?: SortOrder
    price?: SortOrder
    deliveryFeeId?: SortOrder
    productId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deliveryFee?: DeliveryFeeOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type PriceRangeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PriceRangeWhereInput | PriceRangeWhereInput[]
    OR?: PriceRangeWhereInput[]
    NOT?: PriceRangeWhereInput | PriceRangeWhereInput[]
    from?: IntFilter<"PriceRange"> | number
    to?: IntFilter<"PriceRange"> | number
    price?: IntFilter<"PriceRange"> | number
    deliveryFeeId?: StringFilter<"PriceRange"> | string
    productId?: StringNullableFilter<"PriceRange"> | string | null
    createdAt?: DateTimeFilter<"PriceRange"> | Date | string
    updatedAt?: DateTimeFilter<"PriceRange"> | Date | string
    deliveryFee?: XOR<DeliveryFeeScalarRelationFilter, DeliveryFeeWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }, "id">

  export type PriceRangeOrderByWithAggregationInput = {
    id?: SortOrder
    from?: SortOrder
    to?: SortOrder
    price?: SortOrder
    deliveryFeeId?: SortOrder
    productId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PriceRangeCountOrderByAggregateInput
    _avg?: PriceRangeAvgOrderByAggregateInput
    _max?: PriceRangeMaxOrderByAggregateInput
    _min?: PriceRangeMinOrderByAggregateInput
    _sum?: PriceRangeSumOrderByAggregateInput
  }

  export type PriceRangeScalarWhereWithAggregatesInput = {
    AND?: PriceRangeScalarWhereWithAggregatesInput | PriceRangeScalarWhereWithAggregatesInput[]
    OR?: PriceRangeScalarWhereWithAggregatesInput[]
    NOT?: PriceRangeScalarWhereWithAggregatesInput | PriceRangeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PriceRange"> | string
    from?: IntWithAggregatesFilter<"PriceRange"> | number
    to?: IntWithAggregatesFilter<"PriceRange"> | number
    price?: IntWithAggregatesFilter<"PriceRange"> | number
    deliveryFeeId?: StringWithAggregatesFilter<"PriceRange"> | string
    productId?: StringNullableWithAggregatesFilter<"PriceRange"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PriceRange"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PriceRange"> | Date | string
  }

  export type DiscountWhereInput = {
    AND?: DiscountWhereInput | DiscountWhereInput[]
    OR?: DiscountWhereInput[]
    NOT?: DiscountWhereInput | DiscountWhereInput[]
    id?: StringFilter<"Discount"> | string
    name?: StringFilter<"Discount"> | string
    percentage?: IntFilter<"Discount"> | number
    active?: BoolFilter<"Discount"> | boolean
    createdAt?: DateTimeFilter<"Discount"> | Date | string
    updatedAt?: DateTimeFilter<"Discount"> | Date | string
    products?: ProductListRelationFilter
  }

  export type DiscountOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    percentage?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type DiscountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DiscountWhereInput | DiscountWhereInput[]
    OR?: DiscountWhereInput[]
    NOT?: DiscountWhereInput | DiscountWhereInput[]
    percentage?: IntFilter<"Discount"> | number
    active?: BoolFilter<"Discount"> | boolean
    createdAt?: DateTimeFilter<"Discount"> | Date | string
    updatedAt?: DateTimeFilter<"Discount"> | Date | string
    products?: ProductListRelationFilter
  }, "id" | "name">

  export type DiscountOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    percentage?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DiscountCountOrderByAggregateInput
    _avg?: DiscountAvgOrderByAggregateInput
    _max?: DiscountMaxOrderByAggregateInput
    _min?: DiscountMinOrderByAggregateInput
    _sum?: DiscountSumOrderByAggregateInput
  }

  export type DiscountScalarWhereWithAggregatesInput = {
    AND?: DiscountScalarWhereWithAggregatesInput | DiscountScalarWhereWithAggregatesInput[]
    OR?: DiscountScalarWhereWithAggregatesInput[]
    NOT?: DiscountScalarWhereWithAggregatesInput | DiscountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Discount"> | string
    name?: StringWithAggregatesFilter<"Discount"> | string
    percentage?: IntWithAggregatesFilter<"Discount"> | number
    active?: BoolWithAggregatesFilter<"Discount"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Discount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Discount"> | Date | string
  }

  export type TextPersonalizationFieldWhereInput = {
    AND?: TextPersonalizationFieldWhereInput | TextPersonalizationFieldWhereInput[]
    OR?: TextPersonalizationFieldWhereInput[]
    NOT?: TextPersonalizationFieldWhereInput | TextPersonalizationFieldWhereInput[]
    id?: StringFilter<"TextPersonalizationField"> | string
    name?: StringFilter<"TextPersonalizationField"> | string
    placeholder?: StringFilter<"TextPersonalizationField"> | string
    productId?: StringNullableFilter<"TextPersonalizationField"> | string | null
    createdAt?: DateTimeFilter<"TextPersonalizationField"> | Date | string
    updatedAt?: DateTimeFilter<"TextPersonalizationField"> | Date | string
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }

  export type TextPersonalizationFieldOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    placeholder?: SortOrder
    productId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type TextPersonalizationFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TextPersonalizationFieldWhereInput | TextPersonalizationFieldWhereInput[]
    OR?: TextPersonalizationFieldWhereInput[]
    NOT?: TextPersonalizationFieldWhereInput | TextPersonalizationFieldWhereInput[]
    name?: StringFilter<"TextPersonalizationField"> | string
    placeholder?: StringFilter<"TextPersonalizationField"> | string
    productId?: StringNullableFilter<"TextPersonalizationField"> | string | null
    createdAt?: DateTimeFilter<"TextPersonalizationField"> | Date | string
    updatedAt?: DateTimeFilter<"TextPersonalizationField"> | Date | string
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }, "id">

  export type TextPersonalizationFieldOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    placeholder?: SortOrder
    productId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TextPersonalizationFieldCountOrderByAggregateInput
    _max?: TextPersonalizationFieldMaxOrderByAggregateInput
    _min?: TextPersonalizationFieldMinOrderByAggregateInput
  }

  export type TextPersonalizationFieldScalarWhereWithAggregatesInput = {
    AND?: TextPersonalizationFieldScalarWhereWithAggregatesInput | TextPersonalizationFieldScalarWhereWithAggregatesInput[]
    OR?: TextPersonalizationFieldScalarWhereWithAggregatesInput[]
    NOT?: TextPersonalizationFieldScalarWhereWithAggregatesInput | TextPersonalizationFieldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TextPersonalizationField"> | string
    name?: StringWithAggregatesFilter<"TextPersonalizationField"> | string
    placeholder?: StringWithAggregatesFilter<"TextPersonalizationField"> | string
    productId?: StringNullableWithAggregatesFilter<"TextPersonalizationField"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TextPersonalizationField"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TextPersonalizationField"> | Date | string
  }

  export type ImagePersonalizationFieldWhereInput = {
    AND?: ImagePersonalizationFieldWhereInput | ImagePersonalizationFieldWhereInput[]
    OR?: ImagePersonalizationFieldWhereInput[]
    NOT?: ImagePersonalizationFieldWhereInput | ImagePersonalizationFieldWhereInput[]
    id?: StringFilter<"ImagePersonalizationField"> | string
    name?: StringFilter<"ImagePersonalizationField"> | string
    min?: IntFilter<"ImagePersonalizationField"> | number
    max?: IntFilter<"ImagePersonalizationField"> | number
    productId?: StringNullableFilter<"ImagePersonalizationField"> | string | null
    createdAt?: DateTimeFilter<"ImagePersonalizationField"> | Date | string
    updatedAt?: DateTimeFilter<"ImagePersonalizationField"> | Date | string
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }

  export type ImagePersonalizationFieldOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    min?: SortOrder
    max?: SortOrder
    productId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ImagePersonalizationFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImagePersonalizationFieldWhereInput | ImagePersonalizationFieldWhereInput[]
    OR?: ImagePersonalizationFieldWhereInput[]
    NOT?: ImagePersonalizationFieldWhereInput | ImagePersonalizationFieldWhereInput[]
    name?: StringFilter<"ImagePersonalizationField"> | string
    min?: IntFilter<"ImagePersonalizationField"> | number
    max?: IntFilter<"ImagePersonalizationField"> | number
    productId?: StringNullableFilter<"ImagePersonalizationField"> | string | null
    createdAt?: DateTimeFilter<"ImagePersonalizationField"> | Date | string
    updatedAt?: DateTimeFilter<"ImagePersonalizationField"> | Date | string
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }, "id">

  export type ImagePersonalizationFieldOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    min?: SortOrder
    max?: SortOrder
    productId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImagePersonalizationFieldCountOrderByAggregateInput
    _avg?: ImagePersonalizationFieldAvgOrderByAggregateInput
    _max?: ImagePersonalizationFieldMaxOrderByAggregateInput
    _min?: ImagePersonalizationFieldMinOrderByAggregateInput
    _sum?: ImagePersonalizationFieldSumOrderByAggregateInput
  }

  export type ImagePersonalizationFieldScalarWhereWithAggregatesInput = {
    AND?: ImagePersonalizationFieldScalarWhereWithAggregatesInput | ImagePersonalizationFieldScalarWhereWithAggregatesInput[]
    OR?: ImagePersonalizationFieldScalarWhereWithAggregatesInput[]
    NOT?: ImagePersonalizationFieldScalarWhereWithAggregatesInput | ImagePersonalizationFieldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImagePersonalizationField"> | string
    name?: StringWithAggregatesFilter<"ImagePersonalizationField"> | string
    min?: IntWithAggregatesFilter<"ImagePersonalizationField"> | number
    max?: IntWithAggregatesFilter<"ImagePersonalizationField"> | number
    productId?: StringNullableWithAggregatesFilter<"ImagePersonalizationField"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ImagePersonalizationField"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ImagePersonalizationField"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    code?: StringFilter<"Product"> | string
    price?: IntFilter<"Product"> | number
    discountId?: StringNullableFilter<"Product"> | string | null
    material?: StringFilter<"Product"> | string
    dimensions?: StringFilter<"Product"> | string
    personalization?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    delivery?: EnumDeliveryTypeFilter<"Product"> | $Enums.DeliveryType
    inStock?: BoolFilter<"Product"> | boolean
    trending?: BoolFilter<"Product"> | boolean
    packageOptionId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    categories?: CategoryListRelationFilter
    priceTable?: PriceRangeListRelationFilter
    discount?: XOR<DiscountNullableScalarRelationFilter, DiscountWhereInput> | null
    packageOption?: XOR<PackageOptionNullableScalarRelationFilter, PackageOptionWhereInput> | null
    coverImage?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    images?: MediaListRelationFilter
    imagePersonalizationFields?: ImagePersonalizationFieldListRelationFilter
    textPersonalizationFields?: TextPersonalizationFieldListRelationFilter
    cartItems?: CartItemListRelationFilter
    ratings?: RatingListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    price?: SortOrder
    discountId?: SortOrderInput | SortOrder
    material?: SortOrder
    dimensions?: SortOrder
    personalization?: SortOrder
    description?: SortOrder
    delivery?: SortOrder
    inStock?: SortOrder
    trending?: SortOrder
    packageOptionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categories?: CategoryOrderByRelationAggregateInput
    priceTable?: PriceRangeOrderByRelationAggregateInput
    discount?: DiscountOrderByWithRelationInput
    packageOption?: PackageOptionOrderByWithRelationInput
    coverImage?: MediaOrderByWithRelationInput
    images?: MediaOrderByRelationAggregateInput
    imagePersonalizationFields?: ImagePersonalizationFieldOrderByRelationAggregateInput
    textPersonalizationFields?: TextPersonalizationFieldOrderByRelationAggregateInput
    cartItems?: CartItemOrderByRelationAggregateInput
    ratings?: RatingOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    price?: IntFilter<"Product"> | number
    discountId?: StringNullableFilter<"Product"> | string | null
    material?: StringFilter<"Product"> | string
    dimensions?: StringFilter<"Product"> | string
    personalization?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    delivery?: EnumDeliveryTypeFilter<"Product"> | $Enums.DeliveryType
    inStock?: BoolFilter<"Product"> | boolean
    trending?: BoolFilter<"Product"> | boolean
    packageOptionId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    categories?: CategoryListRelationFilter
    priceTable?: PriceRangeListRelationFilter
    discount?: XOR<DiscountNullableScalarRelationFilter, DiscountWhereInput> | null
    packageOption?: XOR<PackageOptionNullableScalarRelationFilter, PackageOptionWhereInput> | null
    coverImage?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    images?: MediaListRelationFilter
    imagePersonalizationFields?: ImagePersonalizationFieldListRelationFilter
    textPersonalizationFields?: TextPersonalizationFieldListRelationFilter
    cartItems?: CartItemListRelationFilter
    ratings?: RatingListRelationFilter
  }, "id" | "code">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    price?: SortOrder
    discountId?: SortOrderInput | SortOrder
    material?: SortOrder
    dimensions?: SortOrder
    personalization?: SortOrder
    description?: SortOrder
    delivery?: SortOrder
    inStock?: SortOrder
    trending?: SortOrder
    packageOptionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    code?: StringWithAggregatesFilter<"Product"> | string
    price?: IntWithAggregatesFilter<"Product"> | number
    discountId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    material?: StringWithAggregatesFilter<"Product"> | string
    dimensions?: StringWithAggregatesFilter<"Product"> | string
    personalization?: StringWithAggregatesFilter<"Product"> | string
    description?: StringWithAggregatesFilter<"Product"> | string
    delivery?: EnumDeliveryTypeWithAggregatesFilter<"Product"> | $Enums.DeliveryType
    inStock?: BoolWithAggregatesFilter<"Product"> | boolean
    trending?: BoolWithAggregatesFilter<"Product"> | boolean
    packageOptionId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type RatingWhereInput = {
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    id?: StringFilter<"Rating"> | string
    userId?: StringFilter<"Rating"> | string
    productId?: StringFilter<"Rating"> | string
    name?: StringFilter<"Rating"> | string
    score?: IntFilter<"Rating"> | number
    comment?: StringFilter<"Rating"> | string
    status?: EnumRatingStatusTypeFilter<"Rating"> | $Enums.RatingStatusType
    createdAt?: DateTimeFilter<"Rating"> | Date | string
    updatedAt?: DateTimeFilter<"Rating"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type RatingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    score?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type RatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    userId?: StringFilter<"Rating"> | string
    productId?: StringFilter<"Rating"> | string
    name?: StringFilter<"Rating"> | string
    score?: IntFilter<"Rating"> | number
    comment?: StringFilter<"Rating"> | string
    status?: EnumRatingStatusTypeFilter<"Rating"> | $Enums.RatingStatusType
    createdAt?: DateTimeFilter<"Rating"> | Date | string
    updatedAt?: DateTimeFilter<"Rating"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type RatingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    score?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RatingCountOrderByAggregateInput
    _avg?: RatingAvgOrderByAggregateInput
    _max?: RatingMaxOrderByAggregateInput
    _min?: RatingMinOrderByAggregateInput
    _sum?: RatingSumOrderByAggregateInput
  }

  export type RatingScalarWhereWithAggregatesInput = {
    AND?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    OR?: RatingScalarWhereWithAggregatesInput[]
    NOT?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Rating"> | string
    userId?: StringWithAggregatesFilter<"Rating"> | string
    productId?: StringWithAggregatesFilter<"Rating"> | string
    name?: StringWithAggregatesFilter<"Rating"> | string
    score?: IntWithAggregatesFilter<"Rating"> | number
    comment?: StringWithAggregatesFilter<"Rating"> | string
    status?: EnumRatingStatusTypeWithAggregatesFilter<"Rating"> | $Enums.RatingStatusType
    createdAt?: DateTimeWithAggregatesFilter<"Rating"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Rating"> | Date | string
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: StringFilter<"Media"> | string
    name?: StringFilter<"Media"> | string
    key?: StringFilter<"Media"> | string
    type?: StringFilter<"Media"> | string
    url?: StringFilter<"Media"> | string
    userId?: StringNullableFilter<"Media"> | string | null
    categoryId?: StringNullableFilter<"Media"> | string | null
    deliveryServiceId?: StringNullableFilter<"Media"> | string | null
    desktopBannerImageId?: StringNullableFilter<"Media"> | string | null
    mobileBannerImageId?: StringNullableFilter<"Media"> | string | null
    productCoverId?: StringNullableFilter<"Media"> | string | null
    productImagesId?: StringNullableFilter<"Media"> | string | null
    imagePersonalizationId?: StringNullableFilter<"Media"> | string | null
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    deliveryService?: XOR<DeliveryServiceNullableScalarRelationFilter, DeliveryServiceWhereInput> | null
    desktopBannerImage?: XOR<BannerNullableScalarRelationFilter, BannerWhereInput> | null
    mobileBannerImage?: XOR<BannerNullableScalarRelationFilter, BannerWhereInput> | null
    productCover?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    productImages?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    imagePersonalization?: XOR<ImagePersonalizationNullableScalarRelationFilter, ImagePersonalizationWhereInput> | null
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    type?: SortOrder
    url?: SortOrder
    userId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    deliveryServiceId?: SortOrderInput | SortOrder
    desktopBannerImageId?: SortOrderInput | SortOrder
    mobileBannerImageId?: SortOrderInput | SortOrder
    productCoverId?: SortOrderInput | SortOrder
    productImagesId?: SortOrderInput | SortOrder
    imagePersonalizationId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    deliveryService?: DeliveryServiceOrderByWithRelationInput
    desktopBannerImage?: BannerOrderByWithRelationInput
    mobileBannerImage?: BannerOrderByWithRelationInput
    productCover?: ProductOrderByWithRelationInput
    productImages?: ProductOrderByWithRelationInput
    imagePersonalization?: ImagePersonalizationOrderByWithRelationInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    url?: string
    categoryId?: string
    deliveryServiceId?: string
    desktopBannerImageId?: string
    mobileBannerImageId?: string
    productCoverId?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    name?: StringFilter<"Media"> | string
    type?: StringFilter<"Media"> | string
    userId?: StringNullableFilter<"Media"> | string | null
    productImagesId?: StringNullableFilter<"Media"> | string | null
    imagePersonalizationId?: StringNullableFilter<"Media"> | string | null
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    deliveryService?: XOR<DeliveryServiceNullableScalarRelationFilter, DeliveryServiceWhereInput> | null
    desktopBannerImage?: XOR<BannerNullableScalarRelationFilter, BannerWhereInput> | null
    mobileBannerImage?: XOR<BannerNullableScalarRelationFilter, BannerWhereInput> | null
    productCover?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    productImages?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    imagePersonalization?: XOR<ImagePersonalizationNullableScalarRelationFilter, ImagePersonalizationWhereInput> | null
  }, "id" | "key" | "url" | "categoryId" | "deliveryServiceId" | "desktopBannerImageId" | "mobileBannerImageId" | "productCoverId">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    type?: SortOrder
    url?: SortOrder
    userId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    deliveryServiceId?: SortOrderInput | SortOrder
    desktopBannerImageId?: SortOrderInput | SortOrder
    mobileBannerImageId?: SortOrderInput | SortOrder
    productCoverId?: SortOrderInput | SortOrder
    productImagesId?: SortOrderInput | SortOrder
    imagePersonalizationId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Media"> | string
    name?: StringWithAggregatesFilter<"Media"> | string
    key?: StringWithAggregatesFilter<"Media"> | string
    type?: StringWithAggregatesFilter<"Media"> | string
    url?: StringWithAggregatesFilter<"Media"> | string
    userId?: StringNullableWithAggregatesFilter<"Media"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"Media"> | string | null
    deliveryServiceId?: StringNullableWithAggregatesFilter<"Media"> | string | null
    desktopBannerImageId?: StringNullableWithAggregatesFilter<"Media"> | string | null
    mobileBannerImageId?: StringNullableWithAggregatesFilter<"Media"> | string | null
    productCoverId?: StringNullableWithAggregatesFilter<"Media"> | string | null
    productImagesId?: StringNullableWithAggregatesFilter<"Media"> | string | null
    imagePersonalizationId?: StringNullableWithAggregatesFilter<"Media"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
  }

  export type CartWhereInput = {
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    id?: StringFilter<"Cart"> | string
    userId?: StringFilter<"Cart"> | string
    onlinePrice?: IntFilter<"Cart"> | number
    totalPrice?: IntFilter<"Cart"> | number
    deliveryFee?: IntFilter<"Cart"> | number
    totalPriceWithDeliveryFee?: IntFilter<"Cart"> | number
    discount?: IntFilter<"Cart"> | number
    couponId?: StringNullableFilter<"Cart"> | string | null
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: CartItemListRelationFilter
    coupon?: XOR<CouponNullableScalarRelationFilter, CouponWhereInput> | null
  }

  export type CartOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    onlinePrice?: SortOrder
    totalPrice?: SortOrder
    deliveryFee?: SortOrder
    totalPriceWithDeliveryFee?: SortOrder
    discount?: SortOrder
    couponId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    items?: CartItemOrderByRelationAggregateInput
    coupon?: CouponOrderByWithRelationInput
  }

  export type CartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    onlinePrice?: IntFilter<"Cart"> | number
    totalPrice?: IntFilter<"Cart"> | number
    deliveryFee?: IntFilter<"Cart"> | number
    totalPriceWithDeliveryFee?: IntFilter<"Cart"> | number
    discount?: IntFilter<"Cart"> | number
    couponId?: StringNullableFilter<"Cart"> | string | null
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: CartItemListRelationFilter
    coupon?: XOR<CouponNullableScalarRelationFilter, CouponWhereInput> | null
  }, "id" | "userId">

  export type CartOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    onlinePrice?: SortOrder
    totalPrice?: SortOrder
    deliveryFee?: SortOrder
    totalPriceWithDeliveryFee?: SortOrder
    discount?: SortOrder
    couponId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CartCountOrderByAggregateInput
    _avg?: CartAvgOrderByAggregateInput
    _max?: CartMaxOrderByAggregateInput
    _min?: CartMinOrderByAggregateInput
    _sum?: CartSumOrderByAggregateInput
  }

  export type CartScalarWhereWithAggregatesInput = {
    AND?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    OR?: CartScalarWhereWithAggregatesInput[]
    NOT?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cart"> | string
    userId?: StringWithAggregatesFilter<"Cart"> | string
    onlinePrice?: IntWithAggregatesFilter<"Cart"> | number
    totalPrice?: IntWithAggregatesFilter<"Cart"> | number
    deliveryFee?: IntWithAggregatesFilter<"Cart"> | number
    totalPriceWithDeliveryFee?: IntWithAggregatesFilter<"Cart"> | number
    discount?: IntWithAggregatesFilter<"Cart"> | number
    couponId?: StringNullableWithAggregatesFilter<"Cart"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
  }

  export type CartItemWhereInput = {
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    price?: IntFilter<"CartItem"> | number
    deliveryFee?: IntFilter<"CartItem"> | number
    quantity?: IntFilter<"CartItem"> | number
    fontType?: EnumFontTypeFilter<"CartItem"> | $Enums.FontType
    packageOptionSelected?: BoolFilter<"CartItem"> | boolean
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    textPersonalizations?: TextPersonalizationListRelationFilter
    imagePersonalizations?: ImagePersonalizationListRelationFilter
  }

  export type CartItemOrderByWithRelationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    deliveryFee?: SortOrder
    quantity?: SortOrder
    fontType?: SortOrder
    packageOptionSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cart?: CartOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    textPersonalizations?: TextPersonalizationOrderByRelationAggregateInput
    imagePersonalizations?: ImagePersonalizationOrderByRelationAggregateInput
  }

  export type CartItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    price?: IntFilter<"CartItem"> | number
    deliveryFee?: IntFilter<"CartItem"> | number
    quantity?: IntFilter<"CartItem"> | number
    fontType?: EnumFontTypeFilter<"CartItem"> | $Enums.FontType
    packageOptionSelected?: BoolFilter<"CartItem"> | boolean
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    textPersonalizations?: TextPersonalizationListRelationFilter
    imagePersonalizations?: ImagePersonalizationListRelationFilter
  }, "id">

  export type CartItemOrderByWithAggregationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    deliveryFee?: SortOrder
    quantity?: SortOrder
    fontType?: SortOrder
    packageOptionSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CartItemCountOrderByAggregateInput
    _avg?: CartItemAvgOrderByAggregateInput
    _max?: CartItemMaxOrderByAggregateInput
    _min?: CartItemMinOrderByAggregateInput
    _sum?: CartItemSumOrderByAggregateInput
  }

  export type CartItemScalarWhereWithAggregatesInput = {
    AND?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    OR?: CartItemScalarWhereWithAggregatesInput[]
    NOT?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CartItem"> | string
    cartId?: StringWithAggregatesFilter<"CartItem"> | string
    productId?: StringWithAggregatesFilter<"CartItem"> | string
    price?: IntWithAggregatesFilter<"CartItem"> | number
    deliveryFee?: IntWithAggregatesFilter<"CartItem"> | number
    quantity?: IntWithAggregatesFilter<"CartItem"> | number
    fontType?: EnumFontTypeWithAggregatesFilter<"CartItem"> | $Enums.FontType
    packageOptionSelected?: BoolWithAggregatesFilter<"CartItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
  }

  export type TextPersonalizationWhereInput = {
    AND?: TextPersonalizationWhereInput | TextPersonalizationWhereInput[]
    OR?: TextPersonalizationWhereInput[]
    NOT?: TextPersonalizationWhereInput | TextPersonalizationWhereInput[]
    id?: StringFilter<"TextPersonalization"> | string
    name?: StringFilter<"TextPersonalization"> | string
    value?: StringFilter<"TextPersonalization"> | string
    cartItemId?: StringNullableFilter<"TextPersonalization"> | string | null
    createdAt?: DateTimeFilter<"TextPersonalization"> | Date | string
    updatedAt?: DateTimeFilter<"TextPersonalization"> | Date | string
    cartItem?: XOR<CartItemNullableScalarRelationFilter, CartItemWhereInput> | null
  }

  export type TextPersonalizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    cartItemId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cartItem?: CartItemOrderByWithRelationInput
  }

  export type TextPersonalizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TextPersonalizationWhereInput | TextPersonalizationWhereInput[]
    OR?: TextPersonalizationWhereInput[]
    NOT?: TextPersonalizationWhereInput | TextPersonalizationWhereInput[]
    name?: StringFilter<"TextPersonalization"> | string
    value?: StringFilter<"TextPersonalization"> | string
    cartItemId?: StringNullableFilter<"TextPersonalization"> | string | null
    createdAt?: DateTimeFilter<"TextPersonalization"> | Date | string
    updatedAt?: DateTimeFilter<"TextPersonalization"> | Date | string
    cartItem?: XOR<CartItemNullableScalarRelationFilter, CartItemWhereInput> | null
  }, "id">

  export type TextPersonalizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    cartItemId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TextPersonalizationCountOrderByAggregateInput
    _max?: TextPersonalizationMaxOrderByAggregateInput
    _min?: TextPersonalizationMinOrderByAggregateInput
  }

  export type TextPersonalizationScalarWhereWithAggregatesInput = {
    AND?: TextPersonalizationScalarWhereWithAggregatesInput | TextPersonalizationScalarWhereWithAggregatesInput[]
    OR?: TextPersonalizationScalarWhereWithAggregatesInput[]
    NOT?: TextPersonalizationScalarWhereWithAggregatesInput | TextPersonalizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TextPersonalization"> | string
    name?: StringWithAggregatesFilter<"TextPersonalization"> | string
    value?: StringWithAggregatesFilter<"TextPersonalization"> | string
    cartItemId?: StringNullableWithAggregatesFilter<"TextPersonalization"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TextPersonalization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TextPersonalization"> | Date | string
  }

  export type ImagePersonalizationWhereInput = {
    AND?: ImagePersonalizationWhereInput | ImagePersonalizationWhereInput[]
    OR?: ImagePersonalizationWhereInput[]
    NOT?: ImagePersonalizationWhereInput | ImagePersonalizationWhereInput[]
    id?: StringFilter<"ImagePersonalization"> | string
    name?: StringFilter<"ImagePersonalization"> | string
    cartItemId?: StringNullableFilter<"ImagePersonalization"> | string | null
    createdAt?: DateTimeFilter<"ImagePersonalization"> | Date | string
    updatedAt?: DateTimeFilter<"ImagePersonalization"> | Date | string
    images?: MediaListRelationFilter
    cartItem?: XOR<CartItemNullableScalarRelationFilter, CartItemWhereInput> | null
  }

  export type ImagePersonalizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    cartItemId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    images?: MediaOrderByRelationAggregateInput
    cartItem?: CartItemOrderByWithRelationInput
  }

  export type ImagePersonalizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImagePersonalizationWhereInput | ImagePersonalizationWhereInput[]
    OR?: ImagePersonalizationWhereInput[]
    NOT?: ImagePersonalizationWhereInput | ImagePersonalizationWhereInput[]
    name?: StringFilter<"ImagePersonalization"> | string
    cartItemId?: StringNullableFilter<"ImagePersonalization"> | string | null
    createdAt?: DateTimeFilter<"ImagePersonalization"> | Date | string
    updatedAt?: DateTimeFilter<"ImagePersonalization"> | Date | string
    images?: MediaListRelationFilter
    cartItem?: XOR<CartItemNullableScalarRelationFilter, CartItemWhereInput> | null
  }, "id">

  export type ImagePersonalizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    cartItemId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImagePersonalizationCountOrderByAggregateInput
    _max?: ImagePersonalizationMaxOrderByAggregateInput
    _min?: ImagePersonalizationMinOrderByAggregateInput
  }

  export type ImagePersonalizationScalarWhereWithAggregatesInput = {
    AND?: ImagePersonalizationScalarWhereWithAggregatesInput | ImagePersonalizationScalarWhereWithAggregatesInput[]
    OR?: ImagePersonalizationScalarWhereWithAggregatesInput[]
    NOT?: ImagePersonalizationScalarWhereWithAggregatesInput | ImagePersonalizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImagePersonalization"> | string
    name?: StringWithAggregatesFilter<"ImagePersonalization"> | string
    cartItemId?: StringNullableWithAggregatesFilter<"ImagePersonalization"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ImagePersonalization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ImagePersonalization"> | Date | string
  }

  export type DeliveryAddressWhereInput = {
    AND?: DeliveryAddressWhereInput | DeliveryAddressWhereInput[]
    OR?: DeliveryAddressWhereInput[]
    NOT?: DeliveryAddressWhereInput | DeliveryAddressWhereInput[]
    id?: StringFilter<"DeliveryAddress"> | string
    name?: StringFilter<"DeliveryAddress"> | string
    address?: StringFilter<"DeliveryAddress"> | string
    city?: StringFilter<"DeliveryAddress"> | string
    zip?: StringFilter<"DeliveryAddress"> | string
    phone?: StringFilter<"DeliveryAddress"> | string
    email?: StringFilter<"DeliveryAddress"> | string
    note?: StringNullableFilter<"DeliveryAddress"> | string | null
    type?: EnumDeliveryAddressTypeFilter<"DeliveryAddress"> | $Enums.DeliveryAddressType
    userId?: StringFilter<"DeliveryAddress"> | string
    createdAt?: DateTimeFilter<"DeliveryAddress"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryAddress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DeliveryAddressOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zip?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    note?: SortOrderInput | SortOrder
    type?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DeliveryAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryAddressWhereInput | DeliveryAddressWhereInput[]
    OR?: DeliveryAddressWhereInput[]
    NOT?: DeliveryAddressWhereInput | DeliveryAddressWhereInput[]
    name?: StringFilter<"DeliveryAddress"> | string
    address?: StringFilter<"DeliveryAddress"> | string
    city?: StringFilter<"DeliveryAddress"> | string
    zip?: StringFilter<"DeliveryAddress"> | string
    phone?: StringFilter<"DeliveryAddress"> | string
    email?: StringFilter<"DeliveryAddress"> | string
    note?: StringNullableFilter<"DeliveryAddress"> | string | null
    type?: EnumDeliveryAddressTypeFilter<"DeliveryAddress"> | $Enums.DeliveryAddressType
    userId?: StringFilter<"DeliveryAddress"> | string
    createdAt?: DateTimeFilter<"DeliveryAddress"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryAddress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DeliveryAddressOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zip?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    note?: SortOrderInput | SortOrder
    type?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeliveryAddressCountOrderByAggregateInput
    _max?: DeliveryAddressMaxOrderByAggregateInput
    _min?: DeliveryAddressMinOrderByAggregateInput
  }

  export type DeliveryAddressScalarWhereWithAggregatesInput = {
    AND?: DeliveryAddressScalarWhereWithAggregatesInput | DeliveryAddressScalarWhereWithAggregatesInput[]
    OR?: DeliveryAddressScalarWhereWithAggregatesInput[]
    NOT?: DeliveryAddressScalarWhereWithAggregatesInput | DeliveryAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryAddress"> | string
    name?: StringWithAggregatesFilter<"DeliveryAddress"> | string
    address?: StringWithAggregatesFilter<"DeliveryAddress"> | string
    city?: StringWithAggregatesFilter<"DeliveryAddress"> | string
    zip?: StringWithAggregatesFilter<"DeliveryAddress"> | string
    phone?: StringWithAggregatesFilter<"DeliveryAddress"> | string
    email?: StringWithAggregatesFilter<"DeliveryAddress"> | string
    note?: StringNullableWithAggregatesFilter<"DeliveryAddress"> | string | null
    type?: EnumDeliveryAddressTypeWithAggregatesFilter<"DeliveryAddress"> | $Enums.DeliveryAddressType
    userId?: StringWithAggregatesFilter<"DeliveryAddress"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryAddress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeliveryAddress"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    termsAccepted?: BoolFilter<"Order"> | boolean
    shippingNumber?: StringFilter<"Order"> | string
    deliveryType?: EnumOrderDeliveryTypeFilter<"Order"> | $Enums.OrderDeliveryType
    paymentType?: EnumOrderPaymentTypeFilter<"Order"> | $Enums.OrderPaymentType
    status?: EnumOrderStatusTypeFilter<"Order"> | $Enums.OrderStatusType
    mediaRemoved?: BoolFilter<"Order"> | boolean
    paymentId?: StringNullableFilter<"Order"> | string | null
    paymentStatus?: EnumOrderPaymentStatusTypeNullableFilter<"Order"> | $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode?: StringNullableFilter<"Order"> | string | null
    paymentStatusCode?: StringNullableFilter<"Order"> | string | null
    paymentTimestamp?: StringNullableFilter<"Order"> | string | null
    paymentAmount?: StringNullableFilter<"Order"> | string | null
    paymentCurrency?: StringNullableFilter<"Order"> | string | null
    paymentBrand?: StringNullableFilter<"Order"> | string | null
    paymentDetails?: JsonNullableFilter<"Order">
    checkoutId?: StringNullableFilter<"Order"> | string | null
    cart?: JsonFilter<"Order">
    deliveryName?: StringFilter<"Order"> | string
    deliveryAddress?: StringFilter<"Order"> | string
    deliveryCity?: StringFilter<"Order"> | string
    deliveryZip?: StringFilter<"Order"> | string
    deliveryPhone?: StringFilter<"Order"> | string
    deliveryEmail?: StringFilter<"Order"> | string
    deliveryNote?: StringFilter<"Order"> | string
    pickupName?: StringFilter<"Order"> | string
    pickupPhone?: StringFilter<"Order"> | string
    pickupEmail?: StringFilter<"Order"> | string
    billingName?: StringFilter<"Order"> | string
    billingAddress?: StringFilter<"Order"> | string
    billingCity?: StringFilter<"Order"> | string
    billingZip?: StringFilter<"Order"> | string
    billingPhone?: StringFilter<"Order"> | string
    billingEmail?: StringFilter<"Order"> | string
    billingNote?: StringFilter<"Order"> | string
    deliveryServiceName?: StringFilter<"Order"> | string
    orderOnlinePrice?: IntFilter<"Order"> | number
    orderDiscount?: IntFilter<"Order"> | number
    orderDeliveryFee?: IntFilter<"Order"> | number
    orderTotalPrice?: IntFilter<"Order"> | number
    userId?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    termsAccepted?: SortOrder
    shippingNumber?: SortOrder
    deliveryType?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    mediaRemoved?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    paymentAuthorizationCode?: SortOrderInput | SortOrder
    paymentStatusCode?: SortOrderInput | SortOrder
    paymentTimestamp?: SortOrderInput | SortOrder
    paymentAmount?: SortOrderInput | SortOrder
    paymentCurrency?: SortOrderInput | SortOrder
    paymentBrand?: SortOrderInput | SortOrder
    paymentDetails?: SortOrderInput | SortOrder
    checkoutId?: SortOrderInput | SortOrder
    cart?: SortOrder
    deliveryName?: SortOrder
    deliveryAddress?: SortOrder
    deliveryCity?: SortOrder
    deliveryZip?: SortOrder
    deliveryPhone?: SortOrder
    deliveryEmail?: SortOrder
    deliveryNote?: SortOrder
    pickupName?: SortOrder
    pickupPhone?: SortOrder
    pickupEmail?: SortOrder
    billingName?: SortOrder
    billingAddress?: SortOrder
    billingCity?: SortOrder
    billingZip?: SortOrder
    billingPhone?: SortOrder
    billingEmail?: SortOrder
    billingNote?: SortOrder
    deliveryServiceName?: SortOrder
    orderOnlinePrice?: SortOrder
    orderDiscount?: SortOrder
    orderDeliveryFee?: SortOrder
    orderTotalPrice?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    orderNumber?: StringFilter<"Order"> | string
    termsAccepted?: BoolFilter<"Order"> | boolean
    shippingNumber?: StringFilter<"Order"> | string
    deliveryType?: EnumOrderDeliveryTypeFilter<"Order"> | $Enums.OrderDeliveryType
    paymentType?: EnumOrderPaymentTypeFilter<"Order"> | $Enums.OrderPaymentType
    status?: EnumOrderStatusTypeFilter<"Order"> | $Enums.OrderStatusType
    mediaRemoved?: BoolFilter<"Order"> | boolean
    paymentId?: StringNullableFilter<"Order"> | string | null
    paymentStatus?: EnumOrderPaymentStatusTypeNullableFilter<"Order"> | $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode?: StringNullableFilter<"Order"> | string | null
    paymentStatusCode?: StringNullableFilter<"Order"> | string | null
    paymentTimestamp?: StringNullableFilter<"Order"> | string | null
    paymentAmount?: StringNullableFilter<"Order"> | string | null
    paymentCurrency?: StringNullableFilter<"Order"> | string | null
    paymentBrand?: StringNullableFilter<"Order"> | string | null
    paymentDetails?: JsonNullableFilter<"Order">
    checkoutId?: StringNullableFilter<"Order"> | string | null
    cart?: JsonFilter<"Order">
    deliveryName?: StringFilter<"Order"> | string
    deliveryAddress?: StringFilter<"Order"> | string
    deliveryCity?: StringFilter<"Order"> | string
    deliveryZip?: StringFilter<"Order"> | string
    deliveryPhone?: StringFilter<"Order"> | string
    deliveryEmail?: StringFilter<"Order"> | string
    deliveryNote?: StringFilter<"Order"> | string
    pickupName?: StringFilter<"Order"> | string
    pickupPhone?: StringFilter<"Order"> | string
    pickupEmail?: StringFilter<"Order"> | string
    billingName?: StringFilter<"Order"> | string
    billingAddress?: StringFilter<"Order"> | string
    billingCity?: StringFilter<"Order"> | string
    billingZip?: StringFilter<"Order"> | string
    billingPhone?: StringFilter<"Order"> | string
    billingEmail?: StringFilter<"Order"> | string
    billingNote?: StringFilter<"Order"> | string
    deliveryServiceName?: StringFilter<"Order"> | string
    orderOnlinePrice?: IntFilter<"Order"> | number
    orderDiscount?: IntFilter<"Order"> | number
    orderDeliveryFee?: IntFilter<"Order"> | number
    orderTotalPrice?: IntFilter<"Order"> | number
    userId?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    termsAccepted?: SortOrder
    shippingNumber?: SortOrder
    deliveryType?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    mediaRemoved?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    paymentAuthorizationCode?: SortOrderInput | SortOrder
    paymentStatusCode?: SortOrderInput | SortOrder
    paymentTimestamp?: SortOrderInput | SortOrder
    paymentAmount?: SortOrderInput | SortOrder
    paymentCurrency?: SortOrderInput | SortOrder
    paymentBrand?: SortOrderInput | SortOrder
    paymentDetails?: SortOrderInput | SortOrder
    checkoutId?: SortOrderInput | SortOrder
    cart?: SortOrder
    deliveryName?: SortOrder
    deliveryAddress?: SortOrder
    deliveryCity?: SortOrder
    deliveryZip?: SortOrder
    deliveryPhone?: SortOrder
    deliveryEmail?: SortOrder
    deliveryNote?: SortOrder
    pickupName?: SortOrder
    pickupPhone?: SortOrder
    pickupEmail?: SortOrder
    billingName?: SortOrder
    billingAddress?: SortOrder
    billingCity?: SortOrder
    billingZip?: SortOrder
    billingPhone?: SortOrder
    billingEmail?: SortOrder
    billingNote?: SortOrder
    deliveryServiceName?: SortOrder
    orderOnlinePrice?: SortOrder
    orderDiscount?: SortOrder
    orderDeliveryFee?: SortOrder
    orderTotalPrice?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    termsAccepted?: BoolWithAggregatesFilter<"Order"> | boolean
    shippingNumber?: StringWithAggregatesFilter<"Order"> | string
    deliveryType?: EnumOrderDeliveryTypeWithAggregatesFilter<"Order"> | $Enums.OrderDeliveryType
    paymentType?: EnumOrderPaymentTypeWithAggregatesFilter<"Order"> | $Enums.OrderPaymentType
    status?: EnumOrderStatusTypeWithAggregatesFilter<"Order"> | $Enums.OrderStatusType
    mediaRemoved?: BoolWithAggregatesFilter<"Order"> | boolean
    paymentId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paymentStatus?: EnumOrderPaymentStatusTypeNullableWithAggregatesFilter<"Order"> | $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paymentStatusCode?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paymentTimestamp?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paymentAmount?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paymentCurrency?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paymentBrand?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paymentDetails?: JsonNullableWithAggregatesFilter<"Order">
    checkoutId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    cart?: JsonWithAggregatesFilter<"Order">
    deliveryName?: StringWithAggregatesFilter<"Order"> | string
    deliveryAddress?: StringWithAggregatesFilter<"Order"> | string
    deliveryCity?: StringWithAggregatesFilter<"Order"> | string
    deliveryZip?: StringWithAggregatesFilter<"Order"> | string
    deliveryPhone?: StringWithAggregatesFilter<"Order"> | string
    deliveryEmail?: StringWithAggregatesFilter<"Order"> | string
    deliveryNote?: StringWithAggregatesFilter<"Order"> | string
    pickupName?: StringWithAggregatesFilter<"Order"> | string
    pickupPhone?: StringWithAggregatesFilter<"Order"> | string
    pickupEmail?: StringWithAggregatesFilter<"Order"> | string
    billingName?: StringWithAggregatesFilter<"Order"> | string
    billingAddress?: StringWithAggregatesFilter<"Order"> | string
    billingCity?: StringWithAggregatesFilter<"Order"> | string
    billingZip?: StringWithAggregatesFilter<"Order"> | string
    billingPhone?: StringWithAggregatesFilter<"Order"> | string
    billingEmail?: StringWithAggregatesFilter<"Order"> | string
    billingNote?: StringWithAggregatesFilter<"Order"> | string
    deliveryServiceName?: StringWithAggregatesFilter<"Order"> | string
    orderOnlinePrice?: IntWithAggregatesFilter<"Order"> | number
    orderDiscount?: IntWithAggregatesFilter<"Order"> | number
    orderDeliveryFee?: IntWithAggregatesFilter<"Order"> | number
    orderTotalPrice?: IntWithAggregatesFilter<"Order"> | number
    userId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleTypeFilter<"User"> | $Enums.UserRoleType
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    banned?: BoolNullableFilter<"User"> | boolean | null
    banReason?: StringNullableFilter<"User"> | string | null
    banExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    media?: MediaListRelationFilter
    cart?: XOR<CartNullableScalarRelationFilter, CartWhereInput> | null
    deliveryAddresses?: DeliveryAddressListRelationFilter
    orders?: OrderListRelationFilter
    ratings?: RatingListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    banned?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    media?: MediaOrderByRelationAggregateInput
    cart?: CartOrderByWithRelationInput
    deliveryAddresses?: DeliveryAddressOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    ratings?: RatingOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleTypeFilter<"User"> | $Enums.UserRoleType
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    banned?: BoolNullableFilter<"User"> | boolean | null
    banReason?: StringNullableFilter<"User"> | string | null
    banExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    media?: MediaListRelationFilter
    cart?: XOR<CartNullableScalarRelationFilter, CartWhereInput> | null
    deliveryAddresses?: DeliveryAddressListRelationFilter
    orders?: OrderListRelationFilter
    ratings?: RatingListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    banned?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleTypeWithAggregatesFilter<"User"> | $Enums.UserRoleType
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    banned?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    banReason?: StringNullableWithAggregatesFilter<"User"> | string | null
    banExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    scope?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    scope?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    scope?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    scope?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    impersonatedBy?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    impersonatedBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    impersonatedBy?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    impersonatedBy?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    impersonatedBy?: StringNullableWithAggregatesFilter<"Session"> | string | null
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    active?: boolean
    special?: boolean
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: MediaCreateNestedOneWithoutCategoryInput
    products?: ProductCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    active?: boolean
    special?: boolean
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: MediaUncheckedCreateNestedOneWithoutCategoryInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    special?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: MediaUpdateOneWithoutCategoryNestedInput
    products?: ProductUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    special?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: MediaUncheckedUpdateOneWithoutCategoryNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    active?: boolean
    special?: boolean
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    special?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    special?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageOptionCreateInput = {
    id?: string
    name: string
    description: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutPackageOptionInput
  }

  export type PackageOptionUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutPackageOptionInput
  }

  export type PackageOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutPackageOptionNestedInput
  }

  export type PackageOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutPackageOptionNestedInput
  }

  export type PackageOptionCreateManyInput = {
    id?: string
    name: string
    description: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryServiceCreateInput = {
    id?: string
    name: string
    link: string
    active?: boolean
    predefinedPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pdf?: MediaCreateNestedOneWithoutDeliveryServiceInput
  }

  export type DeliveryServiceUncheckedCreateInput = {
    id?: string
    name: string
    link: string
    active?: boolean
    predefinedPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pdf?: MediaUncheckedCreateNestedOneWithoutDeliveryServiceInput
  }

  export type DeliveryServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    predefinedPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pdf?: MediaUpdateOneWithoutDeliveryServiceNestedInput
  }

  export type DeliveryServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    predefinedPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pdf?: MediaUncheckedUpdateOneWithoutDeliveryServiceNestedInput
  }

  export type DeliveryServiceCreateManyInput = {
    id?: string
    name: string
    link: string
    active?: boolean
    predefinedPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    predefinedPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    predefinedPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerCreateInput = {
    id?: string
    name: string
    link: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    desktopImage?: MediaCreateNestedOneWithoutDesktopBannerImageInput
    mobileImage?: MediaCreateNestedOneWithoutMobileBannerImageInput
  }

  export type BannerUncheckedCreateInput = {
    id?: string
    name: string
    link: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    desktopImage?: MediaUncheckedCreateNestedOneWithoutDesktopBannerImageInput
    mobileImage?: MediaUncheckedCreateNestedOneWithoutMobileBannerImageInput
  }

  export type BannerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desktopImage?: MediaUpdateOneWithoutDesktopBannerImageNestedInput
    mobileImage?: MediaUpdateOneWithoutMobileBannerImageNestedInput
  }

  export type BannerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desktopImage?: MediaUncheckedUpdateOneWithoutDesktopBannerImageNestedInput
    mobileImage?: MediaUncheckedUpdateOneWithoutMobileBannerImageNestedInput
  }

  export type BannerCreateManyInput = {
    id?: string
    name: string
    link: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponCreateInput = {
    id?: string
    name: string
    code: string
    discountType: $Enums.DiscountType
    discount: number
    cartValue: number
    available: number
    used?: number
    active?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    discountType: $Enums.DiscountType
    discount: number
    cartValue: number
    available: number
    used?: number
    active?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discount?: IntFieldUpdateOperationsInput | number
    cartValue?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    used?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discount?: IntFieldUpdateOperationsInput | number
    cartValue?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    used?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type CouponCreateManyInput = {
    id?: string
    name: string
    code: string
    discountType: $Enums.DiscountType
    discount: number
    cartValue: number
    available: number
    used?: number
    active?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discount?: IntFieldUpdateOperationsInput | number
    cartValue?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    used?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discount?: IntFieldUpdateOperationsInput | number
    cartValue?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    used?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryFeeCreateInput = {
    id?: string
    name: string
    fee: number
    createdAt?: Date | string
    updatedAt?: Date | string
    priceRange?: PriceRangeCreateNestedManyWithoutDeliveryFeeInput
  }

  export type DeliveryFeeUncheckedCreateInput = {
    id?: string
    name: string
    fee: number
    createdAt?: Date | string
    updatedAt?: Date | string
    priceRange?: PriceRangeUncheckedCreateNestedManyWithoutDeliveryFeeInput
  }

  export type DeliveryFeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceRange?: PriceRangeUpdateManyWithoutDeliveryFeeNestedInput
  }

  export type DeliveryFeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceRange?: PriceRangeUncheckedUpdateManyWithoutDeliveryFeeNestedInput
  }

  export type DeliveryFeeCreateManyInput = {
    id?: string
    name: string
    fee: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryFeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryFeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceRangeCreateInput = {
    id?: string
    from: number
    to: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryFee: DeliveryFeeCreateNestedOneWithoutPriceRangeInput
    product?: ProductCreateNestedOneWithoutPriceTableInput
  }

  export type PriceRangeUncheckedCreateInput = {
    id?: string
    from: number
    to: number
    price: number
    deliveryFeeId: string
    productId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceRangeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryFee?: DeliveryFeeUpdateOneRequiredWithoutPriceRangeNestedInput
    product?: ProductUpdateOneWithoutPriceTableNestedInput
  }

  export type PriceRangeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    deliveryFeeId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceRangeCreateManyInput = {
    id?: string
    from: number
    to: number
    price: number
    deliveryFeeId: string
    productId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceRangeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceRangeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    deliveryFeeId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountCreateInput = {
    id?: string
    name: string
    percentage: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutDiscountInput
  }

  export type DiscountUncheckedCreateInput = {
    id?: string
    name: string
    percentage: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutDiscountInput
  }

  export type DiscountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentage?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutDiscountNestedInput
  }

  export type DiscountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentage?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutDiscountNestedInput
  }

  export type DiscountCreateManyInput = {
    id?: string
    name: string
    percentage: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentage?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentage?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextPersonalizationFieldCreateInput = {
    id?: string
    name: string
    placeholder: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedOneWithoutTextPersonalizationFieldsInput
  }

  export type TextPersonalizationFieldUncheckedCreateInput = {
    id?: string
    name: string
    placeholder: string
    productId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TextPersonalizationFieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneWithoutTextPersonalizationFieldsNestedInput
  }

  export type TextPersonalizationFieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextPersonalizationFieldCreateManyInput = {
    id?: string
    name: string
    placeholder: string
    productId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TextPersonalizationFieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextPersonalizationFieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImagePersonalizationFieldCreateInput = {
    id?: string
    name: string
    min: number
    max?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedOneWithoutImagePersonalizationFieldsInput
  }

  export type ImagePersonalizationFieldUncheckedCreateInput = {
    id?: string
    name: string
    min: number
    max?: number
    productId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImagePersonalizationFieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    min?: IntFieldUpdateOperationsInput | number
    max?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneWithoutImagePersonalizationFieldsNestedInput
  }

  export type ImagePersonalizationFieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    min?: IntFieldUpdateOperationsInput | number
    max?: IntFieldUpdateOperationsInput | number
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImagePersonalizationFieldCreateManyInput = {
    id?: string
    name: string
    min: number
    max?: number
    productId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImagePersonalizationFieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    min?: IntFieldUpdateOperationsInput | number
    max?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImagePersonalizationFieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    min?: IntFieldUpdateOperationsInput | number
    max?: IntFieldUpdateOperationsInput | number
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    code: string
    price: number
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeCreateNestedManyWithoutProductInput
    discount?: DiscountCreateNestedOneWithoutProductsInput
    packageOption?: PackageOptionCreateNestedOneWithoutProductsInput
    coverImage?: MediaCreateNestedOneWithoutProductCoverInput
    images?: MediaCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    ratings?: RatingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    price: number
    discountId?: string | null
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    packageOptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeUncheckedCreateNestedManyWithoutProductInput
    coverImage?: MediaUncheckedCreateNestedOneWithoutProductCoverInput
    images?: MediaUncheckedCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUpdateManyWithoutProductNestedInput
    discount?: DiscountUpdateOneWithoutProductsNestedInput
    packageOption?: PackageOptionUpdateOneWithoutProductsNestedInput
    coverImage?: MediaUpdateOneWithoutProductCoverNestedInput
    images?: MediaUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    ratings?: RatingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    packageOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUncheckedUpdateManyWithoutProductNestedInput
    coverImage?: MediaUncheckedUpdateOneWithoutProductCoverNestedInput
    images?: MediaUncheckedUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    code: string
    price: number
    discountId?: string | null
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    packageOptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    packageOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingCreateInput = {
    id?: string
    name: string
    score: number
    comment: string
    status?: $Enums.RatingStatusType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRatingsInput
    product: ProductCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateInput = {
    id?: string
    userId: string
    productId: string
    name: string
    score: number
    comment: string
    status?: $Enums.RatingStatusType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumRatingStatusTypeFieldUpdateOperationsInput | $Enums.RatingStatusType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRatingsNestedInput
    product?: ProductUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumRatingStatusTypeFieldUpdateOperationsInput | $Enums.RatingStatusType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingCreateManyInput = {
    id?: string
    userId: string
    productId: string
    name: string
    score: number
    comment: string
    status?: $Enums.RatingStatusType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumRatingStatusTypeFieldUpdateOperationsInput | $Enums.RatingStatusType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumRatingStatusTypeFieldUpdateOperationsInput | $Enums.RatingStatusType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    updatedAt?: Date | string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutMediaInput
    category?: CategoryCreateNestedOneWithoutImageInput
    deliveryService?: DeliveryServiceCreateNestedOneWithoutPdfInput
    desktopBannerImage?: BannerCreateNestedOneWithoutDesktopImageInput
    mobileBannerImage?: BannerCreateNestedOneWithoutMobileImageInput
    productCover?: ProductCreateNestedOneWithoutCoverImageInput
    productImages?: ProductCreateNestedOneWithoutImagesInput
    imagePersonalization?: ImagePersonalizationCreateNestedOneWithoutImagesInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    userId?: string | null
    categoryId?: string | null
    deliveryServiceId?: string | null
    desktopBannerImageId?: string | null
    mobileBannerImageId?: string | null
    productCoverId?: string | null
    productImagesId?: string | null
    imagePersonalizationId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMediaNestedInput
    category?: CategoryUpdateOneWithoutImageNestedInput
    deliveryService?: DeliveryServiceUpdateOneWithoutPdfNestedInput
    desktopBannerImage?: BannerUpdateOneWithoutDesktopImageNestedInput
    mobileBannerImage?: BannerUpdateOneWithoutMobileImageNestedInput
    productCover?: ProductUpdateOneWithoutCoverImageNestedInput
    productImages?: ProductUpdateOneWithoutImagesNestedInput
    imagePersonalization?: ImagePersonalizationUpdateOneWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    desktopBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    mobileBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    productCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    productImagesId?: NullableStringFieldUpdateOperationsInput | string | null
    imagePersonalizationId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateManyInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    userId?: string | null
    categoryId?: string | null
    deliveryServiceId?: string | null
    desktopBannerImageId?: string | null
    mobileBannerImageId?: string | null
    productCoverId?: string | null
    productImagesId?: string | null
    imagePersonalizationId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    desktopBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    mobileBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    productCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    productImagesId?: NullableStringFieldUpdateOperationsInput | string | null
    imagePersonalizationId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartCreateInput = {
    id?: string
    onlinePrice: number
    totalPrice: number
    deliveryFee: number
    totalPriceWithDeliveryFee: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCartInput
    items?: CartItemCreateNestedManyWithoutCartInput
    coupon?: CouponCreateNestedOneWithoutCartsInput
  }

  export type CartUncheckedCreateInput = {
    id?: string
    userId: string
    onlinePrice: number
    totalPrice: number
    deliveryFee: number
    totalPriceWithDeliveryFee: number
    discount: number
    couponId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    onlinePrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    totalPriceWithDeliveryFee?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCartNestedInput
    items?: CartItemUpdateManyWithoutCartNestedInput
    coupon?: CouponUpdateOneWithoutCartsNestedInput
  }

  export type CartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    onlinePrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    totalPriceWithDeliveryFee?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartCreateManyInput = {
    id?: string
    userId: string
    onlinePrice: number
    totalPrice: number
    deliveryFee: number
    totalPriceWithDeliveryFee: number
    discount: number
    couponId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    onlinePrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    totalPriceWithDeliveryFee?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    onlinePrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    totalPriceWithDeliveryFee?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateInput = {
    id?: string
    price: number
    deliveryFee: number
    quantity: number
    fontType: $Enums.FontType
    packageOptionSelected: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: CartCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutCartItemsInput
    textPersonalizations?: TextPersonalizationCreateNestedManyWithoutCartItemInput
    imagePersonalizations?: ImagePersonalizationCreateNestedManyWithoutCartItemInput
  }

  export type CartItemUncheckedCreateInput = {
    id?: string
    cartId: string
    productId: string
    price: number
    deliveryFee: number
    quantity: number
    fontType: $Enums.FontType
    packageOptionSelected: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    textPersonalizations?: TextPersonalizationUncheckedCreateNestedManyWithoutCartItemInput
    imagePersonalizations?: ImagePersonalizationUncheckedCreateNestedManyWithoutCartItemInput
  }

  export type CartItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    fontType?: EnumFontTypeFieldUpdateOperationsInput | $Enums.FontType
    packageOptionSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutCartItemsNestedInput
    textPersonalizations?: TextPersonalizationUpdateManyWithoutCartItemNestedInput
    imagePersonalizations?: ImagePersonalizationUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    fontType?: EnumFontTypeFieldUpdateOperationsInput | $Enums.FontType
    packageOptionSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textPersonalizations?: TextPersonalizationUncheckedUpdateManyWithoutCartItemNestedInput
    imagePersonalizations?: ImagePersonalizationUncheckedUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemCreateManyInput = {
    id?: string
    cartId: string
    productId: string
    price: number
    deliveryFee: number
    quantity: number
    fontType: $Enums.FontType
    packageOptionSelected: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    fontType?: EnumFontTypeFieldUpdateOperationsInput | $Enums.FontType
    packageOptionSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    fontType?: EnumFontTypeFieldUpdateOperationsInput | $Enums.FontType
    packageOptionSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextPersonalizationCreateInput = {
    id?: string
    name: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItem?: CartItemCreateNestedOneWithoutTextPersonalizationsInput
  }

  export type TextPersonalizationUncheckedCreateInput = {
    id?: string
    name: string
    value: string
    cartItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TextPersonalizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItem?: CartItemUpdateOneWithoutTextPersonalizationsNestedInput
  }

  export type TextPersonalizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextPersonalizationCreateManyInput = {
    id?: string
    name: string
    value: string
    cartItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TextPersonalizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextPersonalizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImagePersonalizationCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaCreateNestedManyWithoutImagePersonalizationInput
    cartItem?: CartItemCreateNestedOneWithoutImagePersonalizationsInput
  }

  export type ImagePersonalizationUncheckedCreateInput = {
    id?: string
    name: string
    cartItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutImagePersonalizationInput
  }

  export type ImagePersonalizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUpdateManyWithoutImagePersonalizationNestedInput
    cartItem?: CartItemUpdateOneWithoutImagePersonalizationsNestedInput
  }

  export type ImagePersonalizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutImagePersonalizationNestedInput
  }

  export type ImagePersonalizationCreateManyInput = {
    id?: string
    name: string
    cartItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImagePersonalizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImagePersonalizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryAddressCreateInput = {
    id?: string
    name: string
    address: string
    city: string
    zip: string
    phone: string
    email: string
    note?: string | null
    type: $Enums.DeliveryAddressType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDeliveryAddressesInput
  }

  export type DeliveryAddressUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    city: string
    zip: string
    phone: string
    email: string
    note?: string | null
    type: $Enums.DeliveryAddressType
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDeliveryAddressTypeFieldUpdateOperationsInput | $Enums.DeliveryAddressType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDeliveryAddressesNestedInput
  }

  export type DeliveryAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDeliveryAddressTypeFieldUpdateOperationsInput | $Enums.DeliveryAddressType
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryAddressCreateManyInput = {
    id?: string
    name: string
    address: string
    city: string
    zip: string
    phone: string
    email: string
    note?: string | null
    type: $Enums.DeliveryAddressType
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDeliveryAddressTypeFieldUpdateOperationsInput | $Enums.DeliveryAddressType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDeliveryAddressTypeFieldUpdateOperationsInput | $Enums.DeliveryAddressType
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    orderNumber: string
    termsAccepted?: boolean
    shippingNumber?: string
    deliveryType: $Enums.OrderDeliveryType
    paymentType: $Enums.OrderPaymentType
    status?: $Enums.OrderStatusType
    mediaRemoved?: boolean
    paymentId?: string | null
    paymentStatus?: $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode?: string | null
    paymentStatusCode?: string | null
    paymentTimestamp?: string | null
    paymentAmount?: string | null
    paymentCurrency?: string | null
    paymentBrand?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    checkoutId?: string | null
    cart: JsonNullValueInput | InputJsonValue
    deliveryName?: string
    deliveryAddress?: string
    deliveryCity?: string
    deliveryZip?: string
    deliveryPhone?: string
    deliveryEmail?: string
    deliveryNote?: string
    pickupName?: string
    pickupPhone?: string
    pickupEmail?: string
    billingName?: string
    billingAddress?: string
    billingCity?: string
    billingZip?: string
    billingPhone?: string
    billingEmail?: string
    billingNote?: string
    deliveryServiceName?: string
    orderOnlinePrice: number
    orderDiscount: number
    orderDeliveryFee: number
    orderTotalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    termsAccepted?: boolean
    shippingNumber?: string
    deliveryType: $Enums.OrderDeliveryType
    paymentType: $Enums.OrderPaymentType
    status?: $Enums.OrderStatusType
    mediaRemoved?: boolean
    paymentId?: string | null
    paymentStatus?: $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode?: string | null
    paymentStatusCode?: string | null
    paymentTimestamp?: string | null
    paymentAmount?: string | null
    paymentCurrency?: string | null
    paymentBrand?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    checkoutId?: string | null
    cart: JsonNullValueInput | InputJsonValue
    deliveryName?: string
    deliveryAddress?: string
    deliveryCity?: string
    deliveryZip?: string
    deliveryPhone?: string
    deliveryEmail?: string
    deliveryNote?: string
    pickupName?: string
    pickupPhone?: string
    pickupEmail?: string
    billingName?: string
    billingAddress?: string
    billingCity?: string
    billingZip?: string
    billingPhone?: string
    billingEmail?: string
    billingNote?: string
    deliveryServiceName?: string
    orderOnlinePrice: number
    orderDiscount: number
    orderDeliveryFee: number
    orderTotalPrice: number
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    shippingNumber?: StringFieldUpdateOperationsInput | string
    deliveryType?: EnumOrderDeliveryTypeFieldUpdateOperationsInput | $Enums.OrderDeliveryType
    paymentType?: EnumOrderPaymentTypeFieldUpdateOperationsInput | $Enums.OrderPaymentType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    mediaRemoved?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableEnumOrderPaymentStatusTypeFieldUpdateOperationsInput | $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatusCode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTimestamp?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBrand?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    checkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    cart?: JsonNullValueInput | InputJsonValue
    deliveryName?: StringFieldUpdateOperationsInput | string
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    deliveryCity?: StringFieldUpdateOperationsInput | string
    deliveryZip?: StringFieldUpdateOperationsInput | string
    deliveryPhone?: StringFieldUpdateOperationsInput | string
    deliveryEmail?: StringFieldUpdateOperationsInput | string
    deliveryNote?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhone?: StringFieldUpdateOperationsInput | string
    pickupEmail?: StringFieldUpdateOperationsInput | string
    billingName?: StringFieldUpdateOperationsInput | string
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingZip?: StringFieldUpdateOperationsInput | string
    billingPhone?: StringFieldUpdateOperationsInput | string
    billingEmail?: StringFieldUpdateOperationsInput | string
    billingNote?: StringFieldUpdateOperationsInput | string
    deliveryServiceName?: StringFieldUpdateOperationsInput | string
    orderOnlinePrice?: IntFieldUpdateOperationsInput | number
    orderDiscount?: IntFieldUpdateOperationsInput | number
    orderDeliveryFee?: IntFieldUpdateOperationsInput | number
    orderTotalPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    shippingNumber?: StringFieldUpdateOperationsInput | string
    deliveryType?: EnumOrderDeliveryTypeFieldUpdateOperationsInput | $Enums.OrderDeliveryType
    paymentType?: EnumOrderPaymentTypeFieldUpdateOperationsInput | $Enums.OrderPaymentType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    mediaRemoved?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableEnumOrderPaymentStatusTypeFieldUpdateOperationsInput | $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatusCode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTimestamp?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBrand?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    checkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    cart?: JsonNullValueInput | InputJsonValue
    deliveryName?: StringFieldUpdateOperationsInput | string
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    deliveryCity?: StringFieldUpdateOperationsInput | string
    deliveryZip?: StringFieldUpdateOperationsInput | string
    deliveryPhone?: StringFieldUpdateOperationsInput | string
    deliveryEmail?: StringFieldUpdateOperationsInput | string
    deliveryNote?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhone?: StringFieldUpdateOperationsInput | string
    pickupEmail?: StringFieldUpdateOperationsInput | string
    billingName?: StringFieldUpdateOperationsInput | string
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingZip?: StringFieldUpdateOperationsInput | string
    billingPhone?: StringFieldUpdateOperationsInput | string
    billingEmail?: StringFieldUpdateOperationsInput | string
    billingNote?: StringFieldUpdateOperationsInput | string
    deliveryServiceName?: StringFieldUpdateOperationsInput | string
    orderOnlinePrice?: IntFieldUpdateOperationsInput | number
    orderDiscount?: IntFieldUpdateOperationsInput | number
    orderDeliveryFee?: IntFieldUpdateOperationsInput | number
    orderTotalPrice?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyInput = {
    id?: string
    orderNumber: string
    termsAccepted?: boolean
    shippingNumber?: string
    deliveryType: $Enums.OrderDeliveryType
    paymentType: $Enums.OrderPaymentType
    status?: $Enums.OrderStatusType
    mediaRemoved?: boolean
    paymentId?: string | null
    paymentStatus?: $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode?: string | null
    paymentStatusCode?: string | null
    paymentTimestamp?: string | null
    paymentAmount?: string | null
    paymentCurrency?: string | null
    paymentBrand?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    checkoutId?: string | null
    cart: JsonNullValueInput | InputJsonValue
    deliveryName?: string
    deliveryAddress?: string
    deliveryCity?: string
    deliveryZip?: string
    deliveryPhone?: string
    deliveryEmail?: string
    deliveryNote?: string
    pickupName?: string
    pickupPhone?: string
    pickupEmail?: string
    billingName?: string
    billingAddress?: string
    billingCity?: string
    billingZip?: string
    billingPhone?: string
    billingEmail?: string
    billingNote?: string
    deliveryServiceName?: string
    orderOnlinePrice: number
    orderDiscount: number
    orderDeliveryFee: number
    orderTotalPrice: number
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    shippingNumber?: StringFieldUpdateOperationsInput | string
    deliveryType?: EnumOrderDeliveryTypeFieldUpdateOperationsInput | $Enums.OrderDeliveryType
    paymentType?: EnumOrderPaymentTypeFieldUpdateOperationsInput | $Enums.OrderPaymentType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    mediaRemoved?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableEnumOrderPaymentStatusTypeFieldUpdateOperationsInput | $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatusCode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTimestamp?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBrand?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    checkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    cart?: JsonNullValueInput | InputJsonValue
    deliveryName?: StringFieldUpdateOperationsInput | string
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    deliveryCity?: StringFieldUpdateOperationsInput | string
    deliveryZip?: StringFieldUpdateOperationsInput | string
    deliveryPhone?: StringFieldUpdateOperationsInput | string
    deliveryEmail?: StringFieldUpdateOperationsInput | string
    deliveryNote?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhone?: StringFieldUpdateOperationsInput | string
    pickupEmail?: StringFieldUpdateOperationsInput | string
    billingName?: StringFieldUpdateOperationsInput | string
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingZip?: StringFieldUpdateOperationsInput | string
    billingPhone?: StringFieldUpdateOperationsInput | string
    billingEmail?: StringFieldUpdateOperationsInput | string
    billingNote?: StringFieldUpdateOperationsInput | string
    deliveryServiceName?: StringFieldUpdateOperationsInput | string
    orderOnlinePrice?: IntFieldUpdateOperationsInput | number
    orderDiscount?: IntFieldUpdateOperationsInput | number
    orderDeliveryFee?: IntFieldUpdateOperationsInput | number
    orderTotalPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    shippingNumber?: StringFieldUpdateOperationsInput | string
    deliveryType?: EnumOrderDeliveryTypeFieldUpdateOperationsInput | $Enums.OrderDeliveryType
    paymentType?: EnumOrderPaymentTypeFieldUpdateOperationsInput | $Enums.OrderPaymentType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    mediaRemoved?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableEnumOrderPaymentStatusTypeFieldUpdateOperationsInput | $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatusCode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTimestamp?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBrand?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    checkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    cart?: JsonNullValueInput | InputJsonValue
    deliveryName?: StringFieldUpdateOperationsInput | string
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    deliveryCity?: StringFieldUpdateOperationsInput | string
    deliveryZip?: StringFieldUpdateOperationsInput | string
    deliveryPhone?: StringFieldUpdateOperationsInput | string
    deliveryEmail?: StringFieldUpdateOperationsInput | string
    deliveryNote?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhone?: StringFieldUpdateOperationsInput | string
    pickupEmail?: StringFieldUpdateOperationsInput | string
    billingName?: StringFieldUpdateOperationsInput | string
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingZip?: StringFieldUpdateOperationsInput | string
    billingPhone?: StringFieldUpdateOperationsInput | string
    billingEmail?: StringFieldUpdateOperationsInput | string
    billingNote?: StringFieldUpdateOperationsInput | string
    deliveryServiceName?: StringFieldUpdateOperationsInput | string
    orderOnlinePrice?: IntFieldUpdateOperationsInput | number
    orderDiscount?: IntFieldUpdateOperationsInput | number
    orderDeliveryFee?: IntFieldUpdateOperationsInput | number
    orderTotalPrice?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.UserRoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    media?: MediaCreateNestedManyWithoutUserInput
    cart?: CartCreateNestedOneWithoutUserInput
    deliveryAddresses?: DeliveryAddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.UserRoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    media?: MediaUncheckedCreateNestedManyWithoutUserInput
    cart?: CartUncheckedCreateNestedOneWithoutUserInput
    deliveryAddresses?: DeliveryAddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: MediaUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneWithoutUserNestedInput
    deliveryAddresses?: DeliveryAddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: MediaUncheckedUpdateManyWithoutUserNestedInput
    cart?: CartUncheckedUpdateOneWithoutUserNestedInput
    deliveryAddresses?: DeliveryAddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.UserRoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateInput = {
    id: string
    scope?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id: string
    userId: string
    scope?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id: string
    userId: string
    scope?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateManyInput = {
    id: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MediaNullableScalarRelationFilter = {
    is?: MediaWhereInput | null
    isNot?: MediaWhereInput | null
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    active?: SortOrder
    special?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    active?: SortOrder
    special?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    active?: SortOrder
    special?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type PackageOptionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageOptionAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PackageOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageOptionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageOptionSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type DeliveryServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    active?: SortOrder
    predefinedPrices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    active?: SortOrder
    predefinedPrices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    active?: SortOrder
    predefinedPrices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type CartListRelationFilter = {
    every?: CartWhereInput
    some?: CartWhereInput
    none?: CartWhereInput
  }

  export type CartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CouponCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    discountType?: SortOrder
    discount?: SortOrder
    cartValue?: SortOrder
    available?: SortOrder
    used?: SortOrder
    active?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponAvgOrderByAggregateInput = {
    discount?: SortOrder
    cartValue?: SortOrder
    available?: SortOrder
    used?: SortOrder
  }

  export type CouponMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    discountType?: SortOrder
    discount?: SortOrder
    cartValue?: SortOrder
    available?: SortOrder
    used?: SortOrder
    active?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    discountType?: SortOrder
    discount?: SortOrder
    cartValue?: SortOrder
    available?: SortOrder
    used?: SortOrder
    active?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponSumOrderByAggregateInput = {
    discount?: SortOrder
    cartValue?: SortOrder
    available?: SortOrder
    used?: SortOrder
  }

  export type EnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type PriceRangeListRelationFilter = {
    every?: PriceRangeWhereInput
    some?: PriceRangeWhereInput
    none?: PriceRangeWhereInput
  }

  export type PriceRangeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryFeeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryFeeAvgOrderByAggregateInput = {
    fee?: SortOrder
  }

  export type DeliveryFeeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryFeeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryFeeSumOrderByAggregateInput = {
    fee?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DeliveryFeeScalarRelationFilter = {
    is?: DeliveryFeeWhereInput
    isNot?: DeliveryFeeWhereInput
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PriceRangeCountOrderByAggregateInput = {
    id?: SortOrder
    from?: SortOrder
    to?: SortOrder
    price?: SortOrder
    deliveryFeeId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceRangeAvgOrderByAggregateInput = {
    from?: SortOrder
    to?: SortOrder
    price?: SortOrder
  }

  export type PriceRangeMaxOrderByAggregateInput = {
    id?: SortOrder
    from?: SortOrder
    to?: SortOrder
    price?: SortOrder
    deliveryFeeId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceRangeMinOrderByAggregateInput = {
    id?: SortOrder
    from?: SortOrder
    to?: SortOrder
    price?: SortOrder
    deliveryFeeId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceRangeSumOrderByAggregateInput = {
    from?: SortOrder
    to?: SortOrder
    price?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DiscountCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    percentage?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountAvgOrderByAggregateInput = {
    percentage?: SortOrder
  }

  export type DiscountMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    percentage?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    percentage?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountSumOrderByAggregateInput = {
    percentage?: SortOrder
  }

  export type TextPersonalizationFieldCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    placeholder?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TextPersonalizationFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    placeholder?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TextPersonalizationFieldMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    placeholder?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImagePersonalizationFieldCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    min?: SortOrder
    max?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImagePersonalizationFieldAvgOrderByAggregateInput = {
    min?: SortOrder
    max?: SortOrder
  }

  export type ImagePersonalizationFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    min?: SortOrder
    max?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImagePersonalizationFieldMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    min?: SortOrder
    max?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImagePersonalizationFieldSumOrderByAggregateInput = {
    min?: SortOrder
    max?: SortOrder
  }

  export type EnumDeliveryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryType | EnumDeliveryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryTypeFilter<$PrismaModel> | $Enums.DeliveryType
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type DiscountNullableScalarRelationFilter = {
    is?: DiscountWhereInput | null
    isNot?: DiscountWhereInput | null
  }

  export type PackageOptionNullableScalarRelationFilter = {
    is?: PackageOptionWhereInput | null
    isNot?: PackageOptionWhereInput | null
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type ImagePersonalizationFieldListRelationFilter = {
    every?: ImagePersonalizationFieldWhereInput
    some?: ImagePersonalizationFieldWhereInput
    none?: ImagePersonalizationFieldWhereInput
  }

  export type TextPersonalizationFieldListRelationFilter = {
    every?: TextPersonalizationFieldWhereInput
    some?: TextPersonalizationFieldWhereInput
    none?: TextPersonalizationFieldWhereInput
  }

  export type CartItemListRelationFilter = {
    every?: CartItemWhereInput
    some?: CartItemWhereInput
    none?: CartItemWhereInput
  }

  export type RatingListRelationFilter = {
    every?: RatingWhereInput
    some?: RatingWhereInput
    none?: RatingWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImagePersonalizationFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TextPersonalizationFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    price?: SortOrder
    discountId?: SortOrder
    material?: SortOrder
    dimensions?: SortOrder
    personalization?: SortOrder
    description?: SortOrder
    delivery?: SortOrder
    inStock?: SortOrder
    trending?: SortOrder
    packageOptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    price?: SortOrder
    discountId?: SortOrder
    material?: SortOrder
    dimensions?: SortOrder
    personalization?: SortOrder
    description?: SortOrder
    delivery?: SortOrder
    inStock?: SortOrder
    trending?: SortOrder
    packageOptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    price?: SortOrder
    discountId?: SortOrder
    material?: SortOrder
    dimensions?: SortOrder
    personalization?: SortOrder
    description?: SortOrder
    delivery?: SortOrder
    inStock?: SortOrder
    trending?: SortOrder
    packageOptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumDeliveryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryType | EnumDeliveryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryTypeFilter<$PrismaModel>
    _max?: NestedEnumDeliveryTypeFilter<$PrismaModel>
  }

  export type EnumRatingStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RatingStatusType | EnumRatingStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RatingStatusType[] | ListEnumRatingStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RatingStatusType[] | ListEnumRatingStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRatingStatusTypeFilter<$PrismaModel> | $Enums.RatingStatusType
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type RatingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    score?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RatingAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type RatingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    score?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RatingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    score?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RatingSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type EnumRatingStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RatingStatusType | EnumRatingStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RatingStatusType[] | ListEnumRatingStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RatingStatusType[] | ListEnumRatingStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRatingStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.RatingStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRatingStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumRatingStatusTypeFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type DeliveryServiceNullableScalarRelationFilter = {
    is?: DeliveryServiceWhereInput | null
    isNot?: DeliveryServiceWhereInput | null
  }

  export type BannerNullableScalarRelationFilter = {
    is?: BannerWhereInput | null
    isNot?: BannerWhereInput | null
  }

  export type ImagePersonalizationNullableScalarRelationFilter = {
    is?: ImagePersonalizationWhereInput | null
    isNot?: ImagePersonalizationWhereInput | null
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    type?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    deliveryServiceId?: SortOrder
    desktopBannerImageId?: SortOrder
    mobileBannerImageId?: SortOrder
    productCoverId?: SortOrder
    productImagesId?: SortOrder
    imagePersonalizationId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    type?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    deliveryServiceId?: SortOrder
    desktopBannerImageId?: SortOrder
    mobileBannerImageId?: SortOrder
    productCoverId?: SortOrder
    productImagesId?: SortOrder
    imagePersonalizationId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    type?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    deliveryServiceId?: SortOrder
    desktopBannerImageId?: SortOrder
    mobileBannerImageId?: SortOrder
    productCoverId?: SortOrder
    productImagesId?: SortOrder
    imagePersonalizationId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CouponNullableScalarRelationFilter = {
    is?: CouponWhereInput | null
    isNot?: CouponWhereInput | null
  }

  export type CartCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    onlinePrice?: SortOrder
    totalPrice?: SortOrder
    deliveryFee?: SortOrder
    totalPriceWithDeliveryFee?: SortOrder
    discount?: SortOrder
    couponId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartAvgOrderByAggregateInput = {
    onlinePrice?: SortOrder
    totalPrice?: SortOrder
    deliveryFee?: SortOrder
    totalPriceWithDeliveryFee?: SortOrder
    discount?: SortOrder
  }

  export type CartMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    onlinePrice?: SortOrder
    totalPrice?: SortOrder
    deliveryFee?: SortOrder
    totalPriceWithDeliveryFee?: SortOrder
    discount?: SortOrder
    couponId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    onlinePrice?: SortOrder
    totalPrice?: SortOrder
    deliveryFee?: SortOrder
    totalPriceWithDeliveryFee?: SortOrder
    discount?: SortOrder
    couponId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartSumOrderByAggregateInput = {
    onlinePrice?: SortOrder
    totalPrice?: SortOrder
    deliveryFee?: SortOrder
    totalPriceWithDeliveryFee?: SortOrder
    discount?: SortOrder
  }

  export type EnumFontTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FontType | EnumFontTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FontType[] | ListEnumFontTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FontType[] | ListEnumFontTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFontTypeFilter<$PrismaModel> | $Enums.FontType
  }

  export type CartScalarRelationFilter = {
    is?: CartWhereInput
    isNot?: CartWhereInput
  }

  export type TextPersonalizationListRelationFilter = {
    every?: TextPersonalizationWhereInput
    some?: TextPersonalizationWhereInput
    none?: TextPersonalizationWhereInput
  }

  export type ImagePersonalizationListRelationFilter = {
    every?: ImagePersonalizationWhereInput
    some?: ImagePersonalizationWhereInput
    none?: ImagePersonalizationWhereInput
  }

  export type TextPersonalizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImagePersonalizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartItemCountOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    deliveryFee?: SortOrder
    quantity?: SortOrder
    fontType?: SortOrder
    packageOptionSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemAvgOrderByAggregateInput = {
    price?: SortOrder
    deliveryFee?: SortOrder
    quantity?: SortOrder
  }

  export type CartItemMaxOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    deliveryFee?: SortOrder
    quantity?: SortOrder
    fontType?: SortOrder
    packageOptionSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemMinOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    deliveryFee?: SortOrder
    quantity?: SortOrder
    fontType?: SortOrder
    packageOptionSelected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemSumOrderByAggregateInput = {
    price?: SortOrder
    deliveryFee?: SortOrder
    quantity?: SortOrder
  }

  export type EnumFontTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FontType | EnumFontTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FontType[] | ListEnumFontTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FontType[] | ListEnumFontTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFontTypeWithAggregatesFilter<$PrismaModel> | $Enums.FontType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFontTypeFilter<$PrismaModel>
    _max?: NestedEnumFontTypeFilter<$PrismaModel>
  }

  export type CartItemNullableScalarRelationFilter = {
    is?: CartItemWhereInput | null
    isNot?: CartItemWhereInput | null
  }

  export type TextPersonalizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    cartItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TextPersonalizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    cartItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TextPersonalizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    cartItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImagePersonalizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cartItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImagePersonalizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cartItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImagePersonalizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cartItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDeliveryAddressTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryAddressType | EnumDeliveryAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryAddressType[] | ListEnumDeliveryAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryAddressType[] | ListEnumDeliveryAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryAddressTypeFilter<$PrismaModel> | $Enums.DeliveryAddressType
  }

  export type DeliveryAddressCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zip?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    note?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zip?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    note?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryAddressMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zip?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    note?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDeliveryAddressTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryAddressType | EnumDeliveryAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryAddressType[] | ListEnumDeliveryAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryAddressType[] | ListEnumDeliveryAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryAddressTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryAddressType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryAddressTypeFilter<$PrismaModel>
    _max?: NestedEnumDeliveryAddressTypeFilter<$PrismaModel>
  }

  export type EnumOrderDeliveryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderDeliveryType | EnumOrderDeliveryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderDeliveryType[] | ListEnumOrderDeliveryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderDeliveryType[] | ListEnumOrderDeliveryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderDeliveryTypeFilter<$PrismaModel> | $Enums.OrderDeliveryType
  }

  export type EnumOrderPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderPaymentType | EnumOrderPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderPaymentType[] | ListEnumOrderPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderPaymentType[] | ListEnumOrderPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderPaymentTypeFilter<$PrismaModel> | $Enums.OrderPaymentType
  }

  export type EnumOrderStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatusType | EnumOrderStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatusType[] | ListEnumOrderStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatusType[] | ListEnumOrderStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusTypeFilter<$PrismaModel> | $Enums.OrderStatusType
  }

  export type EnumOrderPaymentStatusTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderPaymentStatusType | EnumOrderPaymentStatusTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderPaymentStatusType[] | ListEnumOrderPaymentStatusTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderPaymentStatusType[] | ListEnumOrderPaymentStatusTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderPaymentStatusTypeNullableFilter<$PrismaModel> | $Enums.OrderPaymentStatusType | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    termsAccepted?: SortOrder
    shippingNumber?: SortOrder
    deliveryType?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    mediaRemoved?: SortOrder
    paymentId?: SortOrder
    paymentStatus?: SortOrder
    paymentAuthorizationCode?: SortOrder
    paymentStatusCode?: SortOrder
    paymentTimestamp?: SortOrder
    paymentAmount?: SortOrder
    paymentCurrency?: SortOrder
    paymentBrand?: SortOrder
    paymentDetails?: SortOrder
    checkoutId?: SortOrder
    cart?: SortOrder
    deliveryName?: SortOrder
    deliveryAddress?: SortOrder
    deliveryCity?: SortOrder
    deliveryZip?: SortOrder
    deliveryPhone?: SortOrder
    deliveryEmail?: SortOrder
    deliveryNote?: SortOrder
    pickupName?: SortOrder
    pickupPhone?: SortOrder
    pickupEmail?: SortOrder
    billingName?: SortOrder
    billingAddress?: SortOrder
    billingCity?: SortOrder
    billingZip?: SortOrder
    billingPhone?: SortOrder
    billingEmail?: SortOrder
    billingNote?: SortOrder
    deliveryServiceName?: SortOrder
    orderOnlinePrice?: SortOrder
    orderDiscount?: SortOrder
    orderDeliveryFee?: SortOrder
    orderTotalPrice?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    orderOnlinePrice?: SortOrder
    orderDiscount?: SortOrder
    orderDeliveryFee?: SortOrder
    orderTotalPrice?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    termsAccepted?: SortOrder
    shippingNumber?: SortOrder
    deliveryType?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    mediaRemoved?: SortOrder
    paymentId?: SortOrder
    paymentStatus?: SortOrder
    paymentAuthorizationCode?: SortOrder
    paymentStatusCode?: SortOrder
    paymentTimestamp?: SortOrder
    paymentAmount?: SortOrder
    paymentCurrency?: SortOrder
    paymentBrand?: SortOrder
    checkoutId?: SortOrder
    deliveryName?: SortOrder
    deliveryAddress?: SortOrder
    deliveryCity?: SortOrder
    deliveryZip?: SortOrder
    deliveryPhone?: SortOrder
    deliveryEmail?: SortOrder
    deliveryNote?: SortOrder
    pickupName?: SortOrder
    pickupPhone?: SortOrder
    pickupEmail?: SortOrder
    billingName?: SortOrder
    billingAddress?: SortOrder
    billingCity?: SortOrder
    billingZip?: SortOrder
    billingPhone?: SortOrder
    billingEmail?: SortOrder
    billingNote?: SortOrder
    deliveryServiceName?: SortOrder
    orderOnlinePrice?: SortOrder
    orderDiscount?: SortOrder
    orderDeliveryFee?: SortOrder
    orderTotalPrice?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    termsAccepted?: SortOrder
    shippingNumber?: SortOrder
    deliveryType?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    mediaRemoved?: SortOrder
    paymentId?: SortOrder
    paymentStatus?: SortOrder
    paymentAuthorizationCode?: SortOrder
    paymentStatusCode?: SortOrder
    paymentTimestamp?: SortOrder
    paymentAmount?: SortOrder
    paymentCurrency?: SortOrder
    paymentBrand?: SortOrder
    checkoutId?: SortOrder
    deliveryName?: SortOrder
    deliveryAddress?: SortOrder
    deliveryCity?: SortOrder
    deliveryZip?: SortOrder
    deliveryPhone?: SortOrder
    deliveryEmail?: SortOrder
    deliveryNote?: SortOrder
    pickupName?: SortOrder
    pickupPhone?: SortOrder
    pickupEmail?: SortOrder
    billingName?: SortOrder
    billingAddress?: SortOrder
    billingCity?: SortOrder
    billingZip?: SortOrder
    billingPhone?: SortOrder
    billingEmail?: SortOrder
    billingNote?: SortOrder
    deliveryServiceName?: SortOrder
    orderOnlinePrice?: SortOrder
    orderDiscount?: SortOrder
    orderDeliveryFee?: SortOrder
    orderTotalPrice?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    orderOnlinePrice?: SortOrder
    orderDiscount?: SortOrder
    orderDeliveryFee?: SortOrder
    orderTotalPrice?: SortOrder
  }

  export type EnumOrderDeliveryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderDeliveryType | EnumOrderDeliveryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderDeliveryType[] | ListEnumOrderDeliveryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderDeliveryType[] | ListEnumOrderDeliveryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderDeliveryTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderDeliveryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderDeliveryTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderDeliveryTypeFilter<$PrismaModel>
  }

  export type EnumOrderPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderPaymentType | EnumOrderPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderPaymentType[] | ListEnumOrderPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderPaymentType[] | ListEnumOrderPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderPaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderPaymentTypeFilter<$PrismaModel>
  }

  export type EnumOrderStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatusType | EnumOrderStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatusType[] | ListEnumOrderStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatusType[] | ListEnumOrderStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusTypeFilter<$PrismaModel>
  }

  export type EnumOrderPaymentStatusTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderPaymentStatusType | EnumOrderPaymentStatusTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderPaymentStatusType[] | ListEnumOrderPaymentStatusTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderPaymentStatusType[] | ListEnumOrderPaymentStatusTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderPaymentStatusTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderPaymentStatusType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderPaymentStatusTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderPaymentStatusTypeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumUserRoleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRoleType | EnumUserRoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserRoleType[] | ListEnumUserRoleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRoleType[] | ListEnumUserRoleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleTypeFilter<$PrismaModel> | $Enums.UserRoleType
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CartNullableScalarRelationFilter = {
    is?: CartWhereInput | null
    isNot?: CartWhereInput | null
  }

  export type DeliveryAddressListRelationFilter = {
    every?: DeliveryAddressWhereInput
    some?: DeliveryAddressWhereInput
    none?: DeliveryAddressWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type DeliveryAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
  }

  export type EnumUserRoleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRoleType | EnumUserRoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserRoleType[] | ListEnumUserRoleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRoleType[] | ListEnumUserRoleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserRoleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleTypeFilter<$PrismaModel>
    _max?: NestedEnumUserRoleTypeFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    password?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    password?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    password?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    impersonatedBy?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    impersonatedBy?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    impersonatedBy?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaCreateNestedOneWithoutCategoryInput = {
    create?: XOR<MediaCreateWithoutCategoryInput, MediaUncheckedCreateWithoutCategoryInput>
    connectOrCreate?: MediaCreateOrConnectWithoutCategoryInput
    connect?: MediaWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput> | ProductCreateWithoutCategoriesInput[] | ProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput | ProductCreateOrConnectWithoutCategoriesInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedOneWithoutCategoryInput = {
    create?: XOR<MediaCreateWithoutCategoryInput, MediaUncheckedCreateWithoutCategoryInput>
    connectOrCreate?: MediaCreateOrConnectWithoutCategoryInput
    connect?: MediaWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput> | ProductCreateWithoutCategoriesInput[] | ProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput | ProductCreateOrConnectWithoutCategoriesInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MediaUpdateOneWithoutCategoryNestedInput = {
    create?: XOR<MediaCreateWithoutCategoryInput, MediaUncheckedCreateWithoutCategoryInput>
    connectOrCreate?: MediaCreateOrConnectWithoutCategoryInput
    upsert?: MediaUpsertWithoutCategoryInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutCategoryInput, MediaUpdateWithoutCategoryInput>, MediaUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput> | ProductCreateWithoutCategoriesInput[] | ProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput | ProductCreateOrConnectWithoutCategoriesInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoriesInput | ProductUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoriesInput | ProductUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoriesInput | ProductUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type MediaUncheckedUpdateOneWithoutCategoryNestedInput = {
    create?: XOR<MediaCreateWithoutCategoryInput, MediaUncheckedCreateWithoutCategoryInput>
    connectOrCreate?: MediaCreateOrConnectWithoutCategoryInput
    upsert?: MediaUpsertWithoutCategoryInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutCategoryInput, MediaUpdateWithoutCategoryInput>, MediaUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput> | ProductCreateWithoutCategoriesInput[] | ProductUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput | ProductCreateOrConnectWithoutCategoriesInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoriesInput | ProductUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoriesInput | ProductUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoriesInput | ProductUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutPackageOptionInput = {
    create?: XOR<ProductCreateWithoutPackageOptionInput, ProductUncheckedCreateWithoutPackageOptionInput> | ProductCreateWithoutPackageOptionInput[] | ProductUncheckedCreateWithoutPackageOptionInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPackageOptionInput | ProductCreateOrConnectWithoutPackageOptionInput[]
    createMany?: ProductCreateManyPackageOptionInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutPackageOptionInput = {
    create?: XOR<ProductCreateWithoutPackageOptionInput, ProductUncheckedCreateWithoutPackageOptionInput> | ProductCreateWithoutPackageOptionInput[] | ProductUncheckedCreateWithoutPackageOptionInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPackageOptionInput | ProductCreateOrConnectWithoutPackageOptionInput[]
    createMany?: ProductCreateManyPackageOptionInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutPackageOptionNestedInput = {
    create?: XOR<ProductCreateWithoutPackageOptionInput, ProductUncheckedCreateWithoutPackageOptionInput> | ProductCreateWithoutPackageOptionInput[] | ProductUncheckedCreateWithoutPackageOptionInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPackageOptionInput | ProductCreateOrConnectWithoutPackageOptionInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutPackageOptionInput | ProductUpsertWithWhereUniqueWithoutPackageOptionInput[]
    createMany?: ProductCreateManyPackageOptionInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutPackageOptionInput | ProductUpdateWithWhereUniqueWithoutPackageOptionInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutPackageOptionInput | ProductUpdateManyWithWhereWithoutPackageOptionInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutPackageOptionNestedInput = {
    create?: XOR<ProductCreateWithoutPackageOptionInput, ProductUncheckedCreateWithoutPackageOptionInput> | ProductCreateWithoutPackageOptionInput[] | ProductUncheckedCreateWithoutPackageOptionInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPackageOptionInput | ProductCreateOrConnectWithoutPackageOptionInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutPackageOptionInput | ProductUpsertWithWhereUniqueWithoutPackageOptionInput[]
    createMany?: ProductCreateManyPackageOptionInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutPackageOptionInput | ProductUpdateWithWhereUniqueWithoutPackageOptionInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutPackageOptionInput | ProductUpdateManyWithWhereWithoutPackageOptionInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type MediaCreateNestedOneWithoutDeliveryServiceInput = {
    create?: XOR<MediaCreateWithoutDeliveryServiceInput, MediaUncheckedCreateWithoutDeliveryServiceInput>
    connectOrCreate?: MediaCreateOrConnectWithoutDeliveryServiceInput
    connect?: MediaWhereUniqueInput
  }

  export type MediaUncheckedCreateNestedOneWithoutDeliveryServiceInput = {
    create?: XOR<MediaCreateWithoutDeliveryServiceInput, MediaUncheckedCreateWithoutDeliveryServiceInput>
    connectOrCreate?: MediaCreateOrConnectWithoutDeliveryServiceInput
    connect?: MediaWhereUniqueInput
  }

  export type MediaUpdateOneWithoutDeliveryServiceNestedInput = {
    create?: XOR<MediaCreateWithoutDeliveryServiceInput, MediaUncheckedCreateWithoutDeliveryServiceInput>
    connectOrCreate?: MediaCreateOrConnectWithoutDeliveryServiceInput
    upsert?: MediaUpsertWithoutDeliveryServiceInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutDeliveryServiceInput, MediaUpdateWithoutDeliveryServiceInput>, MediaUncheckedUpdateWithoutDeliveryServiceInput>
  }

  export type MediaUncheckedUpdateOneWithoutDeliveryServiceNestedInput = {
    create?: XOR<MediaCreateWithoutDeliveryServiceInput, MediaUncheckedCreateWithoutDeliveryServiceInput>
    connectOrCreate?: MediaCreateOrConnectWithoutDeliveryServiceInput
    upsert?: MediaUpsertWithoutDeliveryServiceInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutDeliveryServiceInput, MediaUpdateWithoutDeliveryServiceInput>, MediaUncheckedUpdateWithoutDeliveryServiceInput>
  }

  export type MediaCreateNestedOneWithoutDesktopBannerImageInput = {
    create?: XOR<MediaCreateWithoutDesktopBannerImageInput, MediaUncheckedCreateWithoutDesktopBannerImageInput>
    connectOrCreate?: MediaCreateOrConnectWithoutDesktopBannerImageInput
    connect?: MediaWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutMobileBannerImageInput = {
    create?: XOR<MediaCreateWithoutMobileBannerImageInput, MediaUncheckedCreateWithoutMobileBannerImageInput>
    connectOrCreate?: MediaCreateOrConnectWithoutMobileBannerImageInput
    connect?: MediaWhereUniqueInput
  }

  export type MediaUncheckedCreateNestedOneWithoutDesktopBannerImageInput = {
    create?: XOR<MediaCreateWithoutDesktopBannerImageInput, MediaUncheckedCreateWithoutDesktopBannerImageInput>
    connectOrCreate?: MediaCreateOrConnectWithoutDesktopBannerImageInput
    connect?: MediaWhereUniqueInput
  }

  export type MediaUncheckedCreateNestedOneWithoutMobileBannerImageInput = {
    create?: XOR<MediaCreateWithoutMobileBannerImageInput, MediaUncheckedCreateWithoutMobileBannerImageInput>
    connectOrCreate?: MediaCreateOrConnectWithoutMobileBannerImageInput
    connect?: MediaWhereUniqueInput
  }

  export type MediaUpdateOneWithoutDesktopBannerImageNestedInput = {
    create?: XOR<MediaCreateWithoutDesktopBannerImageInput, MediaUncheckedCreateWithoutDesktopBannerImageInput>
    connectOrCreate?: MediaCreateOrConnectWithoutDesktopBannerImageInput
    upsert?: MediaUpsertWithoutDesktopBannerImageInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutDesktopBannerImageInput, MediaUpdateWithoutDesktopBannerImageInput>, MediaUncheckedUpdateWithoutDesktopBannerImageInput>
  }

  export type MediaUpdateOneWithoutMobileBannerImageNestedInput = {
    create?: XOR<MediaCreateWithoutMobileBannerImageInput, MediaUncheckedCreateWithoutMobileBannerImageInput>
    connectOrCreate?: MediaCreateOrConnectWithoutMobileBannerImageInput
    upsert?: MediaUpsertWithoutMobileBannerImageInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutMobileBannerImageInput, MediaUpdateWithoutMobileBannerImageInput>, MediaUncheckedUpdateWithoutMobileBannerImageInput>
  }

  export type MediaUncheckedUpdateOneWithoutDesktopBannerImageNestedInput = {
    create?: XOR<MediaCreateWithoutDesktopBannerImageInput, MediaUncheckedCreateWithoutDesktopBannerImageInput>
    connectOrCreate?: MediaCreateOrConnectWithoutDesktopBannerImageInput
    upsert?: MediaUpsertWithoutDesktopBannerImageInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutDesktopBannerImageInput, MediaUpdateWithoutDesktopBannerImageInput>, MediaUncheckedUpdateWithoutDesktopBannerImageInput>
  }

  export type MediaUncheckedUpdateOneWithoutMobileBannerImageNestedInput = {
    create?: XOR<MediaCreateWithoutMobileBannerImageInput, MediaUncheckedCreateWithoutMobileBannerImageInput>
    connectOrCreate?: MediaCreateOrConnectWithoutMobileBannerImageInput
    upsert?: MediaUpsertWithoutMobileBannerImageInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutMobileBannerImageInput, MediaUpdateWithoutMobileBannerImageInput>, MediaUncheckedUpdateWithoutMobileBannerImageInput>
  }

  export type CartCreateNestedManyWithoutCouponInput = {
    create?: XOR<CartCreateWithoutCouponInput, CartUncheckedCreateWithoutCouponInput> | CartCreateWithoutCouponInput[] | CartUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: CartCreateOrConnectWithoutCouponInput | CartCreateOrConnectWithoutCouponInput[]
    createMany?: CartCreateManyCouponInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type CartUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<CartCreateWithoutCouponInput, CartUncheckedCreateWithoutCouponInput> | CartCreateWithoutCouponInput[] | CartUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: CartCreateOrConnectWithoutCouponInput | CartCreateOrConnectWithoutCouponInput[]
    createMany?: CartCreateManyCouponInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type EnumDiscountTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiscountType
  }

  export type CartUpdateManyWithoutCouponNestedInput = {
    create?: XOR<CartCreateWithoutCouponInput, CartUncheckedCreateWithoutCouponInput> | CartCreateWithoutCouponInput[] | CartUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: CartCreateOrConnectWithoutCouponInput | CartCreateOrConnectWithoutCouponInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutCouponInput | CartUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: CartCreateManyCouponInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutCouponInput | CartUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: CartUpdateManyWithWhereWithoutCouponInput | CartUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type CartUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<CartCreateWithoutCouponInput, CartUncheckedCreateWithoutCouponInput> | CartCreateWithoutCouponInput[] | CartUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: CartCreateOrConnectWithoutCouponInput | CartCreateOrConnectWithoutCouponInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutCouponInput | CartUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: CartCreateManyCouponInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutCouponInput | CartUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: CartUpdateManyWithWhereWithoutCouponInput | CartUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type PriceRangeCreateNestedManyWithoutDeliveryFeeInput = {
    create?: XOR<PriceRangeCreateWithoutDeliveryFeeInput, PriceRangeUncheckedCreateWithoutDeliveryFeeInput> | PriceRangeCreateWithoutDeliveryFeeInput[] | PriceRangeUncheckedCreateWithoutDeliveryFeeInput[]
    connectOrCreate?: PriceRangeCreateOrConnectWithoutDeliveryFeeInput | PriceRangeCreateOrConnectWithoutDeliveryFeeInput[]
    createMany?: PriceRangeCreateManyDeliveryFeeInputEnvelope
    connect?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
  }

  export type PriceRangeUncheckedCreateNestedManyWithoutDeliveryFeeInput = {
    create?: XOR<PriceRangeCreateWithoutDeliveryFeeInput, PriceRangeUncheckedCreateWithoutDeliveryFeeInput> | PriceRangeCreateWithoutDeliveryFeeInput[] | PriceRangeUncheckedCreateWithoutDeliveryFeeInput[]
    connectOrCreate?: PriceRangeCreateOrConnectWithoutDeliveryFeeInput | PriceRangeCreateOrConnectWithoutDeliveryFeeInput[]
    createMany?: PriceRangeCreateManyDeliveryFeeInputEnvelope
    connect?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
  }

  export type PriceRangeUpdateManyWithoutDeliveryFeeNestedInput = {
    create?: XOR<PriceRangeCreateWithoutDeliveryFeeInput, PriceRangeUncheckedCreateWithoutDeliveryFeeInput> | PriceRangeCreateWithoutDeliveryFeeInput[] | PriceRangeUncheckedCreateWithoutDeliveryFeeInput[]
    connectOrCreate?: PriceRangeCreateOrConnectWithoutDeliveryFeeInput | PriceRangeCreateOrConnectWithoutDeliveryFeeInput[]
    upsert?: PriceRangeUpsertWithWhereUniqueWithoutDeliveryFeeInput | PriceRangeUpsertWithWhereUniqueWithoutDeliveryFeeInput[]
    createMany?: PriceRangeCreateManyDeliveryFeeInputEnvelope
    set?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
    disconnect?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
    delete?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
    connect?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
    update?: PriceRangeUpdateWithWhereUniqueWithoutDeliveryFeeInput | PriceRangeUpdateWithWhereUniqueWithoutDeliveryFeeInput[]
    updateMany?: PriceRangeUpdateManyWithWhereWithoutDeliveryFeeInput | PriceRangeUpdateManyWithWhereWithoutDeliveryFeeInput[]
    deleteMany?: PriceRangeScalarWhereInput | PriceRangeScalarWhereInput[]
  }

  export type PriceRangeUncheckedUpdateManyWithoutDeliveryFeeNestedInput = {
    create?: XOR<PriceRangeCreateWithoutDeliveryFeeInput, PriceRangeUncheckedCreateWithoutDeliveryFeeInput> | PriceRangeCreateWithoutDeliveryFeeInput[] | PriceRangeUncheckedCreateWithoutDeliveryFeeInput[]
    connectOrCreate?: PriceRangeCreateOrConnectWithoutDeliveryFeeInput | PriceRangeCreateOrConnectWithoutDeliveryFeeInput[]
    upsert?: PriceRangeUpsertWithWhereUniqueWithoutDeliveryFeeInput | PriceRangeUpsertWithWhereUniqueWithoutDeliveryFeeInput[]
    createMany?: PriceRangeCreateManyDeliveryFeeInputEnvelope
    set?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
    disconnect?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
    delete?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
    connect?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
    update?: PriceRangeUpdateWithWhereUniqueWithoutDeliveryFeeInput | PriceRangeUpdateWithWhereUniqueWithoutDeliveryFeeInput[]
    updateMany?: PriceRangeUpdateManyWithWhereWithoutDeliveryFeeInput | PriceRangeUpdateManyWithWhereWithoutDeliveryFeeInput[]
    deleteMany?: PriceRangeScalarWhereInput | PriceRangeScalarWhereInput[]
  }

  export type DeliveryFeeCreateNestedOneWithoutPriceRangeInput = {
    create?: XOR<DeliveryFeeCreateWithoutPriceRangeInput, DeliveryFeeUncheckedCreateWithoutPriceRangeInput>
    connectOrCreate?: DeliveryFeeCreateOrConnectWithoutPriceRangeInput
    connect?: DeliveryFeeWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPriceTableInput = {
    create?: XOR<ProductCreateWithoutPriceTableInput, ProductUncheckedCreateWithoutPriceTableInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPriceTableInput
    connect?: ProductWhereUniqueInput
  }

  export type DeliveryFeeUpdateOneRequiredWithoutPriceRangeNestedInput = {
    create?: XOR<DeliveryFeeCreateWithoutPriceRangeInput, DeliveryFeeUncheckedCreateWithoutPriceRangeInput>
    connectOrCreate?: DeliveryFeeCreateOrConnectWithoutPriceRangeInput
    upsert?: DeliveryFeeUpsertWithoutPriceRangeInput
    connect?: DeliveryFeeWhereUniqueInput
    update?: XOR<XOR<DeliveryFeeUpdateToOneWithWhereWithoutPriceRangeInput, DeliveryFeeUpdateWithoutPriceRangeInput>, DeliveryFeeUncheckedUpdateWithoutPriceRangeInput>
  }

  export type ProductUpdateOneWithoutPriceTableNestedInput = {
    create?: XOR<ProductCreateWithoutPriceTableInput, ProductUncheckedCreateWithoutPriceTableInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPriceTableInput
    upsert?: ProductUpsertWithoutPriceTableInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPriceTableInput, ProductUpdateWithoutPriceTableInput>, ProductUncheckedUpdateWithoutPriceTableInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ProductCreateNestedManyWithoutDiscountInput = {
    create?: XOR<ProductCreateWithoutDiscountInput, ProductUncheckedCreateWithoutDiscountInput> | ProductCreateWithoutDiscountInput[] | ProductUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutDiscountInput | ProductCreateOrConnectWithoutDiscountInput[]
    createMany?: ProductCreateManyDiscountInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutDiscountInput = {
    create?: XOR<ProductCreateWithoutDiscountInput, ProductUncheckedCreateWithoutDiscountInput> | ProductCreateWithoutDiscountInput[] | ProductUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutDiscountInput | ProductCreateOrConnectWithoutDiscountInput[]
    createMany?: ProductCreateManyDiscountInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutDiscountNestedInput = {
    create?: XOR<ProductCreateWithoutDiscountInput, ProductUncheckedCreateWithoutDiscountInput> | ProductCreateWithoutDiscountInput[] | ProductUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutDiscountInput | ProductCreateOrConnectWithoutDiscountInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutDiscountInput | ProductUpsertWithWhereUniqueWithoutDiscountInput[]
    createMany?: ProductCreateManyDiscountInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutDiscountInput | ProductUpdateWithWhereUniqueWithoutDiscountInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutDiscountInput | ProductUpdateManyWithWhereWithoutDiscountInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutDiscountNestedInput = {
    create?: XOR<ProductCreateWithoutDiscountInput, ProductUncheckedCreateWithoutDiscountInput> | ProductCreateWithoutDiscountInput[] | ProductUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutDiscountInput | ProductCreateOrConnectWithoutDiscountInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutDiscountInput | ProductUpsertWithWhereUniqueWithoutDiscountInput[]
    createMany?: ProductCreateManyDiscountInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutDiscountInput | ProductUpdateWithWhereUniqueWithoutDiscountInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutDiscountInput | ProductUpdateManyWithWhereWithoutDiscountInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutTextPersonalizationFieldsInput = {
    create?: XOR<ProductCreateWithoutTextPersonalizationFieldsInput, ProductUncheckedCreateWithoutTextPersonalizationFieldsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTextPersonalizationFieldsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneWithoutTextPersonalizationFieldsNestedInput = {
    create?: XOR<ProductCreateWithoutTextPersonalizationFieldsInput, ProductUncheckedCreateWithoutTextPersonalizationFieldsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTextPersonalizationFieldsInput
    upsert?: ProductUpsertWithoutTextPersonalizationFieldsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutTextPersonalizationFieldsInput, ProductUpdateWithoutTextPersonalizationFieldsInput>, ProductUncheckedUpdateWithoutTextPersonalizationFieldsInput>
  }

  export type ProductCreateNestedOneWithoutImagePersonalizationFieldsInput = {
    create?: XOR<ProductCreateWithoutImagePersonalizationFieldsInput, ProductUncheckedCreateWithoutImagePersonalizationFieldsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutImagePersonalizationFieldsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneWithoutImagePersonalizationFieldsNestedInput = {
    create?: XOR<ProductCreateWithoutImagePersonalizationFieldsInput, ProductUncheckedCreateWithoutImagePersonalizationFieldsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutImagePersonalizationFieldsInput
    upsert?: ProductUpsertWithoutImagePersonalizationFieldsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutImagePersonalizationFieldsInput, ProductUpdateWithoutImagePersonalizationFieldsInput>, ProductUncheckedUpdateWithoutImagePersonalizationFieldsInput>
  }

  export type CategoryCreateNestedManyWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput> | CategoryCreateWithoutProductsInput[] | CategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput | CategoryCreateOrConnectWithoutProductsInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type PriceRangeCreateNestedManyWithoutProductInput = {
    create?: XOR<PriceRangeCreateWithoutProductInput, PriceRangeUncheckedCreateWithoutProductInput> | PriceRangeCreateWithoutProductInput[] | PriceRangeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PriceRangeCreateOrConnectWithoutProductInput | PriceRangeCreateOrConnectWithoutProductInput[]
    createMany?: PriceRangeCreateManyProductInputEnvelope
    connect?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
  }

  export type DiscountCreateNestedOneWithoutProductsInput = {
    create?: XOR<DiscountCreateWithoutProductsInput, DiscountUncheckedCreateWithoutProductsInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutProductsInput
    connect?: DiscountWhereUniqueInput
  }

  export type PackageOptionCreateNestedOneWithoutProductsInput = {
    create?: XOR<PackageOptionCreateWithoutProductsInput, PackageOptionUncheckedCreateWithoutProductsInput>
    connectOrCreate?: PackageOptionCreateOrConnectWithoutProductsInput
    connect?: PackageOptionWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutProductCoverInput = {
    create?: XOR<MediaCreateWithoutProductCoverInput, MediaUncheckedCreateWithoutProductCoverInput>
    connectOrCreate?: MediaCreateOrConnectWithoutProductCoverInput
    connect?: MediaWhereUniqueInput
  }

  export type MediaCreateNestedManyWithoutProductImagesInput = {
    create?: XOR<MediaCreateWithoutProductImagesInput, MediaUncheckedCreateWithoutProductImagesInput> | MediaCreateWithoutProductImagesInput[] | MediaUncheckedCreateWithoutProductImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProductImagesInput | MediaCreateOrConnectWithoutProductImagesInput[]
    createMany?: MediaCreateManyProductImagesInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type ImagePersonalizationFieldCreateNestedManyWithoutProductInput = {
    create?: XOR<ImagePersonalizationFieldCreateWithoutProductInput, ImagePersonalizationFieldUncheckedCreateWithoutProductInput> | ImagePersonalizationFieldCreateWithoutProductInput[] | ImagePersonalizationFieldUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ImagePersonalizationFieldCreateOrConnectWithoutProductInput | ImagePersonalizationFieldCreateOrConnectWithoutProductInput[]
    createMany?: ImagePersonalizationFieldCreateManyProductInputEnvelope
    connect?: ImagePersonalizationFieldWhereUniqueInput | ImagePersonalizationFieldWhereUniqueInput[]
  }

  export type TextPersonalizationFieldCreateNestedManyWithoutProductInput = {
    create?: XOR<TextPersonalizationFieldCreateWithoutProductInput, TextPersonalizationFieldUncheckedCreateWithoutProductInput> | TextPersonalizationFieldCreateWithoutProductInput[] | TextPersonalizationFieldUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TextPersonalizationFieldCreateOrConnectWithoutProductInput | TextPersonalizationFieldCreateOrConnectWithoutProductInput[]
    createMany?: TextPersonalizationFieldCreateManyProductInputEnvelope
    connect?: TextPersonalizationFieldWhereUniqueInput | TextPersonalizationFieldWhereUniqueInput[]
  }

  export type CartItemCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type RatingCreateNestedManyWithoutProductInput = {
    create?: XOR<RatingCreateWithoutProductInput, RatingUncheckedCreateWithoutProductInput> | RatingCreateWithoutProductInput[] | RatingUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutProductInput | RatingCreateOrConnectWithoutProductInput[]
    createMany?: RatingCreateManyProductInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput> | CategoryCreateWithoutProductsInput[] | CategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput | CategoryCreateOrConnectWithoutProductsInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type PriceRangeUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PriceRangeCreateWithoutProductInput, PriceRangeUncheckedCreateWithoutProductInput> | PriceRangeCreateWithoutProductInput[] | PriceRangeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PriceRangeCreateOrConnectWithoutProductInput | PriceRangeCreateOrConnectWithoutProductInput[]
    createMany?: PriceRangeCreateManyProductInputEnvelope
    connect?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedOneWithoutProductCoverInput = {
    create?: XOR<MediaCreateWithoutProductCoverInput, MediaUncheckedCreateWithoutProductCoverInput>
    connectOrCreate?: MediaCreateOrConnectWithoutProductCoverInput
    connect?: MediaWhereUniqueInput
  }

  export type MediaUncheckedCreateNestedManyWithoutProductImagesInput = {
    create?: XOR<MediaCreateWithoutProductImagesInput, MediaUncheckedCreateWithoutProductImagesInput> | MediaCreateWithoutProductImagesInput[] | MediaUncheckedCreateWithoutProductImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProductImagesInput | MediaCreateOrConnectWithoutProductImagesInput[]
    createMany?: MediaCreateManyProductImagesInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type ImagePersonalizationFieldUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ImagePersonalizationFieldCreateWithoutProductInput, ImagePersonalizationFieldUncheckedCreateWithoutProductInput> | ImagePersonalizationFieldCreateWithoutProductInput[] | ImagePersonalizationFieldUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ImagePersonalizationFieldCreateOrConnectWithoutProductInput | ImagePersonalizationFieldCreateOrConnectWithoutProductInput[]
    createMany?: ImagePersonalizationFieldCreateManyProductInputEnvelope
    connect?: ImagePersonalizationFieldWhereUniqueInput | ImagePersonalizationFieldWhereUniqueInput[]
  }

  export type TextPersonalizationFieldUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<TextPersonalizationFieldCreateWithoutProductInput, TextPersonalizationFieldUncheckedCreateWithoutProductInput> | TextPersonalizationFieldCreateWithoutProductInput[] | TextPersonalizationFieldUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TextPersonalizationFieldCreateOrConnectWithoutProductInput | TextPersonalizationFieldCreateOrConnectWithoutProductInput[]
    createMany?: TextPersonalizationFieldCreateManyProductInputEnvelope
    connect?: TextPersonalizationFieldWhereUniqueInput | TextPersonalizationFieldWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<RatingCreateWithoutProductInput, RatingUncheckedCreateWithoutProductInput> | RatingCreateWithoutProductInput[] | RatingUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutProductInput | RatingCreateOrConnectWithoutProductInput[]
    createMany?: RatingCreateManyProductInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type EnumDeliveryTypeFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryType
  }

  export type CategoryUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput> | CategoryCreateWithoutProductsInput[] | CategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput | CategoryCreateOrConnectWithoutProductsInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutProductsInput | CategoryUpsertWithWhereUniqueWithoutProductsInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutProductsInput | CategoryUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutProductsInput | CategoryUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type PriceRangeUpdateManyWithoutProductNestedInput = {
    create?: XOR<PriceRangeCreateWithoutProductInput, PriceRangeUncheckedCreateWithoutProductInput> | PriceRangeCreateWithoutProductInput[] | PriceRangeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PriceRangeCreateOrConnectWithoutProductInput | PriceRangeCreateOrConnectWithoutProductInput[]
    upsert?: PriceRangeUpsertWithWhereUniqueWithoutProductInput | PriceRangeUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PriceRangeCreateManyProductInputEnvelope
    set?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
    disconnect?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
    delete?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
    connect?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
    update?: PriceRangeUpdateWithWhereUniqueWithoutProductInput | PriceRangeUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PriceRangeUpdateManyWithWhereWithoutProductInput | PriceRangeUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PriceRangeScalarWhereInput | PriceRangeScalarWhereInput[]
  }

  export type DiscountUpdateOneWithoutProductsNestedInput = {
    create?: XOR<DiscountCreateWithoutProductsInput, DiscountUncheckedCreateWithoutProductsInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutProductsInput
    upsert?: DiscountUpsertWithoutProductsInput
    disconnect?: DiscountWhereInput | boolean
    delete?: DiscountWhereInput | boolean
    connect?: DiscountWhereUniqueInput
    update?: XOR<XOR<DiscountUpdateToOneWithWhereWithoutProductsInput, DiscountUpdateWithoutProductsInput>, DiscountUncheckedUpdateWithoutProductsInput>
  }

  export type PackageOptionUpdateOneWithoutProductsNestedInput = {
    create?: XOR<PackageOptionCreateWithoutProductsInput, PackageOptionUncheckedCreateWithoutProductsInput>
    connectOrCreate?: PackageOptionCreateOrConnectWithoutProductsInput
    upsert?: PackageOptionUpsertWithoutProductsInput
    disconnect?: PackageOptionWhereInput | boolean
    delete?: PackageOptionWhereInput | boolean
    connect?: PackageOptionWhereUniqueInput
    update?: XOR<XOR<PackageOptionUpdateToOneWithWhereWithoutProductsInput, PackageOptionUpdateWithoutProductsInput>, PackageOptionUncheckedUpdateWithoutProductsInput>
  }

  export type MediaUpdateOneWithoutProductCoverNestedInput = {
    create?: XOR<MediaCreateWithoutProductCoverInput, MediaUncheckedCreateWithoutProductCoverInput>
    connectOrCreate?: MediaCreateOrConnectWithoutProductCoverInput
    upsert?: MediaUpsertWithoutProductCoverInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutProductCoverInput, MediaUpdateWithoutProductCoverInput>, MediaUncheckedUpdateWithoutProductCoverInput>
  }

  export type MediaUpdateManyWithoutProductImagesNestedInput = {
    create?: XOR<MediaCreateWithoutProductImagesInput, MediaUncheckedCreateWithoutProductImagesInput> | MediaCreateWithoutProductImagesInput[] | MediaUncheckedCreateWithoutProductImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProductImagesInput | MediaCreateOrConnectWithoutProductImagesInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutProductImagesInput | MediaUpsertWithWhereUniqueWithoutProductImagesInput[]
    createMany?: MediaCreateManyProductImagesInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutProductImagesInput | MediaUpdateWithWhereUniqueWithoutProductImagesInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutProductImagesInput | MediaUpdateManyWithWhereWithoutProductImagesInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type ImagePersonalizationFieldUpdateManyWithoutProductNestedInput = {
    create?: XOR<ImagePersonalizationFieldCreateWithoutProductInput, ImagePersonalizationFieldUncheckedCreateWithoutProductInput> | ImagePersonalizationFieldCreateWithoutProductInput[] | ImagePersonalizationFieldUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ImagePersonalizationFieldCreateOrConnectWithoutProductInput | ImagePersonalizationFieldCreateOrConnectWithoutProductInput[]
    upsert?: ImagePersonalizationFieldUpsertWithWhereUniqueWithoutProductInput | ImagePersonalizationFieldUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ImagePersonalizationFieldCreateManyProductInputEnvelope
    set?: ImagePersonalizationFieldWhereUniqueInput | ImagePersonalizationFieldWhereUniqueInput[]
    disconnect?: ImagePersonalizationFieldWhereUniqueInput | ImagePersonalizationFieldWhereUniqueInput[]
    delete?: ImagePersonalizationFieldWhereUniqueInput | ImagePersonalizationFieldWhereUniqueInput[]
    connect?: ImagePersonalizationFieldWhereUniqueInput | ImagePersonalizationFieldWhereUniqueInput[]
    update?: ImagePersonalizationFieldUpdateWithWhereUniqueWithoutProductInput | ImagePersonalizationFieldUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ImagePersonalizationFieldUpdateManyWithWhereWithoutProductInput | ImagePersonalizationFieldUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ImagePersonalizationFieldScalarWhereInput | ImagePersonalizationFieldScalarWhereInput[]
  }

  export type TextPersonalizationFieldUpdateManyWithoutProductNestedInput = {
    create?: XOR<TextPersonalizationFieldCreateWithoutProductInput, TextPersonalizationFieldUncheckedCreateWithoutProductInput> | TextPersonalizationFieldCreateWithoutProductInput[] | TextPersonalizationFieldUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TextPersonalizationFieldCreateOrConnectWithoutProductInput | TextPersonalizationFieldCreateOrConnectWithoutProductInput[]
    upsert?: TextPersonalizationFieldUpsertWithWhereUniqueWithoutProductInput | TextPersonalizationFieldUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TextPersonalizationFieldCreateManyProductInputEnvelope
    set?: TextPersonalizationFieldWhereUniqueInput | TextPersonalizationFieldWhereUniqueInput[]
    disconnect?: TextPersonalizationFieldWhereUniqueInput | TextPersonalizationFieldWhereUniqueInput[]
    delete?: TextPersonalizationFieldWhereUniqueInput | TextPersonalizationFieldWhereUniqueInput[]
    connect?: TextPersonalizationFieldWhereUniqueInput | TextPersonalizationFieldWhereUniqueInput[]
    update?: TextPersonalizationFieldUpdateWithWhereUniqueWithoutProductInput | TextPersonalizationFieldUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TextPersonalizationFieldUpdateManyWithWhereWithoutProductInput | TextPersonalizationFieldUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TextPersonalizationFieldScalarWhereInput | TextPersonalizationFieldScalarWhereInput[]
  }

  export type CartItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type RatingUpdateManyWithoutProductNestedInput = {
    create?: XOR<RatingCreateWithoutProductInput, RatingUncheckedCreateWithoutProductInput> | RatingCreateWithoutProductInput[] | RatingUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutProductInput | RatingCreateOrConnectWithoutProductInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutProductInput | RatingUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RatingCreateManyProductInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutProductInput | RatingUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutProductInput | RatingUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput> | CategoryCreateWithoutProductsInput[] | CategoryUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput | CategoryCreateOrConnectWithoutProductsInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutProductsInput | CategoryUpsertWithWhereUniqueWithoutProductsInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutProductsInput | CategoryUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutProductsInput | CategoryUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type PriceRangeUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PriceRangeCreateWithoutProductInput, PriceRangeUncheckedCreateWithoutProductInput> | PriceRangeCreateWithoutProductInput[] | PriceRangeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PriceRangeCreateOrConnectWithoutProductInput | PriceRangeCreateOrConnectWithoutProductInput[]
    upsert?: PriceRangeUpsertWithWhereUniqueWithoutProductInput | PriceRangeUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PriceRangeCreateManyProductInputEnvelope
    set?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
    disconnect?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
    delete?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
    connect?: PriceRangeWhereUniqueInput | PriceRangeWhereUniqueInput[]
    update?: PriceRangeUpdateWithWhereUniqueWithoutProductInput | PriceRangeUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PriceRangeUpdateManyWithWhereWithoutProductInput | PriceRangeUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PriceRangeScalarWhereInput | PriceRangeScalarWhereInput[]
  }

  export type MediaUncheckedUpdateOneWithoutProductCoverNestedInput = {
    create?: XOR<MediaCreateWithoutProductCoverInput, MediaUncheckedCreateWithoutProductCoverInput>
    connectOrCreate?: MediaCreateOrConnectWithoutProductCoverInput
    upsert?: MediaUpsertWithoutProductCoverInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutProductCoverInput, MediaUpdateWithoutProductCoverInput>, MediaUncheckedUpdateWithoutProductCoverInput>
  }

  export type MediaUncheckedUpdateManyWithoutProductImagesNestedInput = {
    create?: XOR<MediaCreateWithoutProductImagesInput, MediaUncheckedCreateWithoutProductImagesInput> | MediaCreateWithoutProductImagesInput[] | MediaUncheckedCreateWithoutProductImagesInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProductImagesInput | MediaCreateOrConnectWithoutProductImagesInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutProductImagesInput | MediaUpsertWithWhereUniqueWithoutProductImagesInput[]
    createMany?: MediaCreateManyProductImagesInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutProductImagesInput | MediaUpdateWithWhereUniqueWithoutProductImagesInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutProductImagesInput | MediaUpdateManyWithWhereWithoutProductImagesInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type ImagePersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ImagePersonalizationFieldCreateWithoutProductInput, ImagePersonalizationFieldUncheckedCreateWithoutProductInput> | ImagePersonalizationFieldCreateWithoutProductInput[] | ImagePersonalizationFieldUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ImagePersonalizationFieldCreateOrConnectWithoutProductInput | ImagePersonalizationFieldCreateOrConnectWithoutProductInput[]
    upsert?: ImagePersonalizationFieldUpsertWithWhereUniqueWithoutProductInput | ImagePersonalizationFieldUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ImagePersonalizationFieldCreateManyProductInputEnvelope
    set?: ImagePersonalizationFieldWhereUniqueInput | ImagePersonalizationFieldWhereUniqueInput[]
    disconnect?: ImagePersonalizationFieldWhereUniqueInput | ImagePersonalizationFieldWhereUniqueInput[]
    delete?: ImagePersonalizationFieldWhereUniqueInput | ImagePersonalizationFieldWhereUniqueInput[]
    connect?: ImagePersonalizationFieldWhereUniqueInput | ImagePersonalizationFieldWhereUniqueInput[]
    update?: ImagePersonalizationFieldUpdateWithWhereUniqueWithoutProductInput | ImagePersonalizationFieldUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ImagePersonalizationFieldUpdateManyWithWhereWithoutProductInput | ImagePersonalizationFieldUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ImagePersonalizationFieldScalarWhereInput | ImagePersonalizationFieldScalarWhereInput[]
  }

  export type TextPersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<TextPersonalizationFieldCreateWithoutProductInput, TextPersonalizationFieldUncheckedCreateWithoutProductInput> | TextPersonalizationFieldCreateWithoutProductInput[] | TextPersonalizationFieldUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TextPersonalizationFieldCreateOrConnectWithoutProductInput | TextPersonalizationFieldCreateOrConnectWithoutProductInput[]
    upsert?: TextPersonalizationFieldUpsertWithWhereUniqueWithoutProductInput | TextPersonalizationFieldUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TextPersonalizationFieldCreateManyProductInputEnvelope
    set?: TextPersonalizationFieldWhereUniqueInput | TextPersonalizationFieldWhereUniqueInput[]
    disconnect?: TextPersonalizationFieldWhereUniqueInput | TextPersonalizationFieldWhereUniqueInput[]
    delete?: TextPersonalizationFieldWhereUniqueInput | TextPersonalizationFieldWhereUniqueInput[]
    connect?: TextPersonalizationFieldWhereUniqueInput | TextPersonalizationFieldWhereUniqueInput[]
    update?: TextPersonalizationFieldUpdateWithWhereUniqueWithoutProductInput | TextPersonalizationFieldUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TextPersonalizationFieldUpdateManyWithWhereWithoutProductInput | TextPersonalizationFieldUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TextPersonalizationFieldScalarWhereInput | TextPersonalizationFieldScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<RatingCreateWithoutProductInput, RatingUncheckedCreateWithoutProductInput> | RatingCreateWithoutProductInput[] | RatingUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutProductInput | RatingCreateOrConnectWithoutProductInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutProductInput | RatingUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RatingCreateManyProductInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutProductInput | RatingUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutProductInput | RatingUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRatingsInput = {
    create?: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutRatingsInput = {
    create?: XOR<ProductCreateWithoutRatingsInput, ProductUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRatingsInput
    connect?: ProductWhereUniqueInput
  }

  export type EnumRatingStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.RatingStatusType
  }

  export type UserUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRatingsInput
    upsert?: UserUpsertWithoutRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRatingsInput, UserUpdateWithoutRatingsInput>, UserUncheckedUpdateWithoutRatingsInput>
  }

  export type ProductUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<ProductCreateWithoutRatingsInput, ProductUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRatingsInput
    upsert?: ProductUpsertWithoutRatingsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutRatingsInput, ProductUpdateWithoutRatingsInput>, ProductUncheckedUpdateWithoutRatingsInput>
  }

  export type UserCreateNestedOneWithoutMediaInput = {
    create?: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutMediaInput
    connect?: UserWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutImageInput = {
    create?: XOR<CategoryCreateWithoutImageInput, CategoryUncheckedCreateWithoutImageInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutImageInput
    connect?: CategoryWhereUniqueInput
  }

  export type DeliveryServiceCreateNestedOneWithoutPdfInput = {
    create?: XOR<DeliveryServiceCreateWithoutPdfInput, DeliveryServiceUncheckedCreateWithoutPdfInput>
    connectOrCreate?: DeliveryServiceCreateOrConnectWithoutPdfInput
    connect?: DeliveryServiceWhereUniqueInput
  }

  export type BannerCreateNestedOneWithoutDesktopImageInput = {
    create?: XOR<BannerCreateWithoutDesktopImageInput, BannerUncheckedCreateWithoutDesktopImageInput>
    connectOrCreate?: BannerCreateOrConnectWithoutDesktopImageInput
    connect?: BannerWhereUniqueInput
  }

  export type BannerCreateNestedOneWithoutMobileImageInput = {
    create?: XOR<BannerCreateWithoutMobileImageInput, BannerUncheckedCreateWithoutMobileImageInput>
    connectOrCreate?: BannerCreateOrConnectWithoutMobileImageInput
    connect?: BannerWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCoverImageInput = {
    create?: XOR<ProductCreateWithoutCoverImageInput, ProductUncheckedCreateWithoutCoverImageInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCoverImageInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutImagesInput = {
    create?: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutImagesInput
    connect?: ProductWhereUniqueInput
  }

  export type ImagePersonalizationCreateNestedOneWithoutImagesInput = {
    create?: XOR<ImagePersonalizationCreateWithoutImagesInput, ImagePersonalizationUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ImagePersonalizationCreateOrConnectWithoutImagesInput
    connect?: ImagePersonalizationWhereUniqueInput
  }

  export type UserUpdateOneWithoutMediaNestedInput = {
    create?: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutMediaInput
    upsert?: UserUpsertWithoutMediaInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMediaInput, UserUpdateWithoutMediaInput>, UserUncheckedUpdateWithoutMediaInput>
  }

  export type CategoryUpdateOneWithoutImageNestedInput = {
    create?: XOR<CategoryCreateWithoutImageInput, CategoryUncheckedCreateWithoutImageInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutImageInput
    upsert?: CategoryUpsertWithoutImageInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutImageInput, CategoryUpdateWithoutImageInput>, CategoryUncheckedUpdateWithoutImageInput>
  }

  export type DeliveryServiceUpdateOneWithoutPdfNestedInput = {
    create?: XOR<DeliveryServiceCreateWithoutPdfInput, DeliveryServiceUncheckedCreateWithoutPdfInput>
    connectOrCreate?: DeliveryServiceCreateOrConnectWithoutPdfInput
    upsert?: DeliveryServiceUpsertWithoutPdfInput
    disconnect?: DeliveryServiceWhereInput | boolean
    delete?: DeliveryServiceWhereInput | boolean
    connect?: DeliveryServiceWhereUniqueInput
    update?: XOR<XOR<DeliveryServiceUpdateToOneWithWhereWithoutPdfInput, DeliveryServiceUpdateWithoutPdfInput>, DeliveryServiceUncheckedUpdateWithoutPdfInput>
  }

  export type BannerUpdateOneWithoutDesktopImageNestedInput = {
    create?: XOR<BannerCreateWithoutDesktopImageInput, BannerUncheckedCreateWithoutDesktopImageInput>
    connectOrCreate?: BannerCreateOrConnectWithoutDesktopImageInput
    upsert?: BannerUpsertWithoutDesktopImageInput
    disconnect?: BannerWhereInput | boolean
    delete?: BannerWhereInput | boolean
    connect?: BannerWhereUniqueInput
    update?: XOR<XOR<BannerUpdateToOneWithWhereWithoutDesktopImageInput, BannerUpdateWithoutDesktopImageInput>, BannerUncheckedUpdateWithoutDesktopImageInput>
  }

  export type BannerUpdateOneWithoutMobileImageNestedInput = {
    create?: XOR<BannerCreateWithoutMobileImageInput, BannerUncheckedCreateWithoutMobileImageInput>
    connectOrCreate?: BannerCreateOrConnectWithoutMobileImageInput
    upsert?: BannerUpsertWithoutMobileImageInput
    disconnect?: BannerWhereInput | boolean
    delete?: BannerWhereInput | boolean
    connect?: BannerWhereUniqueInput
    update?: XOR<XOR<BannerUpdateToOneWithWhereWithoutMobileImageInput, BannerUpdateWithoutMobileImageInput>, BannerUncheckedUpdateWithoutMobileImageInput>
  }

  export type ProductUpdateOneWithoutCoverImageNestedInput = {
    create?: XOR<ProductCreateWithoutCoverImageInput, ProductUncheckedCreateWithoutCoverImageInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCoverImageInput
    upsert?: ProductUpsertWithoutCoverImageInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCoverImageInput, ProductUpdateWithoutCoverImageInput>, ProductUncheckedUpdateWithoutCoverImageInput>
  }

  export type ProductUpdateOneWithoutImagesNestedInput = {
    create?: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutImagesInput
    upsert?: ProductUpsertWithoutImagesInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutImagesInput, ProductUpdateWithoutImagesInput>, ProductUncheckedUpdateWithoutImagesInput>
  }

  export type ImagePersonalizationUpdateOneWithoutImagesNestedInput = {
    create?: XOR<ImagePersonalizationCreateWithoutImagesInput, ImagePersonalizationUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ImagePersonalizationCreateOrConnectWithoutImagesInput
    upsert?: ImagePersonalizationUpsertWithoutImagesInput
    disconnect?: ImagePersonalizationWhereInput | boolean
    delete?: ImagePersonalizationWhereInput | boolean
    connect?: ImagePersonalizationWhereUniqueInput
    update?: XOR<XOR<ImagePersonalizationUpdateToOneWithWhereWithoutImagesInput, ImagePersonalizationUpdateWithoutImagesInput>, ImagePersonalizationUncheckedUpdateWithoutImagesInput>
  }

  export type UserCreateNestedOneWithoutCartInput = {
    create?: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartInput
    connect?: UserWhereUniqueInput
  }

  export type CartItemCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type CouponCreateNestedOneWithoutCartsInput = {
    create?: XOR<CouponCreateWithoutCartsInput, CouponUncheckedCreateWithoutCartsInput>
    connectOrCreate?: CouponCreateOrConnectWithoutCartsInput
    connect?: CouponWhereUniqueInput
  }

  export type CartItemUncheckedCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCartNestedInput = {
    create?: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartInput
    upsert?: UserUpsertWithoutCartInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCartInput, UserUpdateWithoutCartInput>, UserUncheckedUpdateWithoutCartInput>
  }

  export type CartItemUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type CouponUpdateOneWithoutCartsNestedInput = {
    create?: XOR<CouponCreateWithoutCartsInput, CouponUncheckedCreateWithoutCartsInput>
    connectOrCreate?: CouponCreateOrConnectWithoutCartsInput
    upsert?: CouponUpsertWithoutCartsInput
    disconnect?: CouponWhereInput | boolean
    delete?: CouponWhereInput | boolean
    connect?: CouponWhereUniqueInput
    update?: XOR<XOR<CouponUpdateToOneWithWhereWithoutCartsInput, CouponUpdateWithoutCartsInput>, CouponUncheckedUpdateWithoutCartsInput>
  }

  export type CartItemUncheckedUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type CartCreateNestedOneWithoutItemsInput = {
    create?: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutItemsInput
    connect?: CartWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCartItemsInput = {
    create?: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type TextPersonalizationCreateNestedManyWithoutCartItemInput = {
    create?: XOR<TextPersonalizationCreateWithoutCartItemInput, TextPersonalizationUncheckedCreateWithoutCartItemInput> | TextPersonalizationCreateWithoutCartItemInput[] | TextPersonalizationUncheckedCreateWithoutCartItemInput[]
    connectOrCreate?: TextPersonalizationCreateOrConnectWithoutCartItemInput | TextPersonalizationCreateOrConnectWithoutCartItemInput[]
    createMany?: TextPersonalizationCreateManyCartItemInputEnvelope
    connect?: TextPersonalizationWhereUniqueInput | TextPersonalizationWhereUniqueInput[]
  }

  export type ImagePersonalizationCreateNestedManyWithoutCartItemInput = {
    create?: XOR<ImagePersonalizationCreateWithoutCartItemInput, ImagePersonalizationUncheckedCreateWithoutCartItemInput> | ImagePersonalizationCreateWithoutCartItemInput[] | ImagePersonalizationUncheckedCreateWithoutCartItemInput[]
    connectOrCreate?: ImagePersonalizationCreateOrConnectWithoutCartItemInput | ImagePersonalizationCreateOrConnectWithoutCartItemInput[]
    createMany?: ImagePersonalizationCreateManyCartItemInputEnvelope
    connect?: ImagePersonalizationWhereUniqueInput | ImagePersonalizationWhereUniqueInput[]
  }

  export type TextPersonalizationUncheckedCreateNestedManyWithoutCartItemInput = {
    create?: XOR<TextPersonalizationCreateWithoutCartItemInput, TextPersonalizationUncheckedCreateWithoutCartItemInput> | TextPersonalizationCreateWithoutCartItemInput[] | TextPersonalizationUncheckedCreateWithoutCartItemInput[]
    connectOrCreate?: TextPersonalizationCreateOrConnectWithoutCartItemInput | TextPersonalizationCreateOrConnectWithoutCartItemInput[]
    createMany?: TextPersonalizationCreateManyCartItemInputEnvelope
    connect?: TextPersonalizationWhereUniqueInput | TextPersonalizationWhereUniqueInput[]
  }

  export type ImagePersonalizationUncheckedCreateNestedManyWithoutCartItemInput = {
    create?: XOR<ImagePersonalizationCreateWithoutCartItemInput, ImagePersonalizationUncheckedCreateWithoutCartItemInput> | ImagePersonalizationCreateWithoutCartItemInput[] | ImagePersonalizationUncheckedCreateWithoutCartItemInput[]
    connectOrCreate?: ImagePersonalizationCreateOrConnectWithoutCartItemInput | ImagePersonalizationCreateOrConnectWithoutCartItemInput[]
    createMany?: ImagePersonalizationCreateManyCartItemInputEnvelope
    connect?: ImagePersonalizationWhereUniqueInput | ImagePersonalizationWhereUniqueInput[]
  }

  export type EnumFontTypeFieldUpdateOperationsInput = {
    set?: $Enums.FontType
  }

  export type CartUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutItemsInput
    upsert?: CartUpsertWithoutItemsInput
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutItemsInput, CartUpdateWithoutItemsInput>, CartUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutCartItemsNestedInput = {
    create?: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemsInput
    upsert?: ProductUpsertWithoutCartItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCartItemsInput, ProductUpdateWithoutCartItemsInput>, ProductUncheckedUpdateWithoutCartItemsInput>
  }

  export type TextPersonalizationUpdateManyWithoutCartItemNestedInput = {
    create?: XOR<TextPersonalizationCreateWithoutCartItemInput, TextPersonalizationUncheckedCreateWithoutCartItemInput> | TextPersonalizationCreateWithoutCartItemInput[] | TextPersonalizationUncheckedCreateWithoutCartItemInput[]
    connectOrCreate?: TextPersonalizationCreateOrConnectWithoutCartItemInput | TextPersonalizationCreateOrConnectWithoutCartItemInput[]
    upsert?: TextPersonalizationUpsertWithWhereUniqueWithoutCartItemInput | TextPersonalizationUpsertWithWhereUniqueWithoutCartItemInput[]
    createMany?: TextPersonalizationCreateManyCartItemInputEnvelope
    set?: TextPersonalizationWhereUniqueInput | TextPersonalizationWhereUniqueInput[]
    disconnect?: TextPersonalizationWhereUniqueInput | TextPersonalizationWhereUniqueInput[]
    delete?: TextPersonalizationWhereUniqueInput | TextPersonalizationWhereUniqueInput[]
    connect?: TextPersonalizationWhereUniqueInput | TextPersonalizationWhereUniqueInput[]
    update?: TextPersonalizationUpdateWithWhereUniqueWithoutCartItemInput | TextPersonalizationUpdateWithWhereUniqueWithoutCartItemInput[]
    updateMany?: TextPersonalizationUpdateManyWithWhereWithoutCartItemInput | TextPersonalizationUpdateManyWithWhereWithoutCartItemInput[]
    deleteMany?: TextPersonalizationScalarWhereInput | TextPersonalizationScalarWhereInput[]
  }

  export type ImagePersonalizationUpdateManyWithoutCartItemNestedInput = {
    create?: XOR<ImagePersonalizationCreateWithoutCartItemInput, ImagePersonalizationUncheckedCreateWithoutCartItemInput> | ImagePersonalizationCreateWithoutCartItemInput[] | ImagePersonalizationUncheckedCreateWithoutCartItemInput[]
    connectOrCreate?: ImagePersonalizationCreateOrConnectWithoutCartItemInput | ImagePersonalizationCreateOrConnectWithoutCartItemInput[]
    upsert?: ImagePersonalizationUpsertWithWhereUniqueWithoutCartItemInput | ImagePersonalizationUpsertWithWhereUniqueWithoutCartItemInput[]
    createMany?: ImagePersonalizationCreateManyCartItemInputEnvelope
    set?: ImagePersonalizationWhereUniqueInput | ImagePersonalizationWhereUniqueInput[]
    disconnect?: ImagePersonalizationWhereUniqueInput | ImagePersonalizationWhereUniqueInput[]
    delete?: ImagePersonalizationWhereUniqueInput | ImagePersonalizationWhereUniqueInput[]
    connect?: ImagePersonalizationWhereUniqueInput | ImagePersonalizationWhereUniqueInput[]
    update?: ImagePersonalizationUpdateWithWhereUniqueWithoutCartItemInput | ImagePersonalizationUpdateWithWhereUniqueWithoutCartItemInput[]
    updateMany?: ImagePersonalizationUpdateManyWithWhereWithoutCartItemInput | ImagePersonalizationUpdateManyWithWhereWithoutCartItemInput[]
    deleteMany?: ImagePersonalizationScalarWhereInput | ImagePersonalizationScalarWhereInput[]
  }

  export type TextPersonalizationUncheckedUpdateManyWithoutCartItemNestedInput = {
    create?: XOR<TextPersonalizationCreateWithoutCartItemInput, TextPersonalizationUncheckedCreateWithoutCartItemInput> | TextPersonalizationCreateWithoutCartItemInput[] | TextPersonalizationUncheckedCreateWithoutCartItemInput[]
    connectOrCreate?: TextPersonalizationCreateOrConnectWithoutCartItemInput | TextPersonalizationCreateOrConnectWithoutCartItemInput[]
    upsert?: TextPersonalizationUpsertWithWhereUniqueWithoutCartItemInput | TextPersonalizationUpsertWithWhereUniqueWithoutCartItemInput[]
    createMany?: TextPersonalizationCreateManyCartItemInputEnvelope
    set?: TextPersonalizationWhereUniqueInput | TextPersonalizationWhereUniqueInput[]
    disconnect?: TextPersonalizationWhereUniqueInput | TextPersonalizationWhereUniqueInput[]
    delete?: TextPersonalizationWhereUniqueInput | TextPersonalizationWhereUniqueInput[]
    connect?: TextPersonalizationWhereUniqueInput | TextPersonalizationWhereUniqueInput[]
    update?: TextPersonalizationUpdateWithWhereUniqueWithoutCartItemInput | TextPersonalizationUpdateWithWhereUniqueWithoutCartItemInput[]
    updateMany?: TextPersonalizationUpdateManyWithWhereWithoutCartItemInput | TextPersonalizationUpdateManyWithWhereWithoutCartItemInput[]
    deleteMany?: TextPersonalizationScalarWhereInput | TextPersonalizationScalarWhereInput[]
  }

  export type ImagePersonalizationUncheckedUpdateManyWithoutCartItemNestedInput = {
    create?: XOR<ImagePersonalizationCreateWithoutCartItemInput, ImagePersonalizationUncheckedCreateWithoutCartItemInput> | ImagePersonalizationCreateWithoutCartItemInput[] | ImagePersonalizationUncheckedCreateWithoutCartItemInput[]
    connectOrCreate?: ImagePersonalizationCreateOrConnectWithoutCartItemInput | ImagePersonalizationCreateOrConnectWithoutCartItemInput[]
    upsert?: ImagePersonalizationUpsertWithWhereUniqueWithoutCartItemInput | ImagePersonalizationUpsertWithWhereUniqueWithoutCartItemInput[]
    createMany?: ImagePersonalizationCreateManyCartItemInputEnvelope
    set?: ImagePersonalizationWhereUniqueInput | ImagePersonalizationWhereUniqueInput[]
    disconnect?: ImagePersonalizationWhereUniqueInput | ImagePersonalizationWhereUniqueInput[]
    delete?: ImagePersonalizationWhereUniqueInput | ImagePersonalizationWhereUniqueInput[]
    connect?: ImagePersonalizationWhereUniqueInput | ImagePersonalizationWhereUniqueInput[]
    update?: ImagePersonalizationUpdateWithWhereUniqueWithoutCartItemInput | ImagePersonalizationUpdateWithWhereUniqueWithoutCartItemInput[]
    updateMany?: ImagePersonalizationUpdateManyWithWhereWithoutCartItemInput | ImagePersonalizationUpdateManyWithWhereWithoutCartItemInput[]
    deleteMany?: ImagePersonalizationScalarWhereInput | ImagePersonalizationScalarWhereInput[]
  }

  export type CartItemCreateNestedOneWithoutTextPersonalizationsInput = {
    create?: XOR<CartItemCreateWithoutTextPersonalizationsInput, CartItemUncheckedCreateWithoutTextPersonalizationsInput>
    connectOrCreate?: CartItemCreateOrConnectWithoutTextPersonalizationsInput
    connect?: CartItemWhereUniqueInput
  }

  export type CartItemUpdateOneWithoutTextPersonalizationsNestedInput = {
    create?: XOR<CartItemCreateWithoutTextPersonalizationsInput, CartItemUncheckedCreateWithoutTextPersonalizationsInput>
    connectOrCreate?: CartItemCreateOrConnectWithoutTextPersonalizationsInput
    upsert?: CartItemUpsertWithoutTextPersonalizationsInput
    disconnect?: CartItemWhereInput | boolean
    delete?: CartItemWhereInput | boolean
    connect?: CartItemWhereUniqueInput
    update?: XOR<XOR<CartItemUpdateToOneWithWhereWithoutTextPersonalizationsInput, CartItemUpdateWithoutTextPersonalizationsInput>, CartItemUncheckedUpdateWithoutTextPersonalizationsInput>
  }

  export type MediaCreateNestedManyWithoutImagePersonalizationInput = {
    create?: XOR<MediaCreateWithoutImagePersonalizationInput, MediaUncheckedCreateWithoutImagePersonalizationInput> | MediaCreateWithoutImagePersonalizationInput[] | MediaUncheckedCreateWithoutImagePersonalizationInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutImagePersonalizationInput | MediaCreateOrConnectWithoutImagePersonalizationInput[]
    createMany?: MediaCreateManyImagePersonalizationInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type CartItemCreateNestedOneWithoutImagePersonalizationsInput = {
    create?: XOR<CartItemCreateWithoutImagePersonalizationsInput, CartItemUncheckedCreateWithoutImagePersonalizationsInput>
    connectOrCreate?: CartItemCreateOrConnectWithoutImagePersonalizationsInput
    connect?: CartItemWhereUniqueInput
  }

  export type MediaUncheckedCreateNestedManyWithoutImagePersonalizationInput = {
    create?: XOR<MediaCreateWithoutImagePersonalizationInput, MediaUncheckedCreateWithoutImagePersonalizationInput> | MediaCreateWithoutImagePersonalizationInput[] | MediaUncheckedCreateWithoutImagePersonalizationInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutImagePersonalizationInput | MediaCreateOrConnectWithoutImagePersonalizationInput[]
    createMany?: MediaCreateManyImagePersonalizationInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type MediaUpdateManyWithoutImagePersonalizationNestedInput = {
    create?: XOR<MediaCreateWithoutImagePersonalizationInput, MediaUncheckedCreateWithoutImagePersonalizationInput> | MediaCreateWithoutImagePersonalizationInput[] | MediaUncheckedCreateWithoutImagePersonalizationInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutImagePersonalizationInput | MediaCreateOrConnectWithoutImagePersonalizationInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutImagePersonalizationInput | MediaUpsertWithWhereUniqueWithoutImagePersonalizationInput[]
    createMany?: MediaCreateManyImagePersonalizationInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutImagePersonalizationInput | MediaUpdateWithWhereUniqueWithoutImagePersonalizationInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutImagePersonalizationInput | MediaUpdateManyWithWhereWithoutImagePersonalizationInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type CartItemUpdateOneWithoutImagePersonalizationsNestedInput = {
    create?: XOR<CartItemCreateWithoutImagePersonalizationsInput, CartItemUncheckedCreateWithoutImagePersonalizationsInput>
    connectOrCreate?: CartItemCreateOrConnectWithoutImagePersonalizationsInput
    upsert?: CartItemUpsertWithoutImagePersonalizationsInput
    disconnect?: CartItemWhereInput | boolean
    delete?: CartItemWhereInput | boolean
    connect?: CartItemWhereUniqueInput
    update?: XOR<XOR<CartItemUpdateToOneWithWhereWithoutImagePersonalizationsInput, CartItemUpdateWithoutImagePersonalizationsInput>, CartItemUncheckedUpdateWithoutImagePersonalizationsInput>
  }

  export type MediaUncheckedUpdateManyWithoutImagePersonalizationNestedInput = {
    create?: XOR<MediaCreateWithoutImagePersonalizationInput, MediaUncheckedCreateWithoutImagePersonalizationInput> | MediaCreateWithoutImagePersonalizationInput[] | MediaUncheckedCreateWithoutImagePersonalizationInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutImagePersonalizationInput | MediaCreateOrConnectWithoutImagePersonalizationInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutImagePersonalizationInput | MediaUpsertWithWhereUniqueWithoutImagePersonalizationInput[]
    createMany?: MediaCreateManyImagePersonalizationInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutImagePersonalizationInput | MediaUpdateWithWhereUniqueWithoutImagePersonalizationInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutImagePersonalizationInput | MediaUpdateManyWithWhereWithoutImagePersonalizationInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDeliveryAddressesInput = {
    create?: XOR<UserCreateWithoutDeliveryAddressesInput, UserUncheckedCreateWithoutDeliveryAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeliveryAddressesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDeliveryAddressTypeFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryAddressType
  }

  export type UserUpdateOneRequiredWithoutDeliveryAddressesNestedInput = {
    create?: XOR<UserCreateWithoutDeliveryAddressesInput, UserUncheckedCreateWithoutDeliveryAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeliveryAddressesInput
    upsert?: UserUpsertWithoutDeliveryAddressesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeliveryAddressesInput, UserUpdateWithoutDeliveryAddressesInput>, UserUncheckedUpdateWithoutDeliveryAddressesInput>
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumOrderDeliveryTypeFieldUpdateOperationsInput = {
    set?: $Enums.OrderDeliveryType
  }

  export type EnumOrderPaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.OrderPaymentType
  }

  export type EnumOrderStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatusType
  }

  export type NullableEnumOrderPaymentStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.OrderPaymentStatusType | null
  }

  export type UserUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type MediaCreateNestedManyWithoutUserInput = {
    create?: XOR<MediaCreateWithoutUserInput, MediaUncheckedCreateWithoutUserInput> | MediaCreateWithoutUserInput[] | MediaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutUserInput | MediaCreateOrConnectWithoutUserInput[]
    createMany?: MediaCreateManyUserInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type CartCreateNestedOneWithoutUserInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
    connectOrCreate?: CartCreateOrConnectWithoutUserInput
    connect?: CartWhereUniqueInput
  }

  export type DeliveryAddressCreateNestedManyWithoutUserInput = {
    create?: XOR<DeliveryAddressCreateWithoutUserInput, DeliveryAddressUncheckedCreateWithoutUserInput> | DeliveryAddressCreateWithoutUserInput[] | DeliveryAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeliveryAddressCreateOrConnectWithoutUserInput | DeliveryAddressCreateOrConnectWithoutUserInput[]
    createMany?: DeliveryAddressCreateManyUserInputEnvelope
    connect?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type RatingCreateNestedManyWithoutUserInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MediaCreateWithoutUserInput, MediaUncheckedCreateWithoutUserInput> | MediaCreateWithoutUserInput[] | MediaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutUserInput | MediaCreateOrConnectWithoutUserInput[]
    createMany?: MediaCreateManyUserInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type CartUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
    connectOrCreate?: CartCreateOrConnectWithoutUserInput
    connect?: CartWhereUniqueInput
  }

  export type DeliveryAddressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeliveryAddressCreateWithoutUserInput, DeliveryAddressUncheckedCreateWithoutUserInput> | DeliveryAddressCreateWithoutUserInput[] | DeliveryAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeliveryAddressCreateOrConnectWithoutUserInput | DeliveryAddressCreateOrConnectWithoutUserInput[]
    createMany?: DeliveryAddressCreateManyUserInputEnvelope
    connect?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type EnumUserRoleTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserRoleType
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type MediaUpdateManyWithoutUserNestedInput = {
    create?: XOR<MediaCreateWithoutUserInput, MediaUncheckedCreateWithoutUserInput> | MediaCreateWithoutUserInput[] | MediaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutUserInput | MediaCreateOrConnectWithoutUserInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutUserInput | MediaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MediaCreateManyUserInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutUserInput | MediaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutUserInput | MediaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type CartUpdateOneWithoutUserNestedInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
    connectOrCreate?: CartCreateOrConnectWithoutUserInput
    upsert?: CartUpsertWithoutUserInput
    disconnect?: CartWhereInput | boolean
    delete?: CartWhereInput | boolean
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutUserInput, CartUpdateWithoutUserInput>, CartUncheckedUpdateWithoutUserInput>
  }

  export type DeliveryAddressUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeliveryAddressCreateWithoutUserInput, DeliveryAddressUncheckedCreateWithoutUserInput> | DeliveryAddressCreateWithoutUserInput[] | DeliveryAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeliveryAddressCreateOrConnectWithoutUserInput | DeliveryAddressCreateOrConnectWithoutUserInput[]
    upsert?: DeliveryAddressUpsertWithWhereUniqueWithoutUserInput | DeliveryAddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeliveryAddressCreateManyUserInputEnvelope
    set?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
    disconnect?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
    delete?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
    connect?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
    update?: DeliveryAddressUpdateWithWhereUniqueWithoutUserInput | DeliveryAddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeliveryAddressUpdateManyWithWhereWithoutUserInput | DeliveryAddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeliveryAddressScalarWhereInput | DeliveryAddressScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type RatingUpdateManyWithoutUserNestedInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutUserInput | RatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutUserInput | RatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutUserInput | RatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MediaCreateWithoutUserInput, MediaUncheckedCreateWithoutUserInput> | MediaCreateWithoutUserInput[] | MediaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutUserInput | MediaCreateOrConnectWithoutUserInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutUserInput | MediaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MediaCreateManyUserInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutUserInput | MediaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutUserInput | MediaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type CartUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
    connectOrCreate?: CartCreateOrConnectWithoutUserInput
    upsert?: CartUpsertWithoutUserInput
    disconnect?: CartWhereInput | boolean
    delete?: CartWhereInput | boolean
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutUserInput, CartUpdateWithoutUserInput>, CartUncheckedUpdateWithoutUserInput>
  }

  export type DeliveryAddressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeliveryAddressCreateWithoutUserInput, DeliveryAddressUncheckedCreateWithoutUserInput> | DeliveryAddressCreateWithoutUserInput[] | DeliveryAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeliveryAddressCreateOrConnectWithoutUserInput | DeliveryAddressCreateOrConnectWithoutUserInput[]
    upsert?: DeliveryAddressUpsertWithWhereUniqueWithoutUserInput | DeliveryAddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeliveryAddressCreateManyUserInputEnvelope
    set?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
    disconnect?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
    delete?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
    connect?: DeliveryAddressWhereUniqueInput | DeliveryAddressWhereUniqueInput[]
    update?: DeliveryAddressUpdateWithWhereUniqueWithoutUserInput | DeliveryAddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeliveryAddressUpdateManyWithWhereWithoutUserInput | DeliveryAddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeliveryAddressScalarWhereInput | DeliveryAddressScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutUserInput | RatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutUserInput | RatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutUserInput | RatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumDeliveryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryType | EnumDeliveryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryTypeFilter<$PrismaModel> | $Enums.DeliveryType
  }

  export type NestedEnumDeliveryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryType | EnumDeliveryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryTypeFilter<$PrismaModel>
    _max?: NestedEnumDeliveryTypeFilter<$PrismaModel>
  }

  export type NestedEnumRatingStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RatingStatusType | EnumRatingStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RatingStatusType[] | ListEnumRatingStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RatingStatusType[] | ListEnumRatingStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRatingStatusTypeFilter<$PrismaModel> | $Enums.RatingStatusType
  }

  export type NestedEnumRatingStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RatingStatusType | EnumRatingStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RatingStatusType[] | ListEnumRatingStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RatingStatusType[] | ListEnumRatingStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRatingStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.RatingStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRatingStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumRatingStatusTypeFilter<$PrismaModel>
  }

  export type NestedEnumFontTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FontType | EnumFontTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FontType[] | ListEnumFontTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FontType[] | ListEnumFontTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFontTypeFilter<$PrismaModel> | $Enums.FontType
  }

  export type NestedEnumFontTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FontType | EnumFontTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FontType[] | ListEnumFontTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FontType[] | ListEnumFontTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFontTypeWithAggregatesFilter<$PrismaModel> | $Enums.FontType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFontTypeFilter<$PrismaModel>
    _max?: NestedEnumFontTypeFilter<$PrismaModel>
  }

  export type NestedEnumDeliveryAddressTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryAddressType | EnumDeliveryAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryAddressType[] | ListEnumDeliveryAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryAddressType[] | ListEnumDeliveryAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryAddressTypeFilter<$PrismaModel> | $Enums.DeliveryAddressType
  }

  export type NestedEnumDeliveryAddressTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryAddressType | EnumDeliveryAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryAddressType[] | ListEnumDeliveryAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryAddressType[] | ListEnumDeliveryAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryAddressTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryAddressType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryAddressTypeFilter<$PrismaModel>
    _max?: NestedEnumDeliveryAddressTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderDeliveryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderDeliveryType | EnumOrderDeliveryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderDeliveryType[] | ListEnumOrderDeliveryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderDeliveryType[] | ListEnumOrderDeliveryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderDeliveryTypeFilter<$PrismaModel> | $Enums.OrderDeliveryType
  }

  export type NestedEnumOrderPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderPaymentType | EnumOrderPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderPaymentType[] | ListEnumOrderPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderPaymentType[] | ListEnumOrderPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderPaymentTypeFilter<$PrismaModel> | $Enums.OrderPaymentType
  }

  export type NestedEnumOrderStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatusType | EnumOrderStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatusType[] | ListEnumOrderStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatusType[] | ListEnumOrderStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusTypeFilter<$PrismaModel> | $Enums.OrderStatusType
  }

  export type NestedEnumOrderPaymentStatusTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderPaymentStatusType | EnumOrderPaymentStatusTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderPaymentStatusType[] | ListEnumOrderPaymentStatusTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderPaymentStatusType[] | ListEnumOrderPaymentStatusTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderPaymentStatusTypeNullableFilter<$PrismaModel> | $Enums.OrderPaymentStatusType | null
  }

  export type NestedEnumOrderDeliveryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderDeliveryType | EnumOrderDeliveryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderDeliveryType[] | ListEnumOrderDeliveryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderDeliveryType[] | ListEnumOrderDeliveryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderDeliveryTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderDeliveryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderDeliveryTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderDeliveryTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderPaymentType | EnumOrderPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderPaymentType[] | ListEnumOrderPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderPaymentType[] | ListEnumOrderPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderPaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderPaymentTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatusType | EnumOrderStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatusType[] | ListEnumOrderStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatusType[] | ListEnumOrderStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderPaymentStatusTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderPaymentStatusType | EnumOrderPaymentStatusTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderPaymentStatusType[] | ListEnumOrderPaymentStatusTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderPaymentStatusType[] | ListEnumOrderPaymentStatusTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderPaymentStatusTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderPaymentStatusType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderPaymentStatusTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderPaymentStatusTypeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumUserRoleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRoleType | EnumUserRoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserRoleType[] | ListEnumUserRoleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRoleType[] | ListEnumUserRoleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleTypeFilter<$PrismaModel> | $Enums.UserRoleType
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRoleType | EnumUserRoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserRoleType[] | ListEnumUserRoleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRoleType[] | ListEnumUserRoleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserRoleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleTypeFilter<$PrismaModel>
    _max?: NestedEnumUserRoleTypeFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type MediaCreateWithoutCategoryInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    updatedAt?: Date | string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutMediaInput
    deliveryService?: DeliveryServiceCreateNestedOneWithoutPdfInput
    desktopBannerImage?: BannerCreateNestedOneWithoutDesktopImageInput
    mobileBannerImage?: BannerCreateNestedOneWithoutMobileImageInput
    productCover?: ProductCreateNestedOneWithoutCoverImageInput
    productImages?: ProductCreateNestedOneWithoutImagesInput
    imagePersonalization?: ImagePersonalizationCreateNestedOneWithoutImagesInput
  }

  export type MediaUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    userId?: string | null
    deliveryServiceId?: string | null
    desktopBannerImageId?: string | null
    mobileBannerImageId?: string | null
    productCoverId?: string | null
    productImagesId?: string | null
    imagePersonalizationId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type MediaCreateOrConnectWithoutCategoryInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutCategoryInput, MediaUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateWithoutCategoriesInput = {
    id?: string
    name: string
    code: string
    price: number
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    priceTable?: PriceRangeCreateNestedManyWithoutProductInput
    discount?: DiscountCreateNestedOneWithoutProductsInput
    packageOption?: PackageOptionCreateNestedOneWithoutProductsInput
    coverImage?: MediaCreateNestedOneWithoutProductCoverInput
    images?: MediaCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    ratings?: RatingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name: string
    code: string
    price: number
    discountId?: string | null
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    packageOptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    priceTable?: PriceRangeUncheckedCreateNestedManyWithoutProductInput
    coverImage?: MediaUncheckedCreateNestedOneWithoutProductCoverInput
    images?: MediaUncheckedCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type MediaUpsertWithoutCategoryInput = {
    update: XOR<MediaUpdateWithoutCategoryInput, MediaUncheckedUpdateWithoutCategoryInput>
    create: XOR<MediaCreateWithoutCategoryInput, MediaUncheckedCreateWithoutCategoryInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutCategoryInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutCategoryInput, MediaUncheckedUpdateWithoutCategoryInput>
  }

  export type MediaUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMediaNestedInput
    deliveryService?: DeliveryServiceUpdateOneWithoutPdfNestedInput
    desktopBannerImage?: BannerUpdateOneWithoutDesktopImageNestedInput
    mobileBannerImage?: BannerUpdateOneWithoutMobileImageNestedInput
    productCover?: ProductUpdateOneWithoutCoverImageNestedInput
    productImages?: ProductUpdateOneWithoutImagesNestedInput
    imagePersonalization?: ImagePersonalizationUpdateOneWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    desktopBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    mobileBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    productCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    productImagesId?: NullableStringFieldUpdateOperationsInput | string | null
    imagePersonalizationId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoriesInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    code?: StringFilter<"Product"> | string
    price?: IntFilter<"Product"> | number
    discountId?: StringNullableFilter<"Product"> | string | null
    material?: StringFilter<"Product"> | string
    dimensions?: StringFilter<"Product"> | string
    personalization?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    delivery?: EnumDeliveryTypeFilter<"Product"> | $Enums.DeliveryType
    inStock?: BoolFilter<"Product"> | boolean
    trending?: BoolFilter<"Product"> | boolean
    packageOptionId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type ProductCreateWithoutPackageOptionInput = {
    id?: string
    name: string
    code: string
    price: number
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeCreateNestedManyWithoutProductInput
    discount?: DiscountCreateNestedOneWithoutProductsInput
    coverImage?: MediaCreateNestedOneWithoutProductCoverInput
    images?: MediaCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    ratings?: RatingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPackageOptionInput = {
    id?: string
    name: string
    code: string
    price: number
    discountId?: string | null
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeUncheckedCreateNestedManyWithoutProductInput
    coverImage?: MediaUncheckedCreateNestedOneWithoutProductCoverInput
    images?: MediaUncheckedCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPackageOptionInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPackageOptionInput, ProductUncheckedCreateWithoutPackageOptionInput>
  }

  export type ProductCreateManyPackageOptionInputEnvelope = {
    data: ProductCreateManyPackageOptionInput | ProductCreateManyPackageOptionInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutPackageOptionInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutPackageOptionInput, ProductUncheckedUpdateWithoutPackageOptionInput>
    create: XOR<ProductCreateWithoutPackageOptionInput, ProductUncheckedCreateWithoutPackageOptionInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutPackageOptionInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutPackageOptionInput, ProductUncheckedUpdateWithoutPackageOptionInput>
  }

  export type ProductUpdateManyWithWhereWithoutPackageOptionInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutPackageOptionInput>
  }

  export type MediaCreateWithoutDeliveryServiceInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    updatedAt?: Date | string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutMediaInput
    category?: CategoryCreateNestedOneWithoutImageInput
    desktopBannerImage?: BannerCreateNestedOneWithoutDesktopImageInput
    mobileBannerImage?: BannerCreateNestedOneWithoutMobileImageInput
    productCover?: ProductCreateNestedOneWithoutCoverImageInput
    productImages?: ProductCreateNestedOneWithoutImagesInput
    imagePersonalization?: ImagePersonalizationCreateNestedOneWithoutImagesInput
  }

  export type MediaUncheckedCreateWithoutDeliveryServiceInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    userId?: string | null
    categoryId?: string | null
    desktopBannerImageId?: string | null
    mobileBannerImageId?: string | null
    productCoverId?: string | null
    productImagesId?: string | null
    imagePersonalizationId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type MediaCreateOrConnectWithoutDeliveryServiceInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutDeliveryServiceInput, MediaUncheckedCreateWithoutDeliveryServiceInput>
  }

  export type MediaUpsertWithoutDeliveryServiceInput = {
    update: XOR<MediaUpdateWithoutDeliveryServiceInput, MediaUncheckedUpdateWithoutDeliveryServiceInput>
    create: XOR<MediaCreateWithoutDeliveryServiceInput, MediaUncheckedCreateWithoutDeliveryServiceInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutDeliveryServiceInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutDeliveryServiceInput, MediaUncheckedUpdateWithoutDeliveryServiceInput>
  }

  export type MediaUpdateWithoutDeliveryServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMediaNestedInput
    category?: CategoryUpdateOneWithoutImageNestedInput
    desktopBannerImage?: BannerUpdateOneWithoutDesktopImageNestedInput
    mobileBannerImage?: BannerUpdateOneWithoutMobileImageNestedInput
    productCover?: ProductUpdateOneWithoutCoverImageNestedInput
    productImages?: ProductUpdateOneWithoutImagesNestedInput
    imagePersonalization?: ImagePersonalizationUpdateOneWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateWithoutDeliveryServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    desktopBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    mobileBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    productCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    productImagesId?: NullableStringFieldUpdateOperationsInput | string | null
    imagePersonalizationId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateWithoutDesktopBannerImageInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    updatedAt?: Date | string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutMediaInput
    category?: CategoryCreateNestedOneWithoutImageInput
    deliveryService?: DeliveryServiceCreateNestedOneWithoutPdfInput
    mobileBannerImage?: BannerCreateNestedOneWithoutMobileImageInput
    productCover?: ProductCreateNestedOneWithoutCoverImageInput
    productImages?: ProductCreateNestedOneWithoutImagesInput
    imagePersonalization?: ImagePersonalizationCreateNestedOneWithoutImagesInput
  }

  export type MediaUncheckedCreateWithoutDesktopBannerImageInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    userId?: string | null
    categoryId?: string | null
    deliveryServiceId?: string | null
    mobileBannerImageId?: string | null
    productCoverId?: string | null
    productImagesId?: string | null
    imagePersonalizationId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type MediaCreateOrConnectWithoutDesktopBannerImageInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutDesktopBannerImageInput, MediaUncheckedCreateWithoutDesktopBannerImageInput>
  }

  export type MediaCreateWithoutMobileBannerImageInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    updatedAt?: Date | string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutMediaInput
    category?: CategoryCreateNestedOneWithoutImageInput
    deliveryService?: DeliveryServiceCreateNestedOneWithoutPdfInput
    desktopBannerImage?: BannerCreateNestedOneWithoutDesktopImageInput
    productCover?: ProductCreateNestedOneWithoutCoverImageInput
    productImages?: ProductCreateNestedOneWithoutImagesInput
    imagePersonalization?: ImagePersonalizationCreateNestedOneWithoutImagesInput
  }

  export type MediaUncheckedCreateWithoutMobileBannerImageInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    userId?: string | null
    categoryId?: string | null
    deliveryServiceId?: string | null
    desktopBannerImageId?: string | null
    productCoverId?: string | null
    productImagesId?: string | null
    imagePersonalizationId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type MediaCreateOrConnectWithoutMobileBannerImageInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutMobileBannerImageInput, MediaUncheckedCreateWithoutMobileBannerImageInput>
  }

  export type MediaUpsertWithoutDesktopBannerImageInput = {
    update: XOR<MediaUpdateWithoutDesktopBannerImageInput, MediaUncheckedUpdateWithoutDesktopBannerImageInput>
    create: XOR<MediaCreateWithoutDesktopBannerImageInput, MediaUncheckedCreateWithoutDesktopBannerImageInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutDesktopBannerImageInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutDesktopBannerImageInput, MediaUncheckedUpdateWithoutDesktopBannerImageInput>
  }

  export type MediaUpdateWithoutDesktopBannerImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMediaNestedInput
    category?: CategoryUpdateOneWithoutImageNestedInput
    deliveryService?: DeliveryServiceUpdateOneWithoutPdfNestedInput
    mobileBannerImage?: BannerUpdateOneWithoutMobileImageNestedInput
    productCover?: ProductUpdateOneWithoutCoverImageNestedInput
    productImages?: ProductUpdateOneWithoutImagesNestedInput
    imagePersonalization?: ImagePersonalizationUpdateOneWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateWithoutDesktopBannerImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    mobileBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    productCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    productImagesId?: NullableStringFieldUpdateOperationsInput | string | null
    imagePersonalizationId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUpsertWithoutMobileBannerImageInput = {
    update: XOR<MediaUpdateWithoutMobileBannerImageInput, MediaUncheckedUpdateWithoutMobileBannerImageInput>
    create: XOR<MediaCreateWithoutMobileBannerImageInput, MediaUncheckedCreateWithoutMobileBannerImageInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutMobileBannerImageInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutMobileBannerImageInput, MediaUncheckedUpdateWithoutMobileBannerImageInput>
  }

  export type MediaUpdateWithoutMobileBannerImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMediaNestedInput
    category?: CategoryUpdateOneWithoutImageNestedInput
    deliveryService?: DeliveryServiceUpdateOneWithoutPdfNestedInput
    desktopBannerImage?: BannerUpdateOneWithoutDesktopImageNestedInput
    productCover?: ProductUpdateOneWithoutCoverImageNestedInput
    productImages?: ProductUpdateOneWithoutImagesNestedInput
    imagePersonalization?: ImagePersonalizationUpdateOneWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateWithoutMobileBannerImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    desktopBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    productCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    productImagesId?: NullableStringFieldUpdateOperationsInput | string | null
    imagePersonalizationId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartCreateWithoutCouponInput = {
    id?: string
    onlinePrice: number
    totalPrice: number
    deliveryFee: number
    totalPriceWithDeliveryFee: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCartInput
    items?: CartItemCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateWithoutCouponInput = {
    id?: string
    userId: string
    onlinePrice: number
    totalPrice: number
    deliveryFee: number
    totalPriceWithDeliveryFee: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartCreateOrConnectWithoutCouponInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutCouponInput, CartUncheckedCreateWithoutCouponInput>
  }

  export type CartCreateManyCouponInputEnvelope = {
    data: CartCreateManyCouponInput | CartCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type CartUpsertWithWhereUniqueWithoutCouponInput = {
    where: CartWhereUniqueInput
    update: XOR<CartUpdateWithoutCouponInput, CartUncheckedUpdateWithoutCouponInput>
    create: XOR<CartCreateWithoutCouponInput, CartUncheckedCreateWithoutCouponInput>
  }

  export type CartUpdateWithWhereUniqueWithoutCouponInput = {
    where: CartWhereUniqueInput
    data: XOR<CartUpdateWithoutCouponInput, CartUncheckedUpdateWithoutCouponInput>
  }

  export type CartUpdateManyWithWhereWithoutCouponInput = {
    where: CartScalarWhereInput
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyWithoutCouponInput>
  }

  export type CartScalarWhereInput = {
    AND?: CartScalarWhereInput | CartScalarWhereInput[]
    OR?: CartScalarWhereInput[]
    NOT?: CartScalarWhereInput | CartScalarWhereInput[]
    id?: StringFilter<"Cart"> | string
    userId?: StringFilter<"Cart"> | string
    onlinePrice?: IntFilter<"Cart"> | number
    totalPrice?: IntFilter<"Cart"> | number
    deliveryFee?: IntFilter<"Cart"> | number
    totalPriceWithDeliveryFee?: IntFilter<"Cart"> | number
    discount?: IntFilter<"Cart"> | number
    couponId?: StringNullableFilter<"Cart"> | string | null
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
  }

  export type PriceRangeCreateWithoutDeliveryFeeInput = {
    id?: string
    from: number
    to: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedOneWithoutPriceTableInput
  }

  export type PriceRangeUncheckedCreateWithoutDeliveryFeeInput = {
    id?: string
    from: number
    to: number
    price: number
    productId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceRangeCreateOrConnectWithoutDeliveryFeeInput = {
    where: PriceRangeWhereUniqueInput
    create: XOR<PriceRangeCreateWithoutDeliveryFeeInput, PriceRangeUncheckedCreateWithoutDeliveryFeeInput>
  }

  export type PriceRangeCreateManyDeliveryFeeInputEnvelope = {
    data: PriceRangeCreateManyDeliveryFeeInput | PriceRangeCreateManyDeliveryFeeInput[]
    skipDuplicates?: boolean
  }

  export type PriceRangeUpsertWithWhereUniqueWithoutDeliveryFeeInput = {
    where: PriceRangeWhereUniqueInput
    update: XOR<PriceRangeUpdateWithoutDeliveryFeeInput, PriceRangeUncheckedUpdateWithoutDeliveryFeeInput>
    create: XOR<PriceRangeCreateWithoutDeliveryFeeInput, PriceRangeUncheckedCreateWithoutDeliveryFeeInput>
  }

  export type PriceRangeUpdateWithWhereUniqueWithoutDeliveryFeeInput = {
    where: PriceRangeWhereUniqueInput
    data: XOR<PriceRangeUpdateWithoutDeliveryFeeInput, PriceRangeUncheckedUpdateWithoutDeliveryFeeInput>
  }

  export type PriceRangeUpdateManyWithWhereWithoutDeliveryFeeInput = {
    where: PriceRangeScalarWhereInput
    data: XOR<PriceRangeUpdateManyMutationInput, PriceRangeUncheckedUpdateManyWithoutDeliveryFeeInput>
  }

  export type PriceRangeScalarWhereInput = {
    AND?: PriceRangeScalarWhereInput | PriceRangeScalarWhereInput[]
    OR?: PriceRangeScalarWhereInput[]
    NOT?: PriceRangeScalarWhereInput | PriceRangeScalarWhereInput[]
    id?: StringFilter<"PriceRange"> | string
    from?: IntFilter<"PriceRange"> | number
    to?: IntFilter<"PriceRange"> | number
    price?: IntFilter<"PriceRange"> | number
    deliveryFeeId?: StringFilter<"PriceRange"> | string
    productId?: StringNullableFilter<"PriceRange"> | string | null
    createdAt?: DateTimeFilter<"PriceRange"> | Date | string
    updatedAt?: DateTimeFilter<"PriceRange"> | Date | string
  }

  export type DeliveryFeeCreateWithoutPriceRangeInput = {
    id?: string
    name: string
    fee: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryFeeUncheckedCreateWithoutPriceRangeInput = {
    id?: string
    name: string
    fee: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryFeeCreateOrConnectWithoutPriceRangeInput = {
    where: DeliveryFeeWhereUniqueInput
    create: XOR<DeliveryFeeCreateWithoutPriceRangeInput, DeliveryFeeUncheckedCreateWithoutPriceRangeInput>
  }

  export type ProductCreateWithoutPriceTableInput = {
    id?: string
    name: string
    code: string
    price: number
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutProductsInput
    discount?: DiscountCreateNestedOneWithoutProductsInput
    packageOption?: PackageOptionCreateNestedOneWithoutProductsInput
    coverImage?: MediaCreateNestedOneWithoutProductCoverInput
    images?: MediaCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    ratings?: RatingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPriceTableInput = {
    id?: string
    name: string
    code: string
    price: number
    discountId?: string | null
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    packageOptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    coverImage?: MediaUncheckedCreateNestedOneWithoutProductCoverInput
    images?: MediaUncheckedCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPriceTableInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPriceTableInput, ProductUncheckedCreateWithoutPriceTableInput>
  }

  export type DeliveryFeeUpsertWithoutPriceRangeInput = {
    update: XOR<DeliveryFeeUpdateWithoutPriceRangeInput, DeliveryFeeUncheckedUpdateWithoutPriceRangeInput>
    create: XOR<DeliveryFeeCreateWithoutPriceRangeInput, DeliveryFeeUncheckedCreateWithoutPriceRangeInput>
    where?: DeliveryFeeWhereInput
  }

  export type DeliveryFeeUpdateToOneWithWhereWithoutPriceRangeInput = {
    where?: DeliveryFeeWhereInput
    data: XOR<DeliveryFeeUpdateWithoutPriceRangeInput, DeliveryFeeUncheckedUpdateWithoutPriceRangeInput>
  }

  export type DeliveryFeeUpdateWithoutPriceRangeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryFeeUncheckedUpdateWithoutPriceRangeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutPriceTableInput = {
    update: XOR<ProductUpdateWithoutPriceTableInput, ProductUncheckedUpdateWithoutPriceTableInput>
    create: XOR<ProductCreateWithoutPriceTableInput, ProductUncheckedCreateWithoutPriceTableInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPriceTableInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPriceTableInput, ProductUncheckedUpdateWithoutPriceTableInput>
  }

  export type ProductUpdateWithoutPriceTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    discount?: DiscountUpdateOneWithoutProductsNestedInput
    packageOption?: PackageOptionUpdateOneWithoutProductsNestedInput
    coverImage?: MediaUpdateOneWithoutProductCoverNestedInput
    images?: MediaUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    ratings?: RatingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPriceTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    packageOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    coverImage?: MediaUncheckedUpdateOneWithoutProductCoverNestedInput
    images?: MediaUncheckedUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutDiscountInput = {
    id?: string
    name: string
    code: string
    price: number
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeCreateNestedManyWithoutProductInput
    packageOption?: PackageOptionCreateNestedOneWithoutProductsInput
    coverImage?: MediaCreateNestedOneWithoutProductCoverInput
    images?: MediaCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    ratings?: RatingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutDiscountInput = {
    id?: string
    name: string
    code: string
    price: number
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    packageOptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeUncheckedCreateNestedManyWithoutProductInput
    coverImage?: MediaUncheckedCreateNestedOneWithoutProductCoverInput
    images?: MediaUncheckedCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutDiscountInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutDiscountInput, ProductUncheckedCreateWithoutDiscountInput>
  }

  export type ProductCreateManyDiscountInputEnvelope = {
    data: ProductCreateManyDiscountInput | ProductCreateManyDiscountInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutDiscountInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutDiscountInput, ProductUncheckedUpdateWithoutDiscountInput>
    create: XOR<ProductCreateWithoutDiscountInput, ProductUncheckedCreateWithoutDiscountInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutDiscountInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutDiscountInput, ProductUncheckedUpdateWithoutDiscountInput>
  }

  export type ProductUpdateManyWithWhereWithoutDiscountInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutDiscountInput>
  }

  export type ProductCreateWithoutTextPersonalizationFieldsInput = {
    id?: string
    name: string
    code: string
    price: number
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeCreateNestedManyWithoutProductInput
    discount?: DiscountCreateNestedOneWithoutProductsInput
    packageOption?: PackageOptionCreateNestedOneWithoutProductsInput
    coverImage?: MediaCreateNestedOneWithoutProductCoverInput
    images?: MediaCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    ratings?: RatingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTextPersonalizationFieldsInput = {
    id?: string
    name: string
    code: string
    price: number
    discountId?: string | null
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    packageOptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeUncheckedCreateNestedManyWithoutProductInput
    coverImage?: MediaUncheckedCreateNestedOneWithoutProductCoverInput
    images?: MediaUncheckedCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTextPersonalizationFieldsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTextPersonalizationFieldsInput, ProductUncheckedCreateWithoutTextPersonalizationFieldsInput>
  }

  export type ProductUpsertWithoutTextPersonalizationFieldsInput = {
    update: XOR<ProductUpdateWithoutTextPersonalizationFieldsInput, ProductUncheckedUpdateWithoutTextPersonalizationFieldsInput>
    create: XOR<ProductCreateWithoutTextPersonalizationFieldsInput, ProductUncheckedCreateWithoutTextPersonalizationFieldsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTextPersonalizationFieldsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTextPersonalizationFieldsInput, ProductUncheckedUpdateWithoutTextPersonalizationFieldsInput>
  }

  export type ProductUpdateWithoutTextPersonalizationFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUpdateManyWithoutProductNestedInput
    discount?: DiscountUpdateOneWithoutProductsNestedInput
    packageOption?: PackageOptionUpdateOneWithoutProductsNestedInput
    coverImage?: MediaUpdateOneWithoutProductCoverNestedInput
    images?: MediaUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    ratings?: RatingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTextPersonalizationFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    packageOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUncheckedUpdateManyWithoutProductNestedInput
    coverImage?: MediaUncheckedUpdateOneWithoutProductCoverNestedInput
    images?: MediaUncheckedUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutImagePersonalizationFieldsInput = {
    id?: string
    name: string
    code: string
    price: number
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeCreateNestedManyWithoutProductInput
    discount?: DiscountCreateNestedOneWithoutProductsInput
    packageOption?: PackageOptionCreateNestedOneWithoutProductsInput
    coverImage?: MediaCreateNestedOneWithoutProductCoverInput
    images?: MediaCreateNestedManyWithoutProductImagesInput
    textPersonalizationFields?: TextPersonalizationFieldCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    ratings?: RatingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutImagePersonalizationFieldsInput = {
    id?: string
    name: string
    code: string
    price: number
    discountId?: string | null
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    packageOptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeUncheckedCreateNestedManyWithoutProductInput
    coverImage?: MediaUncheckedCreateNestedOneWithoutProductCoverInput
    images?: MediaUncheckedCreateNestedManyWithoutProductImagesInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutImagePersonalizationFieldsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutImagePersonalizationFieldsInput, ProductUncheckedCreateWithoutImagePersonalizationFieldsInput>
  }

  export type ProductUpsertWithoutImagePersonalizationFieldsInput = {
    update: XOR<ProductUpdateWithoutImagePersonalizationFieldsInput, ProductUncheckedUpdateWithoutImagePersonalizationFieldsInput>
    create: XOR<ProductCreateWithoutImagePersonalizationFieldsInput, ProductUncheckedCreateWithoutImagePersonalizationFieldsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutImagePersonalizationFieldsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutImagePersonalizationFieldsInput, ProductUncheckedUpdateWithoutImagePersonalizationFieldsInput>
  }

  export type ProductUpdateWithoutImagePersonalizationFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUpdateManyWithoutProductNestedInput
    discount?: DiscountUpdateOneWithoutProductsNestedInput
    packageOption?: PackageOptionUpdateOneWithoutProductsNestedInput
    coverImage?: MediaUpdateOneWithoutProductCoverNestedInput
    images?: MediaUpdateManyWithoutProductImagesNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    ratings?: RatingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutImagePersonalizationFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    packageOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUncheckedUpdateManyWithoutProductNestedInput
    coverImage?: MediaUncheckedUpdateOneWithoutProductCoverNestedInput
    images?: MediaUncheckedUpdateManyWithoutProductImagesNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    active?: boolean
    special?: boolean
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: MediaCreateNestedOneWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    active?: boolean
    special?: boolean
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: MediaUncheckedCreateNestedOneWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type PriceRangeCreateWithoutProductInput = {
    id?: string
    from: number
    to: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryFee: DeliveryFeeCreateNestedOneWithoutPriceRangeInput
  }

  export type PriceRangeUncheckedCreateWithoutProductInput = {
    id?: string
    from: number
    to: number
    price: number
    deliveryFeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceRangeCreateOrConnectWithoutProductInput = {
    where: PriceRangeWhereUniqueInput
    create: XOR<PriceRangeCreateWithoutProductInput, PriceRangeUncheckedCreateWithoutProductInput>
  }

  export type PriceRangeCreateManyProductInputEnvelope = {
    data: PriceRangeCreateManyProductInput | PriceRangeCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type DiscountCreateWithoutProductsInput = {
    id?: string
    name: string
    percentage: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    percentage: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountCreateOrConnectWithoutProductsInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutProductsInput, DiscountUncheckedCreateWithoutProductsInput>
  }

  export type PackageOptionCreateWithoutProductsInput = {
    id?: string
    name: string
    description: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageOptionUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    description: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageOptionCreateOrConnectWithoutProductsInput = {
    where: PackageOptionWhereUniqueInput
    create: XOR<PackageOptionCreateWithoutProductsInput, PackageOptionUncheckedCreateWithoutProductsInput>
  }

  export type MediaCreateWithoutProductCoverInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    updatedAt?: Date | string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutMediaInput
    category?: CategoryCreateNestedOneWithoutImageInput
    deliveryService?: DeliveryServiceCreateNestedOneWithoutPdfInput
    desktopBannerImage?: BannerCreateNestedOneWithoutDesktopImageInput
    mobileBannerImage?: BannerCreateNestedOneWithoutMobileImageInput
    productImages?: ProductCreateNestedOneWithoutImagesInput
    imagePersonalization?: ImagePersonalizationCreateNestedOneWithoutImagesInput
  }

  export type MediaUncheckedCreateWithoutProductCoverInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    userId?: string | null
    categoryId?: string | null
    deliveryServiceId?: string | null
    desktopBannerImageId?: string | null
    mobileBannerImageId?: string | null
    productImagesId?: string | null
    imagePersonalizationId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type MediaCreateOrConnectWithoutProductCoverInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutProductCoverInput, MediaUncheckedCreateWithoutProductCoverInput>
  }

  export type MediaCreateWithoutProductImagesInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    updatedAt?: Date | string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutMediaInput
    category?: CategoryCreateNestedOneWithoutImageInput
    deliveryService?: DeliveryServiceCreateNestedOneWithoutPdfInput
    desktopBannerImage?: BannerCreateNestedOneWithoutDesktopImageInput
    mobileBannerImage?: BannerCreateNestedOneWithoutMobileImageInput
    productCover?: ProductCreateNestedOneWithoutCoverImageInput
    imagePersonalization?: ImagePersonalizationCreateNestedOneWithoutImagesInput
  }

  export type MediaUncheckedCreateWithoutProductImagesInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    userId?: string | null
    categoryId?: string | null
    deliveryServiceId?: string | null
    desktopBannerImageId?: string | null
    mobileBannerImageId?: string | null
    productCoverId?: string | null
    imagePersonalizationId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type MediaCreateOrConnectWithoutProductImagesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutProductImagesInput, MediaUncheckedCreateWithoutProductImagesInput>
  }

  export type MediaCreateManyProductImagesInputEnvelope = {
    data: MediaCreateManyProductImagesInput | MediaCreateManyProductImagesInput[]
    skipDuplicates?: boolean
  }

  export type ImagePersonalizationFieldCreateWithoutProductInput = {
    id?: string
    name: string
    min: number
    max?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImagePersonalizationFieldUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    min: number
    max?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImagePersonalizationFieldCreateOrConnectWithoutProductInput = {
    where: ImagePersonalizationFieldWhereUniqueInput
    create: XOR<ImagePersonalizationFieldCreateWithoutProductInput, ImagePersonalizationFieldUncheckedCreateWithoutProductInput>
  }

  export type ImagePersonalizationFieldCreateManyProductInputEnvelope = {
    data: ImagePersonalizationFieldCreateManyProductInput | ImagePersonalizationFieldCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type TextPersonalizationFieldCreateWithoutProductInput = {
    id?: string
    name: string
    placeholder: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TextPersonalizationFieldUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    placeholder: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TextPersonalizationFieldCreateOrConnectWithoutProductInput = {
    where: TextPersonalizationFieldWhereUniqueInput
    create: XOR<TextPersonalizationFieldCreateWithoutProductInput, TextPersonalizationFieldUncheckedCreateWithoutProductInput>
  }

  export type TextPersonalizationFieldCreateManyProductInputEnvelope = {
    data: TextPersonalizationFieldCreateManyProductInput | TextPersonalizationFieldCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CartItemCreateWithoutProductInput = {
    id?: string
    price: number
    deliveryFee: number
    quantity: number
    fontType: $Enums.FontType
    packageOptionSelected: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: CartCreateNestedOneWithoutItemsInput
    textPersonalizations?: TextPersonalizationCreateNestedManyWithoutCartItemInput
    imagePersonalizations?: ImagePersonalizationCreateNestedManyWithoutCartItemInput
  }

  export type CartItemUncheckedCreateWithoutProductInput = {
    id?: string
    cartId: string
    price: number
    deliveryFee: number
    quantity: number
    fontType: $Enums.FontType
    packageOptionSelected: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    textPersonalizations?: TextPersonalizationUncheckedCreateNestedManyWithoutCartItemInput
    imagePersonalizations?: ImagePersonalizationUncheckedCreateNestedManyWithoutCartItemInput
  }

  export type CartItemCreateOrConnectWithoutProductInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemCreateManyProductInputEnvelope = {
    data: CartItemCreateManyProductInput | CartItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutProductInput = {
    id?: string
    name: string
    score: number
    comment: string
    status?: $Enums.RatingStatusType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateWithoutProductInput = {
    id?: string
    userId: string
    name: string
    score: number
    comment: string
    status?: $Enums.RatingStatusType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateOrConnectWithoutProductInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutProductInput, RatingUncheckedCreateWithoutProductInput>
  }

  export type RatingCreateManyProductInputEnvelope = {
    data: RatingCreateManyProductInput | RatingCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithWhereUniqueWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateManyWithWhereWithoutProductsInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutProductsInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    active?: BoolFilter<"Category"> | boolean
    special?: BoolFilter<"Category"> | boolean
    position?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
  }

  export type PriceRangeUpsertWithWhereUniqueWithoutProductInput = {
    where: PriceRangeWhereUniqueInput
    update: XOR<PriceRangeUpdateWithoutProductInput, PriceRangeUncheckedUpdateWithoutProductInput>
    create: XOR<PriceRangeCreateWithoutProductInput, PriceRangeUncheckedCreateWithoutProductInput>
  }

  export type PriceRangeUpdateWithWhereUniqueWithoutProductInput = {
    where: PriceRangeWhereUniqueInput
    data: XOR<PriceRangeUpdateWithoutProductInput, PriceRangeUncheckedUpdateWithoutProductInput>
  }

  export type PriceRangeUpdateManyWithWhereWithoutProductInput = {
    where: PriceRangeScalarWhereInput
    data: XOR<PriceRangeUpdateManyMutationInput, PriceRangeUncheckedUpdateManyWithoutProductInput>
  }

  export type DiscountUpsertWithoutProductsInput = {
    update: XOR<DiscountUpdateWithoutProductsInput, DiscountUncheckedUpdateWithoutProductsInput>
    create: XOR<DiscountCreateWithoutProductsInput, DiscountUncheckedCreateWithoutProductsInput>
    where?: DiscountWhereInput
  }

  export type DiscountUpdateToOneWithWhereWithoutProductsInput = {
    where?: DiscountWhereInput
    data: XOR<DiscountUpdateWithoutProductsInput, DiscountUncheckedUpdateWithoutProductsInput>
  }

  export type DiscountUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentage?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    percentage?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageOptionUpsertWithoutProductsInput = {
    update: XOR<PackageOptionUpdateWithoutProductsInput, PackageOptionUncheckedUpdateWithoutProductsInput>
    create: XOR<PackageOptionCreateWithoutProductsInput, PackageOptionUncheckedCreateWithoutProductsInput>
    where?: PackageOptionWhereInput
  }

  export type PackageOptionUpdateToOneWithWhereWithoutProductsInput = {
    where?: PackageOptionWhereInput
    data: XOR<PackageOptionUpdateWithoutProductsInput, PackageOptionUncheckedUpdateWithoutProductsInput>
  }

  export type PackageOptionUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageOptionUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUpsertWithoutProductCoverInput = {
    update: XOR<MediaUpdateWithoutProductCoverInput, MediaUncheckedUpdateWithoutProductCoverInput>
    create: XOR<MediaCreateWithoutProductCoverInput, MediaUncheckedCreateWithoutProductCoverInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutProductCoverInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutProductCoverInput, MediaUncheckedUpdateWithoutProductCoverInput>
  }

  export type MediaUpdateWithoutProductCoverInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMediaNestedInput
    category?: CategoryUpdateOneWithoutImageNestedInput
    deliveryService?: DeliveryServiceUpdateOneWithoutPdfNestedInput
    desktopBannerImage?: BannerUpdateOneWithoutDesktopImageNestedInput
    mobileBannerImage?: BannerUpdateOneWithoutMobileImageNestedInput
    productImages?: ProductUpdateOneWithoutImagesNestedInput
    imagePersonalization?: ImagePersonalizationUpdateOneWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateWithoutProductCoverInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    desktopBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    mobileBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    productImagesId?: NullableStringFieldUpdateOperationsInput | string | null
    imagePersonalizationId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUpsertWithWhereUniqueWithoutProductImagesInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutProductImagesInput, MediaUncheckedUpdateWithoutProductImagesInput>
    create: XOR<MediaCreateWithoutProductImagesInput, MediaUncheckedCreateWithoutProductImagesInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutProductImagesInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutProductImagesInput, MediaUncheckedUpdateWithoutProductImagesInput>
  }

  export type MediaUpdateManyWithWhereWithoutProductImagesInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutProductImagesInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: StringFilter<"Media"> | string
    name?: StringFilter<"Media"> | string
    key?: StringFilter<"Media"> | string
    type?: StringFilter<"Media"> | string
    url?: StringFilter<"Media"> | string
    userId?: StringNullableFilter<"Media"> | string | null
    categoryId?: StringNullableFilter<"Media"> | string | null
    deliveryServiceId?: StringNullableFilter<"Media"> | string | null
    desktopBannerImageId?: StringNullableFilter<"Media"> | string | null
    mobileBannerImageId?: StringNullableFilter<"Media"> | string | null
    productCoverId?: StringNullableFilter<"Media"> | string | null
    productImagesId?: StringNullableFilter<"Media"> | string | null
    imagePersonalizationId?: StringNullableFilter<"Media"> | string | null
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
  }

  export type ImagePersonalizationFieldUpsertWithWhereUniqueWithoutProductInput = {
    where: ImagePersonalizationFieldWhereUniqueInput
    update: XOR<ImagePersonalizationFieldUpdateWithoutProductInput, ImagePersonalizationFieldUncheckedUpdateWithoutProductInput>
    create: XOR<ImagePersonalizationFieldCreateWithoutProductInput, ImagePersonalizationFieldUncheckedCreateWithoutProductInput>
  }

  export type ImagePersonalizationFieldUpdateWithWhereUniqueWithoutProductInput = {
    where: ImagePersonalizationFieldWhereUniqueInput
    data: XOR<ImagePersonalizationFieldUpdateWithoutProductInput, ImagePersonalizationFieldUncheckedUpdateWithoutProductInput>
  }

  export type ImagePersonalizationFieldUpdateManyWithWhereWithoutProductInput = {
    where: ImagePersonalizationFieldScalarWhereInput
    data: XOR<ImagePersonalizationFieldUpdateManyMutationInput, ImagePersonalizationFieldUncheckedUpdateManyWithoutProductInput>
  }

  export type ImagePersonalizationFieldScalarWhereInput = {
    AND?: ImagePersonalizationFieldScalarWhereInput | ImagePersonalizationFieldScalarWhereInput[]
    OR?: ImagePersonalizationFieldScalarWhereInput[]
    NOT?: ImagePersonalizationFieldScalarWhereInput | ImagePersonalizationFieldScalarWhereInput[]
    id?: StringFilter<"ImagePersonalizationField"> | string
    name?: StringFilter<"ImagePersonalizationField"> | string
    min?: IntFilter<"ImagePersonalizationField"> | number
    max?: IntFilter<"ImagePersonalizationField"> | number
    productId?: StringNullableFilter<"ImagePersonalizationField"> | string | null
    createdAt?: DateTimeFilter<"ImagePersonalizationField"> | Date | string
    updatedAt?: DateTimeFilter<"ImagePersonalizationField"> | Date | string
  }

  export type TextPersonalizationFieldUpsertWithWhereUniqueWithoutProductInput = {
    where: TextPersonalizationFieldWhereUniqueInput
    update: XOR<TextPersonalizationFieldUpdateWithoutProductInput, TextPersonalizationFieldUncheckedUpdateWithoutProductInput>
    create: XOR<TextPersonalizationFieldCreateWithoutProductInput, TextPersonalizationFieldUncheckedCreateWithoutProductInput>
  }

  export type TextPersonalizationFieldUpdateWithWhereUniqueWithoutProductInput = {
    where: TextPersonalizationFieldWhereUniqueInput
    data: XOR<TextPersonalizationFieldUpdateWithoutProductInput, TextPersonalizationFieldUncheckedUpdateWithoutProductInput>
  }

  export type TextPersonalizationFieldUpdateManyWithWhereWithoutProductInput = {
    where: TextPersonalizationFieldScalarWhereInput
    data: XOR<TextPersonalizationFieldUpdateManyMutationInput, TextPersonalizationFieldUncheckedUpdateManyWithoutProductInput>
  }

  export type TextPersonalizationFieldScalarWhereInput = {
    AND?: TextPersonalizationFieldScalarWhereInput | TextPersonalizationFieldScalarWhereInput[]
    OR?: TextPersonalizationFieldScalarWhereInput[]
    NOT?: TextPersonalizationFieldScalarWhereInput | TextPersonalizationFieldScalarWhereInput[]
    id?: StringFilter<"TextPersonalizationField"> | string
    name?: StringFilter<"TextPersonalizationField"> | string
    placeholder?: StringFilter<"TextPersonalizationField"> | string
    productId?: StringNullableFilter<"TextPersonalizationField"> | string | null
    createdAt?: DateTimeFilter<"TextPersonalizationField"> | Date | string
    updatedAt?: DateTimeFilter<"TextPersonalizationField"> | Date | string
  }

  export type CartItemUpsertWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
  }

  export type CartItemUpdateManyWithWhereWithoutProductInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutProductInput>
  }

  export type CartItemScalarWhereInput = {
    AND?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    OR?: CartItemScalarWhereInput[]
    NOT?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    price?: IntFilter<"CartItem"> | number
    deliveryFee?: IntFilter<"CartItem"> | number
    quantity?: IntFilter<"CartItem"> | number
    fontType?: EnumFontTypeFilter<"CartItem"> | $Enums.FontType
    packageOptionSelected?: BoolFilter<"CartItem"> | boolean
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
  }

  export type RatingUpsertWithWhereUniqueWithoutProductInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutProductInput, RatingUncheckedUpdateWithoutProductInput>
    create: XOR<RatingCreateWithoutProductInput, RatingUncheckedCreateWithoutProductInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutProductInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutProductInput, RatingUncheckedUpdateWithoutProductInput>
  }

  export type RatingUpdateManyWithWhereWithoutProductInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutProductInput>
  }

  export type RatingScalarWhereInput = {
    AND?: RatingScalarWhereInput | RatingScalarWhereInput[]
    OR?: RatingScalarWhereInput[]
    NOT?: RatingScalarWhereInput | RatingScalarWhereInput[]
    id?: StringFilter<"Rating"> | string
    userId?: StringFilter<"Rating"> | string
    productId?: StringFilter<"Rating"> | string
    name?: StringFilter<"Rating"> | string
    score?: IntFilter<"Rating"> | number
    comment?: StringFilter<"Rating"> | string
    status?: EnumRatingStatusTypeFilter<"Rating"> | $Enums.RatingStatusType
    createdAt?: DateTimeFilter<"Rating"> | Date | string
    updatedAt?: DateTimeFilter<"Rating"> | Date | string
  }

  export type UserCreateWithoutRatingsInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.UserRoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    media?: MediaCreateNestedManyWithoutUserInput
    cart?: CartCreateNestedOneWithoutUserInput
    deliveryAddresses?: DeliveryAddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRatingsInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.UserRoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    media?: MediaUncheckedCreateNestedManyWithoutUserInput
    cart?: CartUncheckedCreateNestedOneWithoutUserInput
    deliveryAddresses?: DeliveryAddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
  }

  export type ProductCreateWithoutRatingsInput = {
    id?: string
    name: string
    code: string
    price: number
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeCreateNestedManyWithoutProductInput
    discount?: DiscountCreateNestedOneWithoutProductsInput
    packageOption?: PackageOptionCreateNestedOneWithoutProductsInput
    coverImage?: MediaCreateNestedOneWithoutProductCoverInput
    images?: MediaCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutRatingsInput = {
    id?: string
    name: string
    code: string
    price: number
    discountId?: string | null
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    packageOptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeUncheckedCreateNestedManyWithoutProductInput
    coverImage?: MediaUncheckedCreateNestedOneWithoutProductCoverInput
    images?: MediaUncheckedCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutRatingsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutRatingsInput, ProductUncheckedCreateWithoutRatingsInput>
  }

  export type UserUpsertWithoutRatingsInput = {
    update: XOR<UserUpdateWithoutRatingsInput, UserUncheckedUpdateWithoutRatingsInput>
    create: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRatingsInput, UserUncheckedUpdateWithoutRatingsInput>
  }

  export type UserUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: MediaUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneWithoutUserNestedInput
    deliveryAddresses?: DeliveryAddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: MediaUncheckedUpdateManyWithoutUserNestedInput
    cart?: CartUncheckedUpdateOneWithoutUserNestedInput
    deliveryAddresses?: DeliveryAddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductUpsertWithoutRatingsInput = {
    update: XOR<ProductUpdateWithoutRatingsInput, ProductUncheckedUpdateWithoutRatingsInput>
    create: XOR<ProductCreateWithoutRatingsInput, ProductUncheckedCreateWithoutRatingsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutRatingsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutRatingsInput, ProductUncheckedUpdateWithoutRatingsInput>
  }

  export type ProductUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUpdateManyWithoutProductNestedInput
    discount?: DiscountUpdateOneWithoutProductsNestedInput
    packageOption?: PackageOptionUpdateOneWithoutProductsNestedInput
    coverImage?: MediaUpdateOneWithoutProductCoverNestedInput
    images?: MediaUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    packageOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUncheckedUpdateManyWithoutProductNestedInput
    coverImage?: MediaUncheckedUpdateOneWithoutProductCoverNestedInput
    images?: MediaUncheckedUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutMediaInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.UserRoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    cart?: CartCreateNestedOneWithoutUserInput
    deliveryAddresses?: DeliveryAddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMediaInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.UserRoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    cart?: CartUncheckedCreateNestedOneWithoutUserInput
    deliveryAddresses?: DeliveryAddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMediaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
  }

  export type CategoryCreateWithoutImageInput = {
    id?: string
    name: string
    slug: string
    active?: boolean
    special?: boolean
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutImageInput = {
    id?: string
    name: string
    slug: string
    active?: boolean
    special?: boolean
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryCreateOrConnectWithoutImageInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutImageInput, CategoryUncheckedCreateWithoutImageInput>
  }

  export type DeliveryServiceCreateWithoutPdfInput = {
    id?: string
    name: string
    link: string
    active?: boolean
    predefinedPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryServiceUncheckedCreateWithoutPdfInput = {
    id?: string
    name: string
    link: string
    active?: boolean
    predefinedPrices?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryServiceCreateOrConnectWithoutPdfInput = {
    where: DeliveryServiceWhereUniqueInput
    create: XOR<DeliveryServiceCreateWithoutPdfInput, DeliveryServiceUncheckedCreateWithoutPdfInput>
  }

  export type BannerCreateWithoutDesktopImageInput = {
    id?: string
    name: string
    link: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mobileImage?: MediaCreateNestedOneWithoutMobileBannerImageInput
  }

  export type BannerUncheckedCreateWithoutDesktopImageInput = {
    id?: string
    name: string
    link: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mobileImage?: MediaUncheckedCreateNestedOneWithoutMobileBannerImageInput
  }

  export type BannerCreateOrConnectWithoutDesktopImageInput = {
    where: BannerWhereUniqueInput
    create: XOR<BannerCreateWithoutDesktopImageInput, BannerUncheckedCreateWithoutDesktopImageInput>
  }

  export type BannerCreateWithoutMobileImageInput = {
    id?: string
    name: string
    link: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    desktopImage?: MediaCreateNestedOneWithoutDesktopBannerImageInput
  }

  export type BannerUncheckedCreateWithoutMobileImageInput = {
    id?: string
    name: string
    link: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    desktopImage?: MediaUncheckedCreateNestedOneWithoutDesktopBannerImageInput
  }

  export type BannerCreateOrConnectWithoutMobileImageInput = {
    where: BannerWhereUniqueInput
    create: XOR<BannerCreateWithoutMobileImageInput, BannerUncheckedCreateWithoutMobileImageInput>
  }

  export type ProductCreateWithoutCoverImageInput = {
    id?: string
    name: string
    code: string
    price: number
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeCreateNestedManyWithoutProductInput
    discount?: DiscountCreateNestedOneWithoutProductsInput
    packageOption?: PackageOptionCreateNestedOneWithoutProductsInput
    images?: MediaCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    ratings?: RatingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCoverImageInput = {
    id?: string
    name: string
    code: string
    price: number
    discountId?: string | null
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    packageOptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeUncheckedCreateNestedManyWithoutProductInput
    images?: MediaUncheckedCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCoverImageInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCoverImageInput, ProductUncheckedCreateWithoutCoverImageInput>
  }

  export type ProductCreateWithoutImagesInput = {
    id?: string
    name: string
    code: string
    price: number
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeCreateNestedManyWithoutProductInput
    discount?: DiscountCreateNestedOneWithoutProductsInput
    packageOption?: PackageOptionCreateNestedOneWithoutProductsInput
    coverImage?: MediaCreateNestedOneWithoutProductCoverInput
    imagePersonalizationFields?: ImagePersonalizationFieldCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    ratings?: RatingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutImagesInput = {
    id?: string
    name: string
    code: string
    price: number
    discountId?: string | null
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    packageOptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeUncheckedCreateNestedManyWithoutProductInput
    coverImage?: MediaUncheckedCreateNestedOneWithoutProductCoverInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutImagesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
  }

  export type ImagePersonalizationCreateWithoutImagesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItem?: CartItemCreateNestedOneWithoutImagePersonalizationsInput
  }

  export type ImagePersonalizationUncheckedCreateWithoutImagesInput = {
    id?: string
    name: string
    cartItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImagePersonalizationCreateOrConnectWithoutImagesInput = {
    where: ImagePersonalizationWhereUniqueInput
    create: XOR<ImagePersonalizationCreateWithoutImagesInput, ImagePersonalizationUncheckedCreateWithoutImagesInput>
  }

  export type UserUpsertWithoutMediaInput = {
    update: XOR<UserUpdateWithoutMediaInput, UserUncheckedUpdateWithoutMediaInput>
    create: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMediaInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMediaInput, UserUncheckedUpdateWithoutMediaInput>
  }

  export type UserUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cart?: CartUpdateOneWithoutUserNestedInput
    deliveryAddresses?: DeliveryAddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cart?: CartUncheckedUpdateOneWithoutUserNestedInput
    deliveryAddresses?: DeliveryAddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CategoryUpsertWithoutImageInput = {
    update: XOR<CategoryUpdateWithoutImageInput, CategoryUncheckedUpdateWithoutImageInput>
    create: XOR<CategoryCreateWithoutImageInput, CategoryUncheckedCreateWithoutImageInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutImageInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutImageInput, CategoryUncheckedUpdateWithoutImageInput>
  }

  export type CategoryUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    special?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    special?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type DeliveryServiceUpsertWithoutPdfInput = {
    update: XOR<DeliveryServiceUpdateWithoutPdfInput, DeliveryServiceUncheckedUpdateWithoutPdfInput>
    create: XOR<DeliveryServiceCreateWithoutPdfInput, DeliveryServiceUncheckedCreateWithoutPdfInput>
    where?: DeliveryServiceWhereInput
  }

  export type DeliveryServiceUpdateToOneWithWhereWithoutPdfInput = {
    where?: DeliveryServiceWhereInput
    data: XOR<DeliveryServiceUpdateWithoutPdfInput, DeliveryServiceUncheckedUpdateWithoutPdfInput>
  }

  export type DeliveryServiceUpdateWithoutPdfInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    predefinedPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryServiceUncheckedUpdateWithoutPdfInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    predefinedPrices?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerUpsertWithoutDesktopImageInput = {
    update: XOR<BannerUpdateWithoutDesktopImageInput, BannerUncheckedUpdateWithoutDesktopImageInput>
    create: XOR<BannerCreateWithoutDesktopImageInput, BannerUncheckedCreateWithoutDesktopImageInput>
    where?: BannerWhereInput
  }

  export type BannerUpdateToOneWithWhereWithoutDesktopImageInput = {
    where?: BannerWhereInput
    data: XOR<BannerUpdateWithoutDesktopImageInput, BannerUncheckedUpdateWithoutDesktopImageInput>
  }

  export type BannerUpdateWithoutDesktopImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mobileImage?: MediaUpdateOneWithoutMobileBannerImageNestedInput
  }

  export type BannerUncheckedUpdateWithoutDesktopImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mobileImage?: MediaUncheckedUpdateOneWithoutMobileBannerImageNestedInput
  }

  export type BannerUpsertWithoutMobileImageInput = {
    update: XOR<BannerUpdateWithoutMobileImageInput, BannerUncheckedUpdateWithoutMobileImageInput>
    create: XOR<BannerCreateWithoutMobileImageInput, BannerUncheckedCreateWithoutMobileImageInput>
    where?: BannerWhereInput
  }

  export type BannerUpdateToOneWithWhereWithoutMobileImageInput = {
    where?: BannerWhereInput
    data: XOR<BannerUpdateWithoutMobileImageInput, BannerUncheckedUpdateWithoutMobileImageInput>
  }

  export type BannerUpdateWithoutMobileImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desktopImage?: MediaUpdateOneWithoutDesktopBannerImageNestedInput
  }

  export type BannerUncheckedUpdateWithoutMobileImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desktopImage?: MediaUncheckedUpdateOneWithoutDesktopBannerImageNestedInput
  }

  export type ProductUpsertWithoutCoverImageInput = {
    update: XOR<ProductUpdateWithoutCoverImageInput, ProductUncheckedUpdateWithoutCoverImageInput>
    create: XOR<ProductCreateWithoutCoverImageInput, ProductUncheckedCreateWithoutCoverImageInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCoverImageInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCoverImageInput, ProductUncheckedUpdateWithoutCoverImageInput>
  }

  export type ProductUpdateWithoutCoverImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUpdateManyWithoutProductNestedInput
    discount?: DiscountUpdateOneWithoutProductsNestedInput
    packageOption?: PackageOptionUpdateOneWithoutProductsNestedInput
    images?: MediaUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    ratings?: RatingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCoverImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    packageOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUncheckedUpdateManyWithoutProductNestedInput
    images?: MediaUncheckedUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUpsertWithoutImagesInput = {
    update: XOR<ProductUpdateWithoutImagesInput, ProductUncheckedUpdateWithoutImagesInput>
    create: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutImagesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutImagesInput, ProductUncheckedUpdateWithoutImagesInput>
  }

  export type ProductUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUpdateManyWithoutProductNestedInput
    discount?: DiscountUpdateOneWithoutProductsNestedInput
    packageOption?: PackageOptionUpdateOneWithoutProductsNestedInput
    coverImage?: MediaUpdateOneWithoutProductCoverNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    ratings?: RatingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    packageOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUncheckedUpdateManyWithoutProductNestedInput
    coverImage?: MediaUncheckedUpdateOneWithoutProductCoverNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ImagePersonalizationUpsertWithoutImagesInput = {
    update: XOR<ImagePersonalizationUpdateWithoutImagesInput, ImagePersonalizationUncheckedUpdateWithoutImagesInput>
    create: XOR<ImagePersonalizationCreateWithoutImagesInput, ImagePersonalizationUncheckedCreateWithoutImagesInput>
    where?: ImagePersonalizationWhereInput
  }

  export type ImagePersonalizationUpdateToOneWithWhereWithoutImagesInput = {
    where?: ImagePersonalizationWhereInput
    data: XOR<ImagePersonalizationUpdateWithoutImagesInput, ImagePersonalizationUncheckedUpdateWithoutImagesInput>
  }

  export type ImagePersonalizationUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItem?: CartItemUpdateOneWithoutImagePersonalizationsNestedInput
  }

  export type ImagePersonalizationUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cartItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutCartInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.UserRoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    media?: MediaCreateNestedManyWithoutUserInput
    deliveryAddresses?: DeliveryAddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCartInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.UserRoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    media?: MediaUncheckedCreateNestedManyWithoutUserInput
    deliveryAddresses?: DeliveryAddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCartInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
  }

  export type CartItemCreateWithoutCartInput = {
    id?: string
    price: number
    deliveryFee: number
    quantity: number
    fontType: $Enums.FontType
    packageOptionSelected: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutCartItemsInput
    textPersonalizations?: TextPersonalizationCreateNestedManyWithoutCartItemInput
    imagePersonalizations?: ImagePersonalizationCreateNestedManyWithoutCartItemInput
  }

  export type CartItemUncheckedCreateWithoutCartInput = {
    id?: string
    productId: string
    price: number
    deliveryFee: number
    quantity: number
    fontType: $Enums.FontType
    packageOptionSelected: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    textPersonalizations?: TextPersonalizationUncheckedCreateNestedManyWithoutCartItemInput
    imagePersonalizations?: ImagePersonalizationUncheckedCreateNestedManyWithoutCartItemInput
  }

  export type CartItemCreateOrConnectWithoutCartInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemCreateManyCartInputEnvelope = {
    data: CartItemCreateManyCartInput | CartItemCreateManyCartInput[]
    skipDuplicates?: boolean
  }

  export type CouponCreateWithoutCartsInput = {
    id?: string
    name: string
    code: string
    discountType: $Enums.DiscountType
    discount: number
    cartValue: number
    available: number
    used?: number
    active?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponUncheckedCreateWithoutCartsInput = {
    id?: string
    name: string
    code: string
    discountType: $Enums.DiscountType
    discount: number
    cartValue: number
    available: number
    used?: number
    active?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponCreateOrConnectWithoutCartsInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutCartsInput, CouponUncheckedCreateWithoutCartsInput>
  }

  export type UserUpsertWithoutCartInput = {
    update: XOR<UserUpdateWithoutCartInput, UserUncheckedUpdateWithoutCartInput>
    create: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCartInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCartInput, UserUncheckedUpdateWithoutCartInput>
  }

  export type UserUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: MediaUpdateManyWithoutUserNestedInput
    deliveryAddresses?: DeliveryAddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: MediaUncheckedUpdateManyWithoutUserNestedInput
    deliveryAddresses?: DeliveryAddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CartItemUpsertWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
  }

  export type CartItemUpdateManyWithWhereWithoutCartInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutCartInput>
  }

  export type CouponUpsertWithoutCartsInput = {
    update: XOR<CouponUpdateWithoutCartsInput, CouponUncheckedUpdateWithoutCartsInput>
    create: XOR<CouponCreateWithoutCartsInput, CouponUncheckedCreateWithoutCartsInput>
    where?: CouponWhereInput
  }

  export type CouponUpdateToOneWithWhereWithoutCartsInput = {
    where?: CouponWhereInput
    data: XOR<CouponUpdateWithoutCartsInput, CouponUncheckedUpdateWithoutCartsInput>
  }

  export type CouponUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discount?: IntFieldUpdateOperationsInput | number
    cartValue?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    used?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discount?: IntFieldUpdateOperationsInput | number
    cartValue?: IntFieldUpdateOperationsInput | number
    available?: IntFieldUpdateOperationsInput | number
    used?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartCreateWithoutItemsInput = {
    id?: string
    onlinePrice: number
    totalPrice: number
    deliveryFee: number
    totalPriceWithDeliveryFee: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCartInput
    coupon?: CouponCreateNestedOneWithoutCartsInput
  }

  export type CartUncheckedCreateWithoutItemsInput = {
    id?: string
    userId: string
    onlinePrice: number
    totalPrice: number
    deliveryFee: number
    totalPriceWithDeliveryFee: number
    discount: number
    couponId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartCreateOrConnectWithoutItemsInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutCartItemsInput = {
    id?: string
    name: string
    code: string
    price: number
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeCreateNestedManyWithoutProductInput
    discount?: DiscountCreateNestedOneWithoutProductsInput
    packageOption?: PackageOptionCreateNestedOneWithoutProductsInput
    coverImage?: MediaCreateNestedOneWithoutProductCoverInput
    images?: MediaCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldCreateNestedManyWithoutProductInput
    ratings?: RatingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCartItemsInput = {
    id?: string
    name: string
    code: string
    price: number
    discountId?: string | null
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    packageOptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutProductsInput
    priceTable?: PriceRangeUncheckedCreateNestedManyWithoutProductInput
    coverImage?: MediaUncheckedCreateNestedOneWithoutProductCoverInput
    images?: MediaUncheckedCreateNestedManyWithoutProductImagesInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedCreateNestedManyWithoutProductInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCartItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
  }

  export type TextPersonalizationCreateWithoutCartItemInput = {
    id?: string
    name: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TextPersonalizationUncheckedCreateWithoutCartItemInput = {
    id?: string
    name: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TextPersonalizationCreateOrConnectWithoutCartItemInput = {
    where: TextPersonalizationWhereUniqueInput
    create: XOR<TextPersonalizationCreateWithoutCartItemInput, TextPersonalizationUncheckedCreateWithoutCartItemInput>
  }

  export type TextPersonalizationCreateManyCartItemInputEnvelope = {
    data: TextPersonalizationCreateManyCartItemInput | TextPersonalizationCreateManyCartItemInput[]
    skipDuplicates?: boolean
  }

  export type ImagePersonalizationCreateWithoutCartItemInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaCreateNestedManyWithoutImagePersonalizationInput
  }

  export type ImagePersonalizationUncheckedCreateWithoutCartItemInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: MediaUncheckedCreateNestedManyWithoutImagePersonalizationInput
  }

  export type ImagePersonalizationCreateOrConnectWithoutCartItemInput = {
    where: ImagePersonalizationWhereUniqueInput
    create: XOR<ImagePersonalizationCreateWithoutCartItemInput, ImagePersonalizationUncheckedCreateWithoutCartItemInput>
  }

  export type ImagePersonalizationCreateManyCartItemInputEnvelope = {
    data: ImagePersonalizationCreateManyCartItemInput | ImagePersonalizationCreateManyCartItemInput[]
    skipDuplicates?: boolean
  }

  export type CartUpsertWithoutItemsInput = {
    update: XOR<CartUpdateWithoutItemsInput, CartUncheckedUpdateWithoutItemsInput>
    create: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    where?: CartWhereInput
  }

  export type CartUpdateToOneWithWhereWithoutItemsInput = {
    where?: CartWhereInput
    data: XOR<CartUpdateWithoutItemsInput, CartUncheckedUpdateWithoutItemsInput>
  }

  export type CartUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    onlinePrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    totalPriceWithDeliveryFee?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCartNestedInput
    coupon?: CouponUpdateOneWithoutCartsNestedInput
  }

  export type CartUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    onlinePrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    totalPriceWithDeliveryFee?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutCartItemsInput = {
    update: XOR<ProductUpdateWithoutCartItemsInput, ProductUncheckedUpdateWithoutCartItemsInput>
    create: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCartItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCartItemsInput, ProductUncheckedUpdateWithoutCartItemsInput>
  }

  export type ProductUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUpdateManyWithoutProductNestedInput
    discount?: DiscountUpdateOneWithoutProductsNestedInput
    packageOption?: PackageOptionUpdateOneWithoutProductsNestedInput
    coverImage?: MediaUpdateOneWithoutProductCoverNestedInput
    images?: MediaUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUpdateManyWithoutProductNestedInput
    ratings?: RatingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    packageOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUncheckedUpdateManyWithoutProductNestedInput
    coverImage?: MediaUncheckedUpdateOneWithoutProductCoverNestedInput
    images?: MediaUncheckedUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TextPersonalizationUpsertWithWhereUniqueWithoutCartItemInput = {
    where: TextPersonalizationWhereUniqueInput
    update: XOR<TextPersonalizationUpdateWithoutCartItemInput, TextPersonalizationUncheckedUpdateWithoutCartItemInput>
    create: XOR<TextPersonalizationCreateWithoutCartItemInput, TextPersonalizationUncheckedCreateWithoutCartItemInput>
  }

  export type TextPersonalizationUpdateWithWhereUniqueWithoutCartItemInput = {
    where: TextPersonalizationWhereUniqueInput
    data: XOR<TextPersonalizationUpdateWithoutCartItemInput, TextPersonalizationUncheckedUpdateWithoutCartItemInput>
  }

  export type TextPersonalizationUpdateManyWithWhereWithoutCartItemInput = {
    where: TextPersonalizationScalarWhereInput
    data: XOR<TextPersonalizationUpdateManyMutationInput, TextPersonalizationUncheckedUpdateManyWithoutCartItemInput>
  }

  export type TextPersonalizationScalarWhereInput = {
    AND?: TextPersonalizationScalarWhereInput | TextPersonalizationScalarWhereInput[]
    OR?: TextPersonalizationScalarWhereInput[]
    NOT?: TextPersonalizationScalarWhereInput | TextPersonalizationScalarWhereInput[]
    id?: StringFilter<"TextPersonalization"> | string
    name?: StringFilter<"TextPersonalization"> | string
    value?: StringFilter<"TextPersonalization"> | string
    cartItemId?: StringNullableFilter<"TextPersonalization"> | string | null
    createdAt?: DateTimeFilter<"TextPersonalization"> | Date | string
    updatedAt?: DateTimeFilter<"TextPersonalization"> | Date | string
  }

  export type ImagePersonalizationUpsertWithWhereUniqueWithoutCartItemInput = {
    where: ImagePersonalizationWhereUniqueInput
    update: XOR<ImagePersonalizationUpdateWithoutCartItemInput, ImagePersonalizationUncheckedUpdateWithoutCartItemInput>
    create: XOR<ImagePersonalizationCreateWithoutCartItemInput, ImagePersonalizationUncheckedCreateWithoutCartItemInput>
  }

  export type ImagePersonalizationUpdateWithWhereUniqueWithoutCartItemInput = {
    where: ImagePersonalizationWhereUniqueInput
    data: XOR<ImagePersonalizationUpdateWithoutCartItemInput, ImagePersonalizationUncheckedUpdateWithoutCartItemInput>
  }

  export type ImagePersonalizationUpdateManyWithWhereWithoutCartItemInput = {
    where: ImagePersonalizationScalarWhereInput
    data: XOR<ImagePersonalizationUpdateManyMutationInput, ImagePersonalizationUncheckedUpdateManyWithoutCartItemInput>
  }

  export type ImagePersonalizationScalarWhereInput = {
    AND?: ImagePersonalizationScalarWhereInput | ImagePersonalizationScalarWhereInput[]
    OR?: ImagePersonalizationScalarWhereInput[]
    NOT?: ImagePersonalizationScalarWhereInput | ImagePersonalizationScalarWhereInput[]
    id?: StringFilter<"ImagePersonalization"> | string
    name?: StringFilter<"ImagePersonalization"> | string
    cartItemId?: StringNullableFilter<"ImagePersonalization"> | string | null
    createdAt?: DateTimeFilter<"ImagePersonalization"> | Date | string
    updatedAt?: DateTimeFilter<"ImagePersonalization"> | Date | string
  }

  export type CartItemCreateWithoutTextPersonalizationsInput = {
    id?: string
    price: number
    deliveryFee: number
    quantity: number
    fontType: $Enums.FontType
    packageOptionSelected: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: CartCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutCartItemsInput
    imagePersonalizations?: ImagePersonalizationCreateNestedManyWithoutCartItemInput
  }

  export type CartItemUncheckedCreateWithoutTextPersonalizationsInput = {
    id?: string
    cartId: string
    productId: string
    price: number
    deliveryFee: number
    quantity: number
    fontType: $Enums.FontType
    packageOptionSelected: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePersonalizations?: ImagePersonalizationUncheckedCreateNestedManyWithoutCartItemInput
  }

  export type CartItemCreateOrConnectWithoutTextPersonalizationsInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutTextPersonalizationsInput, CartItemUncheckedCreateWithoutTextPersonalizationsInput>
  }

  export type CartItemUpsertWithoutTextPersonalizationsInput = {
    update: XOR<CartItemUpdateWithoutTextPersonalizationsInput, CartItemUncheckedUpdateWithoutTextPersonalizationsInput>
    create: XOR<CartItemCreateWithoutTextPersonalizationsInput, CartItemUncheckedCreateWithoutTextPersonalizationsInput>
    where?: CartItemWhereInput
  }

  export type CartItemUpdateToOneWithWhereWithoutTextPersonalizationsInput = {
    where?: CartItemWhereInput
    data: XOR<CartItemUpdateWithoutTextPersonalizationsInput, CartItemUncheckedUpdateWithoutTextPersonalizationsInput>
  }

  export type CartItemUpdateWithoutTextPersonalizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    fontType?: EnumFontTypeFieldUpdateOperationsInput | $Enums.FontType
    packageOptionSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutCartItemsNestedInput
    imagePersonalizations?: ImagePersonalizationUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateWithoutTextPersonalizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    fontType?: EnumFontTypeFieldUpdateOperationsInput | $Enums.FontType
    packageOptionSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePersonalizations?: ImagePersonalizationUncheckedUpdateManyWithoutCartItemNestedInput
  }

  export type MediaCreateWithoutImagePersonalizationInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    updatedAt?: Date | string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutMediaInput
    category?: CategoryCreateNestedOneWithoutImageInput
    deliveryService?: DeliveryServiceCreateNestedOneWithoutPdfInput
    desktopBannerImage?: BannerCreateNestedOneWithoutDesktopImageInput
    mobileBannerImage?: BannerCreateNestedOneWithoutMobileImageInput
    productCover?: ProductCreateNestedOneWithoutCoverImageInput
    productImages?: ProductCreateNestedOneWithoutImagesInput
  }

  export type MediaUncheckedCreateWithoutImagePersonalizationInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    userId?: string | null
    categoryId?: string | null
    deliveryServiceId?: string | null
    desktopBannerImageId?: string | null
    mobileBannerImageId?: string | null
    productCoverId?: string | null
    productImagesId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type MediaCreateOrConnectWithoutImagePersonalizationInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutImagePersonalizationInput, MediaUncheckedCreateWithoutImagePersonalizationInput>
  }

  export type MediaCreateManyImagePersonalizationInputEnvelope = {
    data: MediaCreateManyImagePersonalizationInput | MediaCreateManyImagePersonalizationInput[]
    skipDuplicates?: boolean
  }

  export type CartItemCreateWithoutImagePersonalizationsInput = {
    id?: string
    price: number
    deliveryFee: number
    quantity: number
    fontType: $Enums.FontType
    packageOptionSelected: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: CartCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutCartItemsInput
    textPersonalizations?: TextPersonalizationCreateNestedManyWithoutCartItemInput
  }

  export type CartItemUncheckedCreateWithoutImagePersonalizationsInput = {
    id?: string
    cartId: string
    productId: string
    price: number
    deliveryFee: number
    quantity: number
    fontType: $Enums.FontType
    packageOptionSelected: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    textPersonalizations?: TextPersonalizationUncheckedCreateNestedManyWithoutCartItemInput
  }

  export type CartItemCreateOrConnectWithoutImagePersonalizationsInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutImagePersonalizationsInput, CartItemUncheckedCreateWithoutImagePersonalizationsInput>
  }

  export type MediaUpsertWithWhereUniqueWithoutImagePersonalizationInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutImagePersonalizationInput, MediaUncheckedUpdateWithoutImagePersonalizationInput>
    create: XOR<MediaCreateWithoutImagePersonalizationInput, MediaUncheckedCreateWithoutImagePersonalizationInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutImagePersonalizationInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutImagePersonalizationInput, MediaUncheckedUpdateWithoutImagePersonalizationInput>
  }

  export type MediaUpdateManyWithWhereWithoutImagePersonalizationInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutImagePersonalizationInput>
  }

  export type CartItemUpsertWithoutImagePersonalizationsInput = {
    update: XOR<CartItemUpdateWithoutImagePersonalizationsInput, CartItemUncheckedUpdateWithoutImagePersonalizationsInput>
    create: XOR<CartItemCreateWithoutImagePersonalizationsInput, CartItemUncheckedCreateWithoutImagePersonalizationsInput>
    where?: CartItemWhereInput
  }

  export type CartItemUpdateToOneWithWhereWithoutImagePersonalizationsInput = {
    where?: CartItemWhereInput
    data: XOR<CartItemUpdateWithoutImagePersonalizationsInput, CartItemUncheckedUpdateWithoutImagePersonalizationsInput>
  }

  export type CartItemUpdateWithoutImagePersonalizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    fontType?: EnumFontTypeFieldUpdateOperationsInput | $Enums.FontType
    packageOptionSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutCartItemsNestedInput
    textPersonalizations?: TextPersonalizationUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateWithoutImagePersonalizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    fontType?: EnumFontTypeFieldUpdateOperationsInput | $Enums.FontType
    packageOptionSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textPersonalizations?: TextPersonalizationUncheckedUpdateManyWithoutCartItemNestedInput
  }

  export type UserCreateWithoutDeliveryAddressesInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.UserRoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    media?: MediaCreateNestedManyWithoutUserInput
    cart?: CartCreateNestedOneWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeliveryAddressesInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.UserRoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    media?: MediaUncheckedCreateNestedManyWithoutUserInput
    cart?: CartUncheckedCreateNestedOneWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeliveryAddressesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeliveryAddressesInput, UserUncheckedCreateWithoutDeliveryAddressesInput>
  }

  export type UserUpsertWithoutDeliveryAddressesInput = {
    update: XOR<UserUpdateWithoutDeliveryAddressesInput, UserUncheckedUpdateWithoutDeliveryAddressesInput>
    create: XOR<UserCreateWithoutDeliveryAddressesInput, UserUncheckedCreateWithoutDeliveryAddressesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeliveryAddressesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeliveryAddressesInput, UserUncheckedUpdateWithoutDeliveryAddressesInput>
  }

  export type UserUpdateWithoutDeliveryAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: MediaUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeliveryAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: MediaUncheckedUpdateManyWithoutUserNestedInput
    cart?: CartUncheckedUpdateOneWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.UserRoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    media?: MediaCreateNestedManyWithoutUserInput
    cart?: CartCreateNestedOneWithoutUserInput
    deliveryAddresses?: DeliveryAddressCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.UserRoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    media?: MediaUncheckedCreateNestedManyWithoutUserInput
    cart?: CartUncheckedCreateNestedOneWithoutUserInput
    deliveryAddresses?: DeliveryAddressUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: MediaUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneWithoutUserNestedInput
    deliveryAddresses?: DeliveryAddressUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: MediaUncheckedUpdateManyWithoutUserNestedInput
    cart?: CartUncheckedUpdateOneWithoutUserNestedInput
    deliveryAddresses?: DeliveryAddressUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MediaCreateWithoutUserInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    updatedAt?: Date | string
    createdAt?: Date | string
    category?: CategoryCreateNestedOneWithoutImageInput
    deliveryService?: DeliveryServiceCreateNestedOneWithoutPdfInput
    desktopBannerImage?: BannerCreateNestedOneWithoutDesktopImageInput
    mobileBannerImage?: BannerCreateNestedOneWithoutMobileImageInput
    productCover?: ProductCreateNestedOneWithoutCoverImageInput
    productImages?: ProductCreateNestedOneWithoutImagesInput
    imagePersonalization?: ImagePersonalizationCreateNestedOneWithoutImagesInput
  }

  export type MediaUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    categoryId?: string | null
    deliveryServiceId?: string | null
    desktopBannerImageId?: string | null
    mobileBannerImageId?: string | null
    productCoverId?: string | null
    productImagesId?: string | null
    imagePersonalizationId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type MediaCreateOrConnectWithoutUserInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutUserInput, MediaUncheckedCreateWithoutUserInput>
  }

  export type MediaCreateManyUserInputEnvelope = {
    data: MediaCreateManyUserInput | MediaCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CartCreateWithoutUserInput = {
    id?: string
    onlinePrice: number
    totalPrice: number
    deliveryFee: number
    totalPriceWithDeliveryFee: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemCreateNestedManyWithoutCartInput
    coupon?: CouponCreateNestedOneWithoutCartsInput
  }

  export type CartUncheckedCreateWithoutUserInput = {
    id?: string
    onlinePrice: number
    totalPrice: number
    deliveryFee: number
    totalPriceWithDeliveryFee: number
    discount: number
    couponId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartCreateOrConnectWithoutUserInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
  }

  export type DeliveryAddressCreateWithoutUserInput = {
    id?: string
    name: string
    address: string
    city: string
    zip: string
    phone: string
    email: string
    note?: string | null
    type: $Enums.DeliveryAddressType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryAddressUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    address: string
    city: string
    zip: string
    phone: string
    email: string
    note?: string | null
    type: $Enums.DeliveryAddressType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryAddressCreateOrConnectWithoutUserInput = {
    where: DeliveryAddressWhereUniqueInput
    create: XOR<DeliveryAddressCreateWithoutUserInput, DeliveryAddressUncheckedCreateWithoutUserInput>
  }

  export type DeliveryAddressCreateManyUserInputEnvelope = {
    data: DeliveryAddressCreateManyUserInput | DeliveryAddressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    orderNumber: string
    termsAccepted?: boolean
    shippingNumber?: string
    deliveryType: $Enums.OrderDeliveryType
    paymentType: $Enums.OrderPaymentType
    status?: $Enums.OrderStatusType
    mediaRemoved?: boolean
    paymentId?: string | null
    paymentStatus?: $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode?: string | null
    paymentStatusCode?: string | null
    paymentTimestamp?: string | null
    paymentAmount?: string | null
    paymentCurrency?: string | null
    paymentBrand?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    checkoutId?: string | null
    cart: JsonNullValueInput | InputJsonValue
    deliveryName?: string
    deliveryAddress?: string
    deliveryCity?: string
    deliveryZip?: string
    deliveryPhone?: string
    deliveryEmail?: string
    deliveryNote?: string
    pickupName?: string
    pickupPhone?: string
    pickupEmail?: string
    billingName?: string
    billingAddress?: string
    billingCity?: string
    billingZip?: string
    billingPhone?: string
    billingEmail?: string
    billingNote?: string
    deliveryServiceName?: string
    orderOnlinePrice: number
    orderDiscount: number
    orderDeliveryFee: number
    orderTotalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    orderNumber: string
    termsAccepted?: boolean
    shippingNumber?: string
    deliveryType: $Enums.OrderDeliveryType
    paymentType: $Enums.OrderPaymentType
    status?: $Enums.OrderStatusType
    mediaRemoved?: boolean
    paymentId?: string | null
    paymentStatus?: $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode?: string | null
    paymentStatusCode?: string | null
    paymentTimestamp?: string | null
    paymentAmount?: string | null
    paymentCurrency?: string | null
    paymentBrand?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    checkoutId?: string | null
    cart: JsonNullValueInput | InputJsonValue
    deliveryName?: string
    deliveryAddress?: string
    deliveryCity?: string
    deliveryZip?: string
    deliveryPhone?: string
    deliveryEmail?: string
    deliveryNote?: string
    pickupName?: string
    pickupPhone?: string
    pickupEmail?: string
    billingName?: string
    billingAddress?: string
    billingCity?: string
    billingZip?: string
    billingPhone?: string
    billingEmail?: string
    billingNote?: string
    deliveryServiceName?: string
    orderOnlinePrice: number
    orderDiscount: number
    orderDeliveryFee: number
    orderTotalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutUserInput = {
    id?: string
    name: string
    score: number
    comment: string
    status?: $Enums.RatingStatusType
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateWithoutUserInput = {
    id?: string
    productId: string
    name: string
    score: number
    comment: string
    status?: $Enums.RatingStatusType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateOrConnectWithoutUserInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput>
  }

  export type RatingCreateManyUserInputEnvelope = {
    data: RatingCreateManyUserInput | RatingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id: string
    scope?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id: string
    scope?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MediaUpsertWithWhereUniqueWithoutUserInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutUserInput, MediaUncheckedUpdateWithoutUserInput>
    create: XOR<MediaCreateWithoutUserInput, MediaUncheckedCreateWithoutUserInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutUserInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutUserInput, MediaUncheckedUpdateWithoutUserInput>
  }

  export type MediaUpdateManyWithWhereWithoutUserInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutUserInput>
  }

  export type CartUpsertWithoutUserInput = {
    update: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
    where?: CartWhereInput
  }

  export type CartUpdateToOneWithWhereWithoutUserInput = {
    where?: CartWhereInput
    data: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
  }

  export type CartUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    onlinePrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    totalPriceWithDeliveryFee?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUpdateManyWithoutCartNestedInput
    coupon?: CouponUpdateOneWithoutCartsNestedInput
  }

  export type CartUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    onlinePrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    totalPriceWithDeliveryFee?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type DeliveryAddressUpsertWithWhereUniqueWithoutUserInput = {
    where: DeliveryAddressWhereUniqueInput
    update: XOR<DeliveryAddressUpdateWithoutUserInput, DeliveryAddressUncheckedUpdateWithoutUserInput>
    create: XOR<DeliveryAddressCreateWithoutUserInput, DeliveryAddressUncheckedCreateWithoutUserInput>
  }

  export type DeliveryAddressUpdateWithWhereUniqueWithoutUserInput = {
    where: DeliveryAddressWhereUniqueInput
    data: XOR<DeliveryAddressUpdateWithoutUserInput, DeliveryAddressUncheckedUpdateWithoutUserInput>
  }

  export type DeliveryAddressUpdateManyWithWhereWithoutUserInput = {
    where: DeliveryAddressScalarWhereInput
    data: XOR<DeliveryAddressUpdateManyMutationInput, DeliveryAddressUncheckedUpdateManyWithoutUserInput>
  }

  export type DeliveryAddressScalarWhereInput = {
    AND?: DeliveryAddressScalarWhereInput | DeliveryAddressScalarWhereInput[]
    OR?: DeliveryAddressScalarWhereInput[]
    NOT?: DeliveryAddressScalarWhereInput | DeliveryAddressScalarWhereInput[]
    id?: StringFilter<"DeliveryAddress"> | string
    name?: StringFilter<"DeliveryAddress"> | string
    address?: StringFilter<"DeliveryAddress"> | string
    city?: StringFilter<"DeliveryAddress"> | string
    zip?: StringFilter<"DeliveryAddress"> | string
    phone?: StringFilter<"DeliveryAddress"> | string
    email?: StringFilter<"DeliveryAddress"> | string
    note?: StringNullableFilter<"DeliveryAddress"> | string | null
    type?: EnumDeliveryAddressTypeFilter<"DeliveryAddress"> | $Enums.DeliveryAddressType
    userId?: StringFilter<"DeliveryAddress"> | string
    createdAt?: DateTimeFilter<"DeliveryAddress"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryAddress"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    termsAccepted?: BoolFilter<"Order"> | boolean
    shippingNumber?: StringFilter<"Order"> | string
    deliveryType?: EnumOrderDeliveryTypeFilter<"Order"> | $Enums.OrderDeliveryType
    paymentType?: EnumOrderPaymentTypeFilter<"Order"> | $Enums.OrderPaymentType
    status?: EnumOrderStatusTypeFilter<"Order"> | $Enums.OrderStatusType
    mediaRemoved?: BoolFilter<"Order"> | boolean
    paymentId?: StringNullableFilter<"Order"> | string | null
    paymentStatus?: EnumOrderPaymentStatusTypeNullableFilter<"Order"> | $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode?: StringNullableFilter<"Order"> | string | null
    paymentStatusCode?: StringNullableFilter<"Order"> | string | null
    paymentTimestamp?: StringNullableFilter<"Order"> | string | null
    paymentAmount?: StringNullableFilter<"Order"> | string | null
    paymentCurrency?: StringNullableFilter<"Order"> | string | null
    paymentBrand?: StringNullableFilter<"Order"> | string | null
    paymentDetails?: JsonNullableFilter<"Order">
    checkoutId?: StringNullableFilter<"Order"> | string | null
    cart?: JsonFilter<"Order">
    deliveryName?: StringFilter<"Order"> | string
    deliveryAddress?: StringFilter<"Order"> | string
    deliveryCity?: StringFilter<"Order"> | string
    deliveryZip?: StringFilter<"Order"> | string
    deliveryPhone?: StringFilter<"Order"> | string
    deliveryEmail?: StringFilter<"Order"> | string
    deliveryNote?: StringFilter<"Order"> | string
    pickupName?: StringFilter<"Order"> | string
    pickupPhone?: StringFilter<"Order"> | string
    pickupEmail?: StringFilter<"Order"> | string
    billingName?: StringFilter<"Order"> | string
    billingAddress?: StringFilter<"Order"> | string
    billingCity?: StringFilter<"Order"> | string
    billingZip?: StringFilter<"Order"> | string
    billingPhone?: StringFilter<"Order"> | string
    billingEmail?: StringFilter<"Order"> | string
    billingNote?: StringFilter<"Order"> | string
    deliveryServiceName?: StringFilter<"Order"> | string
    orderOnlinePrice?: IntFilter<"Order"> | number
    orderDiscount?: IntFilter<"Order"> | number
    orderDeliveryFee?: IntFilter<"Order"> | number
    orderTotalPrice?: IntFilter<"Order"> | number
    userId?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type RatingUpsertWithWhereUniqueWithoutUserInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutUserInput, RatingUncheckedUpdateWithoutUserInput>
    create: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutUserInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutUserInput, RatingUncheckedUpdateWithoutUserInput>
  }

  export type RatingUpdateManyWithWhereWithoutUserInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    scope?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    impersonatedBy?: StringNullableFilter<"Session"> | string | null
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.UserRoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    media?: MediaCreateNestedManyWithoutUserInput
    cart?: CartCreateNestedOneWithoutUserInput
    deliveryAddresses?: DeliveryAddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.UserRoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    media?: MediaUncheckedCreateNestedManyWithoutUserInput
    cart?: CartUncheckedCreateNestedOneWithoutUserInput
    deliveryAddresses?: DeliveryAddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: MediaUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneWithoutUserNestedInput
    deliveryAddresses?: DeliveryAddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: MediaUncheckedUpdateManyWithoutUserNestedInput
    cart?: CartUncheckedUpdateOneWithoutUserNestedInput
    deliveryAddresses?: DeliveryAddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.UserRoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    media?: MediaCreateNestedManyWithoutUserInput
    cart?: CartCreateNestedOneWithoutUserInput
    deliveryAddresses?: DeliveryAddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    role?: $Enums.UserRoleType
    createdAt?: Date | string
    updatedAt?: Date | string
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    media?: MediaUncheckedCreateNestedManyWithoutUserInput
    cart?: CartUncheckedCreateNestedOneWithoutUserInput
    deliveryAddresses?: DeliveryAddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: MediaUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneWithoutUserNestedInput
    deliveryAddresses?: DeliveryAddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleTypeFieldUpdateOperationsInput | $Enums.UserRoleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media?: MediaUncheckedUpdateManyWithoutUserNestedInput
    cart?: CartUncheckedUpdateOneWithoutUserNestedInput
    deliveryAddresses?: DeliveryAddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceTable?: PriceRangeUpdateManyWithoutProductNestedInput
    discount?: DiscountUpdateOneWithoutProductsNestedInput
    packageOption?: PackageOptionUpdateOneWithoutProductsNestedInput
    coverImage?: MediaUpdateOneWithoutProductCoverNestedInput
    images?: MediaUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    ratings?: RatingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    packageOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceTable?: PriceRangeUncheckedUpdateManyWithoutProductNestedInput
    coverImage?: MediaUncheckedUpdateOneWithoutProductCoverNestedInput
    images?: MediaUncheckedUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    packageOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyPackageOptionInput = {
    id?: string
    name: string
    code: string
    price: number
    discountId?: string | null
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutPackageOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUpdateManyWithoutProductNestedInput
    discount?: DiscountUpdateOneWithoutProductsNestedInput
    coverImage?: MediaUpdateOneWithoutProductCoverNestedInput
    images?: MediaUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    ratings?: RatingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPackageOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUncheckedUpdateManyWithoutProductNestedInput
    coverImage?: MediaUncheckedUpdateOneWithoutProductCoverNestedInput
    images?: MediaUncheckedUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutPackageOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartCreateManyCouponInput = {
    id?: string
    userId: string
    onlinePrice: number
    totalPrice: number
    deliveryFee: number
    totalPriceWithDeliveryFee: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    onlinePrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    totalPriceWithDeliveryFee?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCartNestedInput
    items?: CartItemUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    onlinePrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    totalPriceWithDeliveryFee?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateManyWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    onlinePrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    totalPriceWithDeliveryFee?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceRangeCreateManyDeliveryFeeInput = {
    id?: string
    from: number
    to: number
    price: number
    productId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceRangeUpdateWithoutDeliveryFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneWithoutPriceTableNestedInput
  }

  export type PriceRangeUncheckedUpdateWithoutDeliveryFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceRangeUncheckedUpdateManyWithoutDeliveryFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyDiscountInput = {
    id?: string
    name: string
    code: string
    price: number
    material: string
    dimensions: string
    personalization: string
    description: string
    delivery: $Enums.DeliveryType
    inStock?: boolean
    trending?: boolean
    packageOptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUpdateManyWithoutProductNestedInput
    packageOption?: PackageOptionUpdateOneWithoutProductsNestedInput
    coverImage?: MediaUpdateOneWithoutProductCoverNestedInput
    images?: MediaUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    ratings?: RatingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    packageOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutProductsNestedInput
    priceTable?: PriceRangeUncheckedUpdateManyWithoutProductNestedInput
    coverImage?: MediaUncheckedUpdateOneWithoutProductCoverNestedInput
    images?: MediaUncheckedUpdateManyWithoutProductImagesNestedInput
    imagePersonalizationFields?: ImagePersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    textPersonalizationFields?: TextPersonalizationFieldUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    material?: StringFieldUpdateOperationsInput | string
    dimensions?: StringFieldUpdateOperationsInput | string
    personalization?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    delivery?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    inStock?: BoolFieldUpdateOperationsInput | boolean
    trending?: BoolFieldUpdateOperationsInput | boolean
    packageOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceRangeCreateManyProductInput = {
    id?: string
    from: number
    to: number
    price: number
    deliveryFeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaCreateManyProductImagesInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    userId?: string | null
    categoryId?: string | null
    deliveryServiceId?: string | null
    desktopBannerImageId?: string | null
    mobileBannerImageId?: string | null
    productCoverId?: string | null
    imagePersonalizationId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type ImagePersonalizationFieldCreateManyProductInput = {
    id?: string
    name: string
    min: number
    max?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TextPersonalizationFieldCreateManyProductInput = {
    id?: string
    name: string
    placeholder: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemCreateManyProductInput = {
    id?: string
    cartId: string
    price: number
    deliveryFee: number
    quantity: number
    fontType: $Enums.FontType
    packageOptionSelected: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateManyProductInput = {
    id?: string
    userId: string
    name: string
    score: number
    comment: string
    status?: $Enums.RatingStatusType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    special?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: MediaUpdateOneWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    special?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: MediaUncheckedUpdateOneWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    special?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceRangeUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryFee?: DeliveryFeeUpdateOneRequiredWithoutPriceRangeNestedInput
  }

  export type PriceRangeUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    deliveryFeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceRangeUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    deliveryFeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUpdateWithoutProductImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMediaNestedInput
    category?: CategoryUpdateOneWithoutImageNestedInput
    deliveryService?: DeliveryServiceUpdateOneWithoutPdfNestedInput
    desktopBannerImage?: BannerUpdateOneWithoutDesktopImageNestedInput
    mobileBannerImage?: BannerUpdateOneWithoutMobileImageNestedInput
    productCover?: ProductUpdateOneWithoutCoverImageNestedInput
    imagePersonalization?: ImagePersonalizationUpdateOneWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateWithoutProductImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    desktopBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    mobileBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    productCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    imagePersonalizationId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyWithoutProductImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    desktopBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    mobileBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    productCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    imagePersonalizationId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImagePersonalizationFieldUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    min?: IntFieldUpdateOperationsInput | number
    max?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImagePersonalizationFieldUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    min?: IntFieldUpdateOperationsInput | number
    max?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImagePersonalizationFieldUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    min?: IntFieldUpdateOperationsInput | number
    max?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextPersonalizationFieldUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextPersonalizationFieldUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextPersonalizationFieldUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    fontType?: EnumFontTypeFieldUpdateOperationsInput | $Enums.FontType
    packageOptionSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
    textPersonalizations?: TextPersonalizationUpdateManyWithoutCartItemNestedInput
    imagePersonalizations?: ImagePersonalizationUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    fontType?: EnumFontTypeFieldUpdateOperationsInput | $Enums.FontType
    packageOptionSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textPersonalizations?: TextPersonalizationUncheckedUpdateManyWithoutCartItemNestedInput
    imagePersonalizations?: ImagePersonalizationUncheckedUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    fontType?: EnumFontTypeFieldUpdateOperationsInput | $Enums.FontType
    packageOptionSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumRatingStatusTypeFieldUpdateOperationsInput | $Enums.RatingStatusType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumRatingStatusTypeFieldUpdateOperationsInput | $Enums.RatingStatusType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumRatingStatusTypeFieldUpdateOperationsInput | $Enums.RatingStatusType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateManyCartInput = {
    id?: string
    productId: string
    price: number
    deliveryFee: number
    quantity: number
    fontType: $Enums.FontType
    packageOptionSelected: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    fontType?: EnumFontTypeFieldUpdateOperationsInput | $Enums.FontType
    packageOptionSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutCartItemsNestedInput
    textPersonalizations?: TextPersonalizationUpdateManyWithoutCartItemNestedInput
    imagePersonalizations?: ImagePersonalizationUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    fontType?: EnumFontTypeFieldUpdateOperationsInput | $Enums.FontType
    packageOptionSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    textPersonalizations?: TextPersonalizationUncheckedUpdateManyWithoutCartItemNestedInput
    imagePersonalizations?: ImagePersonalizationUncheckedUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateManyWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    deliveryFee?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    fontType?: EnumFontTypeFieldUpdateOperationsInput | $Enums.FontType
    packageOptionSelected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextPersonalizationCreateManyCartItemInput = {
    id?: string
    name: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImagePersonalizationCreateManyCartItemInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TextPersonalizationUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextPersonalizationUncheckedUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextPersonalizationUncheckedUpdateManyWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImagePersonalizationUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUpdateManyWithoutImagePersonalizationNestedInput
  }

  export type ImagePersonalizationUncheckedUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: MediaUncheckedUpdateManyWithoutImagePersonalizationNestedInput
  }

  export type ImagePersonalizationUncheckedUpdateManyWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateManyImagePersonalizationInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    userId?: string | null
    categoryId?: string | null
    deliveryServiceId?: string | null
    desktopBannerImageId?: string | null
    mobileBannerImageId?: string | null
    productCoverId?: string | null
    productImagesId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type MediaUpdateWithoutImagePersonalizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMediaNestedInput
    category?: CategoryUpdateOneWithoutImageNestedInput
    deliveryService?: DeliveryServiceUpdateOneWithoutPdfNestedInput
    desktopBannerImage?: BannerUpdateOneWithoutDesktopImageNestedInput
    mobileBannerImage?: BannerUpdateOneWithoutMobileImageNestedInput
    productCover?: ProductUpdateOneWithoutCoverImageNestedInput
    productImages?: ProductUpdateOneWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateWithoutImagePersonalizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    desktopBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    mobileBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    productCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    productImagesId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyWithoutImagePersonalizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    desktopBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    mobileBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    productCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    productImagesId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateManyUserInput = {
    id?: string
    name: string
    key: string
    type: string
    url: string
    categoryId?: string | null
    deliveryServiceId?: string | null
    desktopBannerImageId?: string | null
    mobileBannerImageId?: string | null
    productCoverId?: string | null
    productImagesId?: string | null
    imagePersonalizationId?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type DeliveryAddressCreateManyUserInput = {
    id?: string
    name: string
    address: string
    city: string
    zip: string
    phone: string
    email: string
    note?: string | null
    type: $Enums.DeliveryAddressType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyUserInput = {
    id?: string
    orderNumber: string
    termsAccepted?: boolean
    shippingNumber?: string
    deliveryType: $Enums.OrderDeliveryType
    paymentType: $Enums.OrderPaymentType
    status?: $Enums.OrderStatusType
    mediaRemoved?: boolean
    paymentId?: string | null
    paymentStatus?: $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode?: string | null
    paymentStatusCode?: string | null
    paymentTimestamp?: string | null
    paymentAmount?: string | null
    paymentCurrency?: string | null
    paymentBrand?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    checkoutId?: string | null
    cart: JsonNullValueInput | InputJsonValue
    deliveryName?: string
    deliveryAddress?: string
    deliveryCity?: string
    deliveryZip?: string
    deliveryPhone?: string
    deliveryEmail?: string
    deliveryNote?: string
    pickupName?: string
    pickupPhone?: string
    pickupEmail?: string
    billingName?: string
    billingAddress?: string
    billingCity?: string
    billingZip?: string
    billingPhone?: string
    billingEmail?: string
    billingNote?: string
    deliveryServiceName?: string
    orderOnlinePrice: number
    orderDiscount: number
    orderDeliveryFee: number
    orderTotalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateManyUserInput = {
    id?: string
    productId: string
    name: string
    score: number
    comment: string
    status?: $Enums.RatingStatusType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id: string
    scope?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
  }

  export type SessionCreateManyUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
  }

  export type MediaUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutImageNestedInput
    deliveryService?: DeliveryServiceUpdateOneWithoutPdfNestedInput
    desktopBannerImage?: BannerUpdateOneWithoutDesktopImageNestedInput
    mobileBannerImage?: BannerUpdateOneWithoutMobileImageNestedInput
    productCover?: ProductUpdateOneWithoutCoverImageNestedInput
    productImages?: ProductUpdateOneWithoutImagesNestedInput
    imagePersonalization?: ImagePersonalizationUpdateOneWithoutImagesNestedInput
  }

  export type MediaUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    desktopBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    mobileBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    productCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    productImagesId?: NullableStringFieldUpdateOperationsInput | string | null
    imagePersonalizationId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    desktopBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    mobileBannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    productCoverId?: NullableStringFieldUpdateOperationsInput | string | null
    productImagesId?: NullableStringFieldUpdateOperationsInput | string | null
    imagePersonalizationId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryAddressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDeliveryAddressTypeFieldUpdateOperationsInput | $Enums.DeliveryAddressType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryAddressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDeliveryAddressTypeFieldUpdateOperationsInput | $Enums.DeliveryAddressType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryAddressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDeliveryAddressTypeFieldUpdateOperationsInput | $Enums.DeliveryAddressType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    shippingNumber?: StringFieldUpdateOperationsInput | string
    deliveryType?: EnumOrderDeliveryTypeFieldUpdateOperationsInput | $Enums.OrderDeliveryType
    paymentType?: EnumOrderPaymentTypeFieldUpdateOperationsInput | $Enums.OrderPaymentType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    mediaRemoved?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableEnumOrderPaymentStatusTypeFieldUpdateOperationsInput | $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatusCode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTimestamp?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBrand?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    checkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    cart?: JsonNullValueInput | InputJsonValue
    deliveryName?: StringFieldUpdateOperationsInput | string
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    deliveryCity?: StringFieldUpdateOperationsInput | string
    deliveryZip?: StringFieldUpdateOperationsInput | string
    deliveryPhone?: StringFieldUpdateOperationsInput | string
    deliveryEmail?: StringFieldUpdateOperationsInput | string
    deliveryNote?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhone?: StringFieldUpdateOperationsInput | string
    pickupEmail?: StringFieldUpdateOperationsInput | string
    billingName?: StringFieldUpdateOperationsInput | string
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingZip?: StringFieldUpdateOperationsInput | string
    billingPhone?: StringFieldUpdateOperationsInput | string
    billingEmail?: StringFieldUpdateOperationsInput | string
    billingNote?: StringFieldUpdateOperationsInput | string
    deliveryServiceName?: StringFieldUpdateOperationsInput | string
    orderOnlinePrice?: IntFieldUpdateOperationsInput | number
    orderDiscount?: IntFieldUpdateOperationsInput | number
    orderDeliveryFee?: IntFieldUpdateOperationsInput | number
    orderTotalPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    shippingNumber?: StringFieldUpdateOperationsInput | string
    deliveryType?: EnumOrderDeliveryTypeFieldUpdateOperationsInput | $Enums.OrderDeliveryType
    paymentType?: EnumOrderPaymentTypeFieldUpdateOperationsInput | $Enums.OrderPaymentType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    mediaRemoved?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableEnumOrderPaymentStatusTypeFieldUpdateOperationsInput | $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatusCode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTimestamp?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBrand?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    checkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    cart?: JsonNullValueInput | InputJsonValue
    deliveryName?: StringFieldUpdateOperationsInput | string
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    deliveryCity?: StringFieldUpdateOperationsInput | string
    deliveryZip?: StringFieldUpdateOperationsInput | string
    deliveryPhone?: StringFieldUpdateOperationsInput | string
    deliveryEmail?: StringFieldUpdateOperationsInput | string
    deliveryNote?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhone?: StringFieldUpdateOperationsInput | string
    pickupEmail?: StringFieldUpdateOperationsInput | string
    billingName?: StringFieldUpdateOperationsInput | string
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingZip?: StringFieldUpdateOperationsInput | string
    billingPhone?: StringFieldUpdateOperationsInput | string
    billingEmail?: StringFieldUpdateOperationsInput | string
    billingNote?: StringFieldUpdateOperationsInput | string
    deliveryServiceName?: StringFieldUpdateOperationsInput | string
    orderOnlinePrice?: IntFieldUpdateOperationsInput | number
    orderDiscount?: IntFieldUpdateOperationsInput | number
    orderDeliveryFee?: IntFieldUpdateOperationsInput | number
    orderTotalPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    shippingNumber?: StringFieldUpdateOperationsInput | string
    deliveryType?: EnumOrderDeliveryTypeFieldUpdateOperationsInput | $Enums.OrderDeliveryType
    paymentType?: EnumOrderPaymentTypeFieldUpdateOperationsInput | $Enums.OrderPaymentType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    mediaRemoved?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableEnumOrderPaymentStatusTypeFieldUpdateOperationsInput | $Enums.OrderPaymentStatusType | null
    paymentAuthorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatusCode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTimestamp?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentBrand?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    checkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    cart?: JsonNullValueInput | InputJsonValue
    deliveryName?: StringFieldUpdateOperationsInput | string
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    deliveryCity?: StringFieldUpdateOperationsInput | string
    deliveryZip?: StringFieldUpdateOperationsInput | string
    deliveryPhone?: StringFieldUpdateOperationsInput | string
    deliveryEmail?: StringFieldUpdateOperationsInput | string
    deliveryNote?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhone?: StringFieldUpdateOperationsInput | string
    pickupEmail?: StringFieldUpdateOperationsInput | string
    billingName?: StringFieldUpdateOperationsInput | string
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingZip?: StringFieldUpdateOperationsInput | string
    billingPhone?: StringFieldUpdateOperationsInput | string
    billingEmail?: StringFieldUpdateOperationsInput | string
    billingNote?: StringFieldUpdateOperationsInput | string
    deliveryServiceName?: StringFieldUpdateOperationsInput | string
    orderOnlinePrice?: IntFieldUpdateOperationsInput | number
    orderDiscount?: IntFieldUpdateOperationsInput | number
    orderDeliveryFee?: IntFieldUpdateOperationsInput | number
    orderTotalPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumRatingStatusTypeFieldUpdateOperationsInput | $Enums.RatingStatusType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumRatingStatusTypeFieldUpdateOperationsInput | $Enums.RatingStatusType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumRatingStatusTypeFieldUpdateOperationsInput | $Enums.RatingStatusType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}